<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>The data mask ambiguity — topic-data-mask-ambiguity • rlang</title><!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png"><link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png"><link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png"><link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png"><link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png"><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Source_Sans_Pro-0.4.10/font.css" rel="stylesheet"><link href="../deps/Source_Code_Pro-0.4.10/font.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="The data mask ambiguity — topic-data-mask-ambiguity"><meta name="description" content="Data masking is an R feature that blends programming variables that live inside environments (env-variables) with statistical variables stored in data frames (data-variables). This mixture makes it easy to refer to data frame columns as well as objects defined in the current environment.
x &amp;lt;- 100
mtcars %&amp;gt;% dplyr::summarise(mean(disp / x))
#&amp;gt; # A tibble: 1 x 1
#&amp;gt;   `mean(disp/x)`
#&amp;gt;            &amp;lt;dbl&amp;gt;
#&amp;gt; 1           2.31

However this convenience introduces an ambiguity between data-variables and env-variables which might cause collisions.
Column collisions


In the following snippet, are we referring to the env-variable x or to the data-variable of the same name?
df &amp;lt;- data.frame(x = NA, y = 2)
x &amp;lt;- 100

df %&amp;gt;% dplyr::mutate(y = y / x)
#&amp;gt;    x  y
#&amp;gt; 1 NA NA

A column collision occurs when you want to use an object defined outside of the data frame, but a column of the same name happens to exist.



Object collisions


The opposite problem occurs when there is a typo in a data-variable name and an env-variable of the same name exists:
df &amp;lt;- data.frame(foo = &quot;right&quot;)
ffo &amp;lt;- &quot;wrong&quot;

df %&amp;gt;% dplyr::mutate(foo = toupper(ffo))
#&amp;gt;     foo
#&amp;gt; 1 WRONG

Instead of a typo, it might also be that you were expecting a column in the data frame which is unexpectedly missing. In both cases, if a variable can't be found in the data mask, R looks for variables in the surrounding environment. This isn't what we intended here and it would have been better to fail early with a &quot;Column not found&quot; error.



Preventing collisions


In casual scripts or interactive programming, data mask ambiguity is not a huge deal compared to the payoff of iterating quickly while developing your analysis. However in production code and in package functions, the ambiguity might cause collision bugs in the long run.
Fortunately it is easy to be explicit about the scoping of variables with a little more verbose code. This topic lists the solutions and workarounds that have been created to solve ambiguity issues in data masks.
The .data and .env pronouns


The simplest solution is to use the .data and .env pronouns to disambiguate between data-variables and env-variables.
df &amp;lt;- data.frame(x = 1, y = 2)
x &amp;lt;- 100

df %&amp;gt;% dplyr::mutate(y = .data$y / .env$x)
#&amp;gt;   x    y
#&amp;gt; 1 1 0.02

This is especially useful in functions because the data frame is not known in advance and potentially contain masking columns for any of the env-variables in scope in the function:
my_rescale &amp;lt;- function(data, var, factor = 10) {
  data %&amp;gt;% dplyr::mutate(&quot;{{ var }}&quot; := {{ var }} / factor)
}

# This works
data.frame(value = 1) %&amp;gt;% my_rescale(value)
#&amp;gt;   value
#&amp;gt; 1   0.1

# Oh no!
data.frame(factor = 0, value = 1) %&amp;gt;% my_rescale(value)
#&amp;gt;   factor value
#&amp;gt; 1      0   Inf

Subsetting function arguments with .env ensures we never hit a masking column:
my_rescale &amp;lt;- function(data, var, factor = 10) {
  data %&amp;gt;% dplyr::mutate(&quot;{{ var }}&quot; := {{ var }} / .env$factor)
}

# Yay!
data.frame(factor = 0, value = 1) %&amp;gt;% my_rescale(value)
#&amp;gt;   factor value
#&amp;gt; 1      0   0.1




Subsetting .data with env-variables


The .data pronoun may be used as a name-to-data-mask pattern (see Data mask programming patterns):
var &amp;lt;- &quot;cyl&quot;
mtcars %&amp;gt;% dplyr::summarise(mean = mean(.data[[var]]))
#&amp;gt; # A tibble: 1 x 1
#&amp;gt;    mean
#&amp;gt;   &amp;lt;dbl&amp;gt;
#&amp;gt; 1  6.19

In this example, the env-variable var is used inside the data mask to subset the .data pronoun. Does this mean that var is at risk of a column collision if the input data frame contains a column of the same name? Fortunately not:
var &amp;lt;- &quot;cyl&quot;

mtcars2 &amp;lt;- mtcars
mtcars2$var &amp;lt;- &quot;wrong&quot;

mtcars2 %&amp;gt;% dplyr::summarise(mean = mean(.data[[var]]))
#&amp;gt; # A tibble: 1 x 1
#&amp;gt;    mean
#&amp;gt;   &amp;lt;dbl&amp;gt;
#&amp;gt; 1  6.19

The evaluation of .data[[var]] is set up in such a way that there is no ambiguity. The .data pronoun can only be subsetted with env-variables, not data-variables. Technically, this is because [[ behaves like an injection operator when applied to .data. It is evaluated very early before the data mask is even created. See the !! section below.



Injecting env-variables with !!


Injection operators such as !! have interesting properties regarding the ambiguity problem. They modify a piece of code early on by injecting objects or other expressions before any data-masking logic comes into play. If you inject the value of a variable, it becomes inlined in the expression. R no longer needs to look up any variable to find the value.
Taking the earlier division example, let's use !! to inject the value of the env-variable x inside the division expression:
df &amp;lt;- data.frame(x = NA, y = 2)
x &amp;lt;- 100

df %&amp;gt;% dplyr::mutate(y = y / !!x)
#&amp;gt;    x    y
#&amp;gt; 1 NA 0.02

While injection solves issues of ambiguity, it is a bit heavy handed compared to using the .env pronoun. Big objects inlined in expressions might cause issues in unexpected places, for instance they might make the calls in a traceback() less readable.






No ambiguity in tidy selections


Tidy selection is a dialect of R that optimises column selection in tidyverse packages. Examples of functions that use tidy selections are dplyr::select() and tidyr::pivot_longer().
Unlike data masking, tidy selections do not suffer from ambiguity. The selection language is designed in such a way that evaluation of expressions is either scoped in the data mask only, or in the environment only. Take this example:
mtcars %&amp;gt;% dplyr::select(gear:ncol(mtcars))

gear is a symbol supplied to a selection operator : and thus scoped in the data mask only. Any other kind of expression, such as ncol(mtcars), is evaluated as normal R code outside of any data context. This is why there is no column collision here:
data &amp;lt;- data.frame(x = 1, data = 1:3)

data %&amp;gt;% dplyr::select(data:ncol(data))
#&amp;gt;   data
#&amp;gt; 1    1
#&amp;gt; 2    2
#&amp;gt; 3    3

It is useful to introduce two new terms. Tidy selections distinguish data-expressions and env-expressions:
data is a data-expression that refers to the data-variable.
ncol(data) is an env-expression that refers to the env-variable.


To learn more about the difference between the two kinds of expressions, see the technical description of the tidy selection syntax.
Names pattern with all_of()


all_of() is often used in functions as a programming pattern that connects column names to a data mask, similarly to the .data pronoun. A simple example is:
my_group_by &amp;lt;- function(data, vars) {
  data %&amp;gt;% dplyr::group_by(across(all_of(vars)))
}

If tidy selections were affected by the data mask ambiguity, this function would be at risk of a column collision. It would break as soon as the user supplies a data frame containing a vars column. However, all_of() is an env-expression that is evaluated outside of the data mask, so there is no possibility of collisions.




"><meta property="og:description" content="Data masking is an R feature that blends programming variables that live inside environments (env-variables) with statistical variables stored in data frames (data-variables). This mixture makes it easy to refer to data frame columns as well as objects defined in the current environment.
x &amp;lt;- 100
mtcars %&amp;gt;% dplyr::summarise(mean(disp / x))
#&amp;gt; # A tibble: 1 x 1
#&amp;gt;   `mean(disp/x)`
#&amp;gt;            &amp;lt;dbl&amp;gt;
#&amp;gt; 1           2.31

However this convenience introduces an ambiguity between data-variables and env-variables which might cause collisions.
Column collisions


In the following snippet, are we referring to the env-variable x or to the data-variable of the same name?
df &amp;lt;- data.frame(x = NA, y = 2)
x &amp;lt;- 100

df %&amp;gt;% dplyr::mutate(y = y / x)
#&amp;gt;    x  y
#&amp;gt; 1 NA NA

A column collision occurs when you want to use an object defined outside of the data frame, but a column of the same name happens to exist.



Object collisions


The opposite problem occurs when there is a typo in a data-variable name and an env-variable of the same name exists:
df &amp;lt;- data.frame(foo = &quot;right&quot;)
ffo &amp;lt;- &quot;wrong&quot;

df %&amp;gt;% dplyr::mutate(foo = toupper(ffo))
#&amp;gt;     foo
#&amp;gt; 1 WRONG

Instead of a typo, it might also be that you were expecting a column in the data frame which is unexpectedly missing. In both cases, if a variable can't be found in the data mask, R looks for variables in the surrounding environment. This isn't what we intended here and it would have been better to fail early with a &quot;Column not found&quot; error.



Preventing collisions


In casual scripts or interactive programming, data mask ambiguity is not a huge deal compared to the payoff of iterating quickly while developing your analysis. However in production code and in package functions, the ambiguity might cause collision bugs in the long run.
Fortunately it is easy to be explicit about the scoping of variables with a little more verbose code. This topic lists the solutions and workarounds that have been created to solve ambiguity issues in data masks.
The .data and .env pronouns


The simplest solution is to use the .data and .env pronouns to disambiguate between data-variables and env-variables.
df &amp;lt;- data.frame(x = 1, y = 2)
x &amp;lt;- 100

df %&amp;gt;% dplyr::mutate(y = .data$y / .env$x)
#&amp;gt;   x    y
#&amp;gt; 1 1 0.02

This is especially useful in functions because the data frame is not known in advance and potentially contain masking columns for any of the env-variables in scope in the function:
my_rescale &amp;lt;- function(data, var, factor = 10) {
  data %&amp;gt;% dplyr::mutate(&quot;{{ var }}&quot; := {{ var }} / factor)
}

# This works
data.frame(value = 1) %&amp;gt;% my_rescale(value)
#&amp;gt;   value
#&amp;gt; 1   0.1

# Oh no!
data.frame(factor = 0, value = 1) %&amp;gt;% my_rescale(value)
#&amp;gt;   factor value
#&amp;gt; 1      0   Inf

Subsetting function arguments with .env ensures we never hit a masking column:
my_rescale &amp;lt;- function(data, var, factor = 10) {
  data %&amp;gt;% dplyr::mutate(&quot;{{ var }}&quot; := {{ var }} / .env$factor)
}

# Yay!
data.frame(factor = 0, value = 1) %&amp;gt;% my_rescale(value)
#&amp;gt;   factor value
#&amp;gt; 1      0   0.1




Subsetting .data with env-variables


The .data pronoun may be used as a name-to-data-mask pattern (see Data mask programming patterns):
var &amp;lt;- &quot;cyl&quot;
mtcars %&amp;gt;% dplyr::summarise(mean = mean(.data[[var]]))
#&amp;gt; # A tibble: 1 x 1
#&amp;gt;    mean
#&amp;gt;   &amp;lt;dbl&amp;gt;
#&amp;gt; 1  6.19

In this example, the env-variable var is used inside the data mask to subset the .data pronoun. Does this mean that var is at risk of a column collision if the input data frame contains a column of the same name? Fortunately not:
var &amp;lt;- &quot;cyl&quot;

mtcars2 &amp;lt;- mtcars
mtcars2$var &amp;lt;- &quot;wrong&quot;

mtcars2 %&amp;gt;% dplyr::summarise(mean = mean(.data[[var]]))
#&amp;gt; # A tibble: 1 x 1
#&amp;gt;    mean
#&amp;gt;   &amp;lt;dbl&amp;gt;
#&amp;gt; 1  6.19

The evaluation of .data[[var]] is set up in such a way that there is no ambiguity. The .data pronoun can only be subsetted with env-variables, not data-variables. Technically, this is because [[ behaves like an injection operator when applied to .data. It is evaluated very early before the data mask is even created. See the !! section below.



Injecting env-variables with !!


Injection operators such as !! have interesting properties regarding the ambiguity problem. They modify a piece of code early on by injecting objects or other expressions before any data-masking logic comes into play. If you inject the value of a variable, it becomes inlined in the expression. R no longer needs to look up any variable to find the value.
Taking the earlier division example, let's use !! to inject the value of the env-variable x inside the division expression:
df &amp;lt;- data.frame(x = NA, y = 2)
x &amp;lt;- 100

df %&amp;gt;% dplyr::mutate(y = y / !!x)
#&amp;gt;    x    y
#&amp;gt; 1 NA 0.02

While injection solves issues of ambiguity, it is a bit heavy handed compared to using the .env pronoun. Big objects inlined in expressions might cause issues in unexpected places, for instance they might make the calls in a traceback() less readable.






No ambiguity in tidy selections


Tidy selection is a dialect of R that optimises column selection in tidyverse packages. Examples of functions that use tidy selections are dplyr::select() and tidyr::pivot_longer().
Unlike data masking, tidy selections do not suffer from ambiguity. The selection language is designed in such a way that evaluation of expressions is either scoped in the data mask only, or in the environment only. Take this example:
mtcars %&amp;gt;% dplyr::select(gear:ncol(mtcars))

gear is a symbol supplied to a selection operator : and thus scoped in the data mask only. Any other kind of expression, such as ncol(mtcars), is evaluated as normal R code outside of any data context. This is why there is no column collision here:
data &amp;lt;- data.frame(x = 1, data = 1:3)

data %&amp;gt;% dplyr::select(data:ncol(data))
#&amp;gt;   data
#&amp;gt; 1    1
#&amp;gt; 2    2
#&amp;gt; 3    3

It is useful to introduce two new terms. Tidy selections distinguish data-expressions and env-expressions:
data is a data-expression that refers to the data-variable.
ncol(data) is an env-expression that refers to the env-variable.


To learn more about the difference between the two kinds of expressions, see the technical description of the tidy selection syntax.
Names pattern with all_of()


all_of() is often used in functions as a programming pattern that connects column names to a data mask, similarly to the .data pronoun. A simple example is:
my_group_by &amp;lt;- function(data, vars) {
  data %&amp;gt;% dplyr::group_by(across(all_of(vars)))
}

If tidy selections were affected by the data mask ambiguity, this function would be at risk of a column collision. It would break as soon as the user supplies a data frame containing a vars column. However, all_of() is an env-expression that is evaluated outside of the data mask, so there is no possibility of collisions.




"><meta property="og:image" content="https://rlang.r-lib.org/logo.png"><meta name="robots" content="noindex"><script defer data-domain="rlang.r-lib.org,all.tidyverse.org" src="https://plausible.io/js/plausible.js"></script></head><body>
    <a href="#container" class="visually-hidden-focusable">Skip to content</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-none" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">rlang</a>

    <small class="nav-text text-danger me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="In-development version">1.1.6.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-tidy-evaluation" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Tidy evaluation</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-tidy-evaluation"><li><h6 class="dropdown-header" data-toc-skip>Overviews</h6></li>
    <li><a class="dropdown-item" href="../reference/topic-data-mask.html">What is data-masking and why do I need `{{`?</a></li>
    <li><a class="dropdown-item" href="../reference/topic-data-mask-programming.html">Data mask programming patterns</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Guides</h6></li>
    <li><a class="dropdown-item" href="../reference/topic-data-mask-ambiguity.html">The data mask ambiguity</a></li>
    <li><a class="dropdown-item" href="../reference/topic-double-evaluation.html">The double evaluation problem</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Notes</h6></li>
    <li><a class="dropdown-item" href="../reference/topic-inject-out-of-context.html">What happens if I use injection operators out of context?</a></li>
    <li><a class="dropdown-item" href="../reference/topic-embrace-non-args.html">Does `{{` work on regular objects?</a></li>
  </ul></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-metaprogramming" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Metaprogramming</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-metaprogramming"><li><h6 class="dropdown-header" data-toc-skip>Overviews</h6></li>
    <li><a class="dropdown-item" href="../reference/topic-defuse.html">Defusing R expressions</a></li>
    <li><a class="dropdown-item" href="../reference/topic-inject.html">Injecting with `!!`, `!!!`, and glue syntax</a></li>
    <li><a class="dropdown-item" href="../reference/topic-metaprogramming.html">Metaprogramming patterns</a></li>
    <li><a class="dropdown-item" href="../reference/topic-quosure.html">What are quosures and when are they needed?</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Guides</h6></li>
    <li><a class="dropdown-item" href="../reference/topic-multiple-columns.html">Taking multiple columns without `...`</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Notes</h6></li>
    <li><a class="dropdown-item" href="../reference/topic-embrace-constants.html">Why are strings and other constants enquosed in the empty environment?</a></li>
  </ul></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-conditions" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Conditions</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-conditions"><li><h6 class="dropdown-header" data-toc-skip>Guides</h6></li>
    <li><a class="dropdown-item" href="../reference/topic-error-call.html">Including function calls in error messages</a></li>
    <li><a class="dropdown-item" href="../reference/topic-error-chaining.html">Including contextual information with error chains</a></li>
    <li><a class="dropdown-item" href="../reference/topic-condition-formatting.html">Formatting messages with cli</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><h6 class="dropdown-header" data-toc-skip>Notes</h6></li>
    <li><a class="dropdown-item" href="../reference/topic-condition-customisation.html">Customising condition messages</a></li>
  </ul></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-news" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">News</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-news"><li><h6 class="dropdown-header" data-toc-skip>Releases</h6></li>
    <li><a class="external-link dropdown-item" href="https://www.tidyverse.org/blog/2020/02/glue-strings-and-tidy-eval/">Version 0.4.3</a></li>
    <li><a class="external-link dropdown-item" href="https://www.tidyverse.org/articles/2019/06/rlang-0-4-0/">Version 0.4.0</a></li>
    <li><a class="external-link dropdown-item" href="https://www.tidyverse.org/articles/2019/01/rlang-0-3-1/">Version 0.3.1</a></li>
    <li><a class="external-link dropdown-item" href="https://www.tidyverse.org/articles/2018/10/rlang-0-3-0/">Version 0.3.0</a></li>
    <li><a class="external-link dropdown-item" href="https://www.tidyverse.org/articles/2018/03/rlang-0.2.0/">Version 0.2.0</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" href="../news/index.html">Changelog</a></li>
  </ul></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/r-lib/rlang/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic" id="container">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>The data mask ambiguity</h1>
      <small class="dont-index">Source: <a href="https://github.com/r-lib/rlang/blob/main/R/topic-nse.R" class="external-link"><code>R/topic-nse.R</code></a></small>
      <div class="d-none name"><code>topic-data-mask-ambiguity.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p><a href="topic-data-mask.html">Data masking</a> is an R feature that blends programming variables that live inside environments (env-variables) with statistical variables stored in data frames (data-variables). This mixture makes it easy to refer to data frame columns as well as objects defined in the current environment.</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fl">100</span></span>
<span><span class="va">mtcars</span> <span class="op">%&gt;%</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html" class="external-link">summarise</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">disp</span> <span class="op">/</span> <span class="va">x</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 1 x 1</span></span>
<span><span class="co">#&gt;   `mean(disp/x)`</span></span>
<span><span class="co">#&gt;            &lt;dbl&gt;</span></span>
<span><span class="co">#&gt; 1           2.31</span></span></code></pre><p></p></div>
<p>However this convenience introduces an ambiguity between data-variables and env-variables which might cause <strong>collisions</strong>.</p><div class="section">
<h3 id="column-collisions">Column collisions<a class="anchor" aria-label="anchor" href="#column-collisions"></a></h3>


<p>In the following snippet, are we referring to the env-variable <code>x</code> or to the data-variable of the same name?</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="cn">NA</span>, y <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fl">100</span></span>
<span></span>
<span><span class="va">df</span> <span class="op">%&gt;%</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html" class="external-link">mutate</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">y</span> <span class="op">/</span> <span class="va">x</span><span class="op">)</span></span>
<span><span class="co">#&gt;    x  y</span></span>
<span><span class="co">#&gt; 1 NA NA</span></span></code></pre><p></p></div>
<p>A column collision occurs when you want to use an object defined outside of the data frame, but a column of the same name happens to exist.</p>
</div>

<div class="section">
<h3 id="object-collisions">Object collisions<a class="anchor" aria-label="anchor" href="#object-collisions"></a></h3>


<p>The opposite problem occurs when there is a typo in a data-variable name and an env-variable of the same name exists:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>foo <span class="op">=</span> <span class="st">"right"</span><span class="op">)</span></span>
<span><span class="va">ffo</span> <span class="op">&lt;-</span> <span class="st">"wrong"</span></span>
<span></span>
<span><span class="va">df</span> <span class="op">%&gt;%</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html" class="external-link">mutate</a></span><span class="op">(</span>foo <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/chartr.html" class="external-link">toupper</a></span><span class="op">(</span><span class="va">ffo</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;     foo</span></span>
<span><span class="co">#&gt; 1 WRONG</span></span></code></pre><p></p></div>
<p>Instead of a typo, it might also be that you were expecting a column in the data frame which is unexpectedly missing. In both cases, if a variable can't be found in the data mask, R looks for variables in the surrounding environment. This isn't what we intended here and it would have been better to fail early with a "Column not found" error.</p>
</div>

<div class="section">
<h3 id="preventing-collisions">Preventing collisions<a class="anchor" aria-label="anchor" href="#preventing-collisions"></a></h3>


<p>In casual scripts or interactive programming, data mask ambiguity is not a huge deal compared to the payoff of iterating quickly while developing your analysis. However in production code and in package functions, the ambiguity might cause collision bugs in the long run.</p>
<p>Fortunately it is easy to be explicit about the scoping of variables with a little more verbose code. This topic lists the solutions and workarounds that have been created to solve ambiguity issues in data masks.</p><div class="section">
<h4 id="the-data-and-env-pronouns">The <code>.data</code> and <code>.env</code> pronouns<a class="anchor" aria-label="anchor" href="#the-data-and-env-pronouns"></a></h4>


<p>The simplest solution is to use the <code><a href="dot-data.html">.data</a></code> and <code><a href="dot-data.html">.env</a></code> pronouns to disambiguate between data-variables and env-variables.</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span>, y <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fl">100</span></span>
<span></span>
<span><span class="va">df</span> <span class="op">%&gt;%</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html" class="external-link">mutate</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">.data</span><span class="op">$</span><span class="va">y</span> <span class="op">/</span> <span class="va">.env</span><span class="op">$</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="co">#&gt;   x    y</span></span>
<span><span class="co">#&gt; 1 1 0.02</span></span></code></pre><p></p></div>
<p>This is especially useful in functions because the data frame is not known in advance and potentially contain masking columns for any of the env-variables in scope in the function:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">my_rescale</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">var</span>, <span class="va">factor</span> <span class="op">=</span> <span class="fl">10</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">data</span> <span class="op">%&gt;%</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html" class="external-link">mutate</a></span><span class="op">(</span><span class="st">"{{ var }}"</span> <span class="op">:=</span> <span class="op">{</span><span class="op">{</span> <span class="va">var</span> <span class="op">}</span><span class="op">}</span> <span class="op">/</span> <span class="va">factor</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># This works</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>value <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">%&gt;%</span> <span class="fu">my_rescale</span><span class="op">(</span><span class="va">value</span><span class="op">)</span></span>
<span><span class="co">#&gt;   value</span></span>
<span><span class="co">#&gt; 1   0.1</span></span>
<span></span>
<span><span class="co"># Oh no!</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>factor <span class="op">=</span> <span class="fl">0</span>, value <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">%&gt;%</span> <span class="fu">my_rescale</span><span class="op">(</span><span class="va">value</span><span class="op">)</span></span>
<span><span class="co">#&gt;   factor value</span></span>
<span><span class="co">#&gt; 1      0   Inf</span></span></code></pre><p></p></div>
<p>Subsetting function arguments with <code>.env</code> ensures we never hit a masking column:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">my_rescale</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">var</span>, <span class="va">factor</span> <span class="op">=</span> <span class="fl">10</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">data</span> <span class="op">%&gt;%</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html" class="external-link">mutate</a></span><span class="op">(</span><span class="st">"{{ var }}"</span> <span class="op">:=</span> <span class="op">{</span><span class="op">{</span> <span class="va">var</span> <span class="op">}</span><span class="op">}</span> <span class="op">/</span> <span class="va">.env</span><span class="op">$</span><span class="va">factor</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># Yay!</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>factor <span class="op">=</span> <span class="fl">0</span>, value <span class="op">=</span> <span class="fl">1</span><span class="op">)</span> <span class="op">%&gt;%</span> <span class="fu">my_rescale</span><span class="op">(</span><span class="va">value</span><span class="op">)</span></span>
<span><span class="co">#&gt;   factor value</span></span>
<span><span class="co">#&gt; 1      0   0.1</span></span></code></pre><p></p></div>
</div>

<div class="section">
<h4 id="subsetting-data-with-env-variables">Subsetting <code>.data</code> with env-variables<a class="anchor" aria-label="anchor" href="#subsetting-data-with-env-variables"></a></h4>


<p>The <code><a href="dot-data.html">.data</a></code> pronoun may be used as a name-to-data-mask pattern (see <a href="topic-data-mask-programming.html">Data mask programming patterns</a>):</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">var</span> <span class="op">&lt;-</span> <span class="st">"cyl"</span></span>
<span><span class="va">mtcars</span> <span class="op">%&gt;%</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html" class="external-link">summarise</a></span><span class="op">(</span>mean <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">.data</span><span class="op">[[</span><span class="va">var</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 1 x 1</span></span>
<span><span class="co">#&gt;    mean</span></span>
<span><span class="co">#&gt;   &lt;dbl&gt;</span></span>
<span><span class="co">#&gt; 1  6.19</span></span></code></pre><p></p></div>
<p>In this example, the env-variable <code>var</code> is used inside the data mask to subset the <code>.data</code> pronoun. Does this mean that <code>var</code> is at risk of a column collision if the input data frame contains a column of the same name? Fortunately not:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">var</span> <span class="op">&lt;-</span> <span class="st">"cyl"</span></span>
<span></span>
<span><span class="va">mtcars2</span> <span class="op">&lt;-</span> <span class="va">mtcars</span></span>
<span><span class="va">mtcars2</span><span class="op">$</span><span class="va">var</span> <span class="op">&lt;-</span> <span class="st">"wrong"</span></span>
<span></span>
<span><span class="va">mtcars2</span> <span class="op">%&gt;%</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/summarise.html" class="external-link">summarise</a></span><span class="op">(</span>mean <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">.data</span><span class="op">[[</span><span class="va">var</span><span class="op">]</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt; # A tibble: 1 x 1</span></span>
<span><span class="co">#&gt;    mean</span></span>
<span><span class="co">#&gt;   &lt;dbl&gt;</span></span>
<span><span class="co">#&gt; 1  6.19</span></span></code></pre><p></p></div>
<p>The evaluation of <code>.data[[var]]</code> is set up in such a way that there is no ambiguity. The <code>.data</code> pronoun can only be subsetted with env-variables, not data-variables. Technically, this is because <code>[[</code> behaves like an <em>injection operator</em> when applied to <code>.data</code>. It is evaluated very early before the data mask is even created. See the <code>!!</code> section below.</p>
</div>

<div class="section">
<h4 id="injecting-env-variables-with-">Injecting env-variables with <code>!!</code><a class="anchor" aria-label="anchor" href="#injecting-env-variables-with-"></a></h4>


<p><a href="topic-inject.html">Injection operators</a> such as <code><a href="injection-operator.html">!!</a></code> have interesting properties regarding the ambiguity problem. They modify a piece of code early on by injecting objects or other expressions before any data-masking logic comes into play. If you inject the <em>value</em> of a variable, it becomes inlined in the expression. R no longer needs to look up any variable to find the value.</p>
<p>Taking the earlier division example, let's use <code>!!</code> to inject the value of the env-variable <code>x</code> inside the division expression:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">df</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="cn">NA</span>, y <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">x</span> <span class="op">&lt;-</span> <span class="fl">100</span></span>
<span></span>
<span><span class="va">df</span> <span class="op">%&gt;%</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/mutate.html" class="external-link">mutate</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">y</span> <span class="op">/</span> <span class="op">!</span><span class="op">!</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="co">#&gt;    x    y</span></span>
<span><span class="co">#&gt; 1 NA 0.02</span></span></code></pre><p></p></div>
<p>While injection solves issues of ambiguity, it is a bit heavy handed compared to using the <code><a href="dot-data.html">.env</a></code> pronoun. Big objects inlined in expressions might cause issues in unexpected places, for instance they might make the calls in a <code><a href="https://rdrr.io/r/base/traceback.html" class="external-link">traceback()</a></code> less readable.</p>
</div>


</div>

<div class="section">
<h3 id="no-ambiguity-in-tidy-selections">No ambiguity in tidy selections<a class="anchor" aria-label="anchor" href="#no-ambiguity-in-tidy-selections"></a></h3>


<p><a href="https://tidyselect.r-lib.org/reference/language.html" class="external-link">Tidy selection</a> is a dialect of R that optimises column selection in tidyverse packages. Examples of functions that use tidy selections are <code><a href="https://dplyr.tidyverse.org/reference/select.html" class="external-link">dplyr::select()</a></code> and <code>tidyr::pivot_longer()</code>.</p>
<p>Unlike data masking, tidy selections do not suffer from ambiguity. The selection language is designed in such a way that evaluation of expressions is either scoped in the data mask only, or in the environment only. Take this example:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">mtcars</span> <span class="op">%&gt;%</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/select.html" class="external-link">select</a></span><span class="op">(</span><span class="va">gear</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">mtcars</span><span class="op">)</span><span class="op">)</span></span></code></pre><p></p></div>
<p><code>gear</code> is a symbol supplied to a selection operator <code>:</code> and thus scoped in the data mask only. Any other kind of expression, such as <code>ncol(mtcars)</code>, is evaluated as normal R code outside of any data context. This is why there is no column collision here:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">1</span>, data <span class="op">=</span> <span class="fl">1</span><span class="op">:</span><span class="fl">3</span><span class="op">)</span></span>
<span></span>
<span><span class="va">data</span> <span class="op">%&gt;%</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/select.html" class="external-link">select</a></span><span class="op">(</span><span class="va">data</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;   data</span></span>
<span><span class="co">#&gt; 1    1</span></span>
<span><span class="co">#&gt; 2    2</span></span>
<span><span class="co">#&gt; 3    3</span></span></code></pre><p></p></div>
<p>It is useful to introduce two new terms. Tidy selections distinguish data-expressions and env-expressions:</p><ul><li><p><code>data</code> is a data-expression that refers to the data-variable.</p></li>
<li><p><code>ncol(data)</code> is an env-expression that refers to the env-variable.</p></li>
</ul><p>To learn more about the difference between the two kinds of expressions, see the <a href="https://tidyselect.r-lib.org/articles/syntax.html" class="external-link">technical description of the tidy selection syntax</a>.</p><div class="section">
<h4 id="names-pattern-with-all-of-">Names pattern with <code>all_of()</code><a class="anchor" aria-label="anchor" href="#names-pattern-with-all-of-"></a></h4>


<p><code>all_of()</code> is often used in functions as a <a href="topic-data-mask-programming.html">programming pattern</a> that connects column names to a data mask, similarly to the <code><a href="dot-data.html">.data</a></code> pronoun. A simple example is:</p>
<p></p><div class="sourceCode r"><pre><code><span><span class="va">my_group_by</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">data</span>, <span class="va">vars</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">data</span> <span class="op">%&gt;%</span> <span class="fu">dplyr</span><span class="fu">::</span><span class="fu"><a href="https://dplyr.tidyverse.org/reference/group_by.html" class="external-link">group_by</a></span><span class="op">(</span><span class="fu">across</span><span class="op">(</span><span class="fu">all_of</span><span class="op">(</span><span class="va">vars</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre><p></p></div>
<p>If tidy selections were affected by the data mask ambiguity, this function would be at risk of a column collision. It would break as soon as the user supplies a data frame containing a <code>vars</code> column. However, <code>all_of()</code> is an env-expression that is evaluated outside of the data mask, so there is no possibility of collisions.</p>
</div>


</div>

    </div>



  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


   </div>
  <footer><div class="container">
  <div class="pkgdown-footer-left">
  <p>Developed by <a href="https://github.com/lionel-" class="external-link">Lionel Henry</a>, <a href="https://hadley.nz" class="external-link">Hadley Wickham</a>, <a href="https://www.posit.co" class="external-link"><img src="https://www.tidyverse.org/posit-logo.svg" alt="Posit" height="16" width="62" style="margin-bottom: 3px;"></a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

  </div></footer></body></html>

