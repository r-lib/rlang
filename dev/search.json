[{"path":[]},{"path":"https://rlang.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"https://rlang.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"https://rlang.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"https://rlang.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"https://rlang.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement codeofconduct@rstudio.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"https://rlang.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"https://rlang.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"https://rlang.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"https://rlang.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"https://rlang.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"https://rlang.r-lib.org/dev/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"https://rlang.r-lib.org/dev/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2020 rlang authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://rlang.r-lib.org/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Lionel Henry. Author, maintainer. Hadley Wickham. Author. mikefc. Copyright holder.           Hash implementation based Mike's xxhashlite Yann Collet. Copyright holder.           Author embedded xxHash library . Copyright holder, funder.","code":""},{"path":"https://rlang.r-lib.org/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Henry L, Wickham H (2025). rlang: Functions Base Types Core R 'Tidyverse' Features. R package version 1.1.6.9000, https://rlang.r-lib.org.","code":"@Manual{,   title = {rlang: Functions for Base Types and Core R and 'Tidyverse' Features},   author = {Lionel Henry and Hadley Wickham},   year = {2025},   note = {R package version 1.1.6.9000},   url = {https://rlang.r-lib.org}, }"},{"path":"https://rlang.r-lib.org/dev/index.html","id":"rlang-","dir":"","previous_headings":"","what":"Functions for Base Types and Core R and Tidyverse Features","title":"Functions for Base Types and Core R and Tidyverse Features","text":"rlang collection frameworks APIs programming R.","code":""},{"path":"https://rlang.r-lib.org/dev/index.html","id":"frameworks","dir":"","previous_headings":"","what":"Frameworks","title":"Functions for Base Types and Core R and Tidyverse Features","text":"Two comprehensive frameworks implemented rlang. tidy eval, programmable data-masking framework used tidyverse packages like dplyr ggplot2. user, encounter embracing operator {{ name injection glue operators \"{\" \"{{\". rlang errors, set tools signal display errors. includes backtrace capture global_entrace() backtrace display last_error() last_warnings(). Use abort() create errors bullet lists, structured metadata, error chaining support. display error messages optimised bullet lists chained errors optionally integrates cli package (see local_use_cli()).","code":""},{"path":"https://rlang.r-lib.org/dev/index.html","id":"argument-intake","dir":"","previous_headings":"","what":"Argument intake","title":"Functions for Base Types and Core R and Tidyverse Features","text":"set tools help check, validate, preprocess arguments. Checking function arguments, e.g. arg_match(), check_required(), check_exclusive(). Checking dots, e.g. check_dots_used() check_dots_empty(). Collecting dynamic dots, e.g. list2(). dots support splicing !!! name injection glue operators \"{\" \"{{\".","code":""},{"path":"https://rlang.r-lib.org/dev/index.html","id":"programming-interfaces","dir":"","previous_headings":"","what":"Programming interfaces","title":"Functions for Base Types and Core R and Tidyverse Features","text":"rlang provides various interfaces working R R objects. R session, e.g. check_installed(), on_load(), on_package_load(). Environments, e.g. env(), env_has(), env_get(), env_bind(), env_unbind(), env_print(), local_bindings(). Evaluation, e.g. inject() eval_bare(). Calls symbols, e.g. call2(), is_call(), is_call_simple(), data_sym(), data_syms(). Functions, e.g. new_function() as_function(). latter supports purrr-style formula notation lambda functions.","code":""},{"path":"https://rlang.r-lib.org/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Functions for Base Types and Core R and Tidyverse Features","text":"Install released version rlang CRAN: install development version GitHub :","code":"install.packages(\"rlang\") # install.packages(\"pak\") pak::pkg_install(\"r-lib/rlang\")"},{"path":"https://rlang.r-lib.org/dev/index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Functions for Base Types and Core R and Tidyverse Features","text":"Please note rlang project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/UQ.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated UQ() and UQS() operators — UQ","title":"Deprecated UQ() and UQS() operators — UQ","text":"operators deprecated favour !! !!!.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/UQ.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated UQ() and UQS() operators — UQ","text":"","code":"UQ(x)  UQS(x)"},{"path":"https://rlang.r-lib.org/dev/reference/abort.html","id":null,"dir":"Reference","previous_headings":"","what":"Signal an error, warning, or message — abort","title":"Signal an error, warning, or message — abort","text":"functions equivalent base functions base::stop(), base::warning(), base::message(). signal condition (error, warning, message respectively) make easy supply condition metadata: Supply class create classed condition can caught handled selectively, allowing finer-grained error handling. Supply metadata named ... arguments. data stored condition object can examined handlers. Supply call inform users function error occurred . Supply another condition parent create chained condition. Certain components condition messages formatted unicode symbols terminal colours default. aspects can customised, see Customising condition messages.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/abort.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Signal an error, warning, or message — abort","text":"","code":"abort(   message = NULL,   class = NULL,   ...,   call,   body = NULL,   footer = NULL,   trace = NULL,   parent = NULL,   use_cli_format = NULL,   .inherit = TRUE,   .internal = FALSE,   .file = NULL,   .frame = caller_env(),   .trace_bottom = NULL,   .subclass = deprecated() )  warn(   message = NULL,   class = NULL,   ...,   body = NULL,   footer = NULL,   parent = NULL,   use_cli_format = NULL,   .inherit = NULL,   .frequency = c(\"always\", \"regularly\", \"once\"),   .frequency_id = NULL,   .subclass = deprecated() )  inform(   message = NULL,   class = NULL,   ...,   body = NULL,   footer = NULL,   parent = NULL,   use_cli_format = NULL,   .inherit = NULL,   .file = NULL,   .frequency = c(\"always\", \"regularly\", \"once\"),   .frequency_id = NULL,   .subclass = deprecated() )  signal(message = \"\", class, ..., .subclass = deprecated())  reset_warning_verbosity(id)  reset_message_verbosity(id)"},{"path":"https://rlang.r-lib.org/dev/reference/abort.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Signal an error, warning, or message — abort","text":"message message display, formatted bulleted list. first element displayed alert bullet prefixed ! default. Elements named \"*\", \"\", \"v\", \"x\", \"!\" formatted regular, info, success, failure, error bullets respectively. See Formatting messages cli bulleted messaging. message supplied, expected message generated lazily cnd_header() cnd_body() methods. case, class must supplied. inform() allows empty messages occasionally useful build user output incrementally. function, stored header field error condition. acts cnd_header() method invoked lazily error message displayed. class Subclass condition. ... Additional data stored condition object. supply condition fields, usually provide class argument. may consider prefixing condition fields name package organisation prevent name collisions. call execution environment currently running function, e.g. call = caller_env(). corresponding function call retrieved mentioned error messages source error. need supply call throwing condition helper function relevant mention message. Can also NULL defused function call respectively display call hard-code code display. information error calls, see Including function calls error messages. body, footer Additional bullets. trace trace object created trace_back(). parent Supply parent rethrow error condition handler (e.g. try_fetch()). parent condition object, chained error created, useful want enhance error details, still retaining original information. parent NA, indicates unchained rethrow, useful want take ownership error rethrow custom message better fits surrounding context. Technically, supplying NA lets abort() know called condition handler. helps create simpler backtraces condition handling context hidden default. information error calls, see Including contextual information error chains. use_cli_format Whether format message lazily using cli available. results prettier accurate formatting messages. See local_use_cli() set condition field default package namespace. set TRUE, message character vector individual unformatted lines. newline character \"\\\\n\" already present message reformatted cli's paragraph formatter. See Formatting messages cli. .inherit Whether condition inherits parent according cnd_inherits() try_fetch(). default, parent conditions higher severity inherited. instance error chained warning inherited avoid unexpectedly catching error downgraded warning. .internal TRUE, footer bullet added message let user know error internal report package authors. argument incompatible footer. .file connection string specifying print message. default depends context, see stdout vs stderr section. .frame throwing context. Used default .trace_bottom, determine internal package mention internal errors .internal TRUE. .trace_bottom Used display simplified backtraces last relevant call frame show. way, irrelevant parts backtraces corresponding condition handling (tryCatch(), try_fetch(), abort(), etc.) hidden default. Defaults call environment, .frame otherwise. Without effect trace supplied. .subclass argument renamed class rlang 0.4.2 consistency conventions class constructors documented https://adv-r.hadley.nz/s3.html#s3-subclassing. .frequency frequently warning message displayed? default (\"always\") displayed time. \"regularly\", displayed every 8 hours. \"\", displayed per session. .frequency_id unique identifier warning message. used .frequency supplied recognise recurring conditions. argument must supplied .frequency set \"always\". id identifying string condition supplied .frequency_id warn() inform().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/abort.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Signal an error, warning, or message — abort","text":"abort() throws subclassed errors, see \"rlang_error\". warn() temporarily set warning.length global option maximum value (8170), unless option changed default value. default limit (1000 characters) especially easy hit message contains lot ANSI escapes, created crayon cli packages","code":""},{"path":"https://rlang.r-lib.org/dev/reference/abort.html","id":"error-prefix","dir":"Reference","previous_headings":"","what":"Error prefix","title":"Signal an error, warning, or message — abort","text":"base::stop(), errors thrown abort() prefixed \"Error: \". Calls source references included prefix, e.g. \"Error my_function() myfile.R:1:2:\". cosmetic differences: call stripped arguments keep simple. formatted using cli package available. line break prefix message former long. source location included, line break always inserted. throwing code highly structured, may explicitly inform abort() relevant user-facing call include prefix. Internal helpers rarely relevant end users. See call argument abort().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/abort.html","id":"backtrace","dir":"Reference","previous_headings":"","what":"Backtrace","title":"Signal an error, warning, or message — abort","text":"abort() saves backtrace trace component error condition. can print simplified backtrace last error calling last_error() full backtrace summary(last_error()). Learn control displayed error thrown rlang_backtrace_on_error.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/abort.html","id":"muffling-and-silencing-conditions","dir":"Reference","previous_headings":"","what":"Muffling and silencing conditions","title":"Signal an error, warning, or message — abort","text":"Signalling condition inform() warn() displays message console. messages can muffled usual base::suppressMessages() base::suppressWarnings(). inform() warn() messages can also silenced global options rlib_message_verbosity rlib_warning_verbosity. options take values: \"default\": Verbose unless .frequency argument supplied. \"verbose\": Always verbose. \"quiet\": Always quiet. set quiet, message displayed condition signalled.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/abort.html","id":"stdout-and-stderr","dir":"Reference","previous_headings":"","what":"stdout and stderr","title":"Signal an error, warning, or message — abort","text":"default, abort() inform() print standard output interactive sessions. allows rlang control appearance messages IDEs like RStudio. two situations messages streamed stderr: non-interactive sessions, messages streamed standard error R scripts can easily filter normal output redirecting stderr. sink active (either output messages) messages always streamd stderr. exceptions ensure consistency behaviour interactive non-interactive sessions, sinks active.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/abort.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Signal an error, warning, or message — abort","text":"","code":"# These examples are guarded to avoid throwing errors if (FALSE) {  # Signal an error with a message just like stop(): abort(\"The error message.\")   # Unhandled errors are saved automatically by `abort()` and can be # retrieved with `last_error()`. The error prints with a simplified # backtrace: f <- function() try(g()) g <- function() evalq(h()) h <- function() abort(\"Tilt.\") last_error()  # Use `summary()` to print the full backtrace and the condition fields: summary(last_error())   # Give a class to the error: abort(\"The error message\", \"mypkg_bad_error\")  # This allows callers to handle the error selectively tryCatch(   mypkg_function(),   mypkg_bad_error = function(err) {     warn(conditionMessage(err)) # Demote the error to a warning     NA                          # Return an alternative value   } )  # You can also specify metadata that will be stored in the condition: abort(\"The error message.\", \"mypkg_bad_error\", data = 1:10)  # This data can then be consulted by user handlers: tryCatch(   mypkg_function(),   mypkg_bad_error = function(err) {     # Compute an alternative return value with the data:     recover_error(err$data)   } )   # If you call low-level APIs it may be a good idea to create a # chained error with the low-level error wrapped in a more # user-friendly error. Use `try_fetch()` to fetch errors of a given # class and rethrow them with the `parent` argument of `abort()`: file <- \"http://foo.bar/baz\" try(   try_fetch(     download(file),     error = function(err) {       msg <- sprintf(\"Can't download `%s`\", file)       abort(msg, parent = err)   }) )  # You can also hard-code the call when it's not easy to # forward it from the caller  f <- function() {   abort(\"my message\", call = call(\"my_function\")) } g <- function() {   f() } # Shows that the error occured in `my_function()` try(g())  }"},{"path":"https://rlang.r-lib.org/dev/reference/are_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for missing values — are_na","title":"Test for missing values — are_na","text":"are_na() checks missing values vector equivalent base::.na(). vectorised predicate, meaning output always length input. hand, is_na() scalar predicate always returns scalar boolean, TRUE FALSE. input scalar, returns FALSE. Finally, typed versions check particular missing types.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/are_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for missing values — are_na","text":"","code":"are_na(x)  is_na(x)  is_lgl_na(x)  is_int_na(x)  is_dbl_na(x)  is_chr_na(x)  is_cpl_na(x)"},{"path":"https://rlang.r-lib.org/dev/reference/are_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for missing values — are_na","text":"x object test","code":""},{"path":"https://rlang.r-lib.org/dev/reference/are_na.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test for missing values — are_na","text":"scalar predicates accept non-vector inputs. equivalent is_null() respect. contrast vectorised predicate are_na() requires vector input since defined vector values.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/are_na.html","id":"life-cycle","dir":"Reference","previous_headings":"","what":"Life cycle","title":"Test for missing values — are_na","text":"functions might moved vctrs package point. marked questioning.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/are_na.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test for missing values — are_na","text":"","code":"# are_na() is vectorised and works regardless of the type are_na(c(1, 2, NA)) #> [1] FALSE FALSE  TRUE are_na(c(1L, NA, 3L)) #> [1] FALSE  TRUE FALSE  # is_na() checks for scalar input and works for all types is_na(NA) #> [1] TRUE is_na(na_dbl) #> [1] TRUE is_na(character(0)) #> [1] FALSE  # There are typed versions as well: is_lgl_na(NA) #> [1] TRUE is_lgl_na(na_dbl) #> [1] FALSE"},{"path":"https://rlang.r-lib.org/dev/reference/arg_match.html","id":null,"dir":"Reference","previous_headings":"","what":"Match an argument to a character vector — arg_match","title":"Match an argument to a character vector — arg_match","text":"equivalent base::match.arg() differences: Partial matches trigger error. Error messages bit informative obey tidyverse standards. arg_match() derives possible values caller function. arg_match0() bare-bones version performance premium. requires string arg explicit character values. convenience, arg may also character vector containing every element values, possibly permuted. case, first element arg used.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/arg_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match an argument to a character vector — arg_match","text":"","code":"arg_match(   arg,   values = NULL,   ...,   multiple = FALSE,   error_arg = caller_arg(arg),   error_call = caller_env() )  arg_match0(arg, values, arg_nm = caller_arg(arg), error_call = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/arg_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match an argument to a character vector — arg_match","text":"arg symbol referring argument accepting strings. values character vector possible values arg can take. ... dots future extensions must empty. multiple Whether arg may contain zero several values. error_arg argument name string. argument mentioned error messages input origin problem. error_call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. arg_nm error_arg.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/arg_match.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match an argument to a character vector — arg_match","text":"string supplied arg.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/arg_match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match an argument to a character vector — arg_match","text":"","code":"fn <- function(x = c(\"foo\", \"bar\")) arg_match(x) fn(\"bar\") #> [1] \"bar\"  # Throws an informative error for mismatches: try(fn(\"b\")) #> Error in fn(\"b\") : `x` must be one of \"foo\" or \"bar\", not \"b\". #> ℹ Did you mean \"bar\"? try(fn(\"baz\")) #> Error in fn(\"baz\") : `x` must be one of \"foo\" or \"bar\", not \"baz\". #> ℹ Did you mean \"bar\"?  # Use the bare-bones version with explicit values for speed: arg_match0(\"bar\", c(\"foo\", \"bar\", \"baz\")) #> [1] \"bar\"  # For convenience: fn1 <- function(x = c(\"bar\", \"baz\", \"foo\")) fn3(x) fn2 <- function(x = c(\"baz\", \"bar\", \"foo\")) fn3(x) fn3 <- function(x) arg_match0(x, c(\"foo\", \"bar\", \"baz\")) fn1() #> [1] \"bar\" fn2(\"bar\") #> [1] \"bar\" try(fn3(\"zoo\")) #> Error in fn3(\"zoo\") :  #>   `x` must be one of \"foo\", \"bar\", or \"baz\", not \"zoo\". #> ℹ Did you mean \"foo\"?"},{"path":"https://rlang.r-lib.org/dev/reference/args_data_masking.html","id":null,"dir":"Reference","previous_headings":"","what":"Argument type: data-masking — args_data_masking","title":"Argument type: data-masking — args_data_masking","text":"page describes <data-masking> argument modifier indicates argument uses tidy evaluation data masking. never heard tidy evaluation , start vignette(\"programming\", package = \"dplyr\").","code":""},{"path":"https://rlang.r-lib.org/dev/reference/args_data_masking.html","id":"key-terms","dir":"Reference","previous_headings":"","what":"Key terms","title":"Argument type: data-masking — args_data_masking","text":"primary motivation tidy evaluation tidyverse packages provides data masking, blurs distinction two types variables: env-variables \"programming\" variables live environment. usually created <-. Env-variables can type R object. data-variables \"statistical\" variables live data frame. usually come data files (e.g. .csv, .xls), created manipulating existing variables. Data-variables live inside data frames, must vectors.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/args_data_masking.html","id":"general-usage","dir":"Reference","previous_headings":"","what":"General usage","title":"Argument type: data-masking — args_data_masking","text":"Data masking allows refer variables \"current\" data frame (usually supplied .data argument), without prefix. allows type (e.g.) filter(diamonds, x == 0 & y == 0 & z == 0) instead diamonds[diamonds$x == 0 & diamonds$y == 0 & diamonds$z == 0, ].","code":""},{"path":"https://rlang.r-lib.org/dev/reference/args_data_masking.html","id":"indirection-in-wrapper-functions","dir":"Reference","previous_headings":"","what":"Indirection in wrapper functions","title":"Argument type: data-masking — args_data_masking","text":"main challenge data masking arises introduce indirection, .e. instead directly typing name variable want supply function argument character vector. two main cases: want user supply variable (function variables) function argument, embrace argument, e.g. filter(df, {{ var }}).   column name character vector, use .data pronoun, e.g. summarise(df, mean = mean(.data[[var]])).   (Note contents [[, e.g. var , never evaluated data environment need worry data-variable called var causing problems.)","code":"dist_summary <- function(df, var) {   df %>%     summarise(n = n(), min = min({{ var }}), max = max({{ var }})) } mtcars %>% dist_summary(mpg) mtcars %>% group_by(cyl) %>% dist_summary(mpg) for (var in names(mtcars)) {   mtcars %>% count(.data[[var]]) %>% print() }  lapply(names(mtcars), function(var) mtcars %>% count(.data[[var]]))"},{"path":"https://rlang.r-lib.org/dev/reference/args_data_masking.html","id":"dot-dot-dot-","dir":"Reference","previous_headings":"","what":"Dot-dot-dot (...)","title":"Argument type: data-masking — args_data_masking","text":"modifier applied ..., one useful technique solves problem creating new variable name supplied user. Use interpolation syntax glue package: \"{var}\" := expression. (Note use := instead = enable syntax).   Note ... automatically provides indirection, can use (.e. without embracing) inside function:","code":"var_name <- \"l100km\" mtcars %>% mutate(\"{var_name}\" := 235 / mpg) grouped_mean <- function(df, var, ...) {   df %>%     group_by(...) %>%     summarise(mean = mean({{ var }})) }"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/args_dots_empty.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper for consistent documentation of empty dots — args_dots_empty","title":"Helper for consistent documentation of empty dots — args_dots_empty","text":"Use @inheritParams rlang::args_dots_empty package consistently document ... must empty.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/args_dots_empty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper for consistent documentation of empty dots — args_dots_empty","text":"... dots future extensions must empty.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/args_dots_used.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper for consistent documentation of used dots — args_dots_used","title":"Helper for consistent documentation of used dots — args_dots_used","text":"Use @inheritParams rlang::args_dots_used package consistently document ... must used.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/args_dots_used.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper for consistent documentation of used dots — args_dots_used","text":"... Arguments passed methods.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/args_error_context.html","id":null,"dir":"Reference","previous_headings":"","what":"Documentation anchor for error arguments — args_error_context","title":"Documentation anchor for error arguments — args_error_context","text":"Use @inheritParams rlang::args_error_context package document arg call arguments (equivalently prefixed versions error_arg error_call). arg parameters formatted argument (e.g. using cli's .arg specifier) included error messages. See also caller_arg(). call parameters included error conditions field named call. easy way passing call argument abort(). See also local_error_call().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/args_error_context.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Documentation anchor for error arguments — args_error_context","text":"arg argument name string. argument mentioned error messages input origin problem. error_arg argument name string. argument mentioned error messages input origin problem. call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. error_call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_box.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert object to a box — as_box","title":"Convert object to a box — as_box","text":"as_box() boxes input already box. class also checked supplied. as_box_if() boxes input already box, predicate .p returns TRUE.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_box.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert object to a box — as_box","text":"","code":"as_box(x, class = NULL)  as_box_if(.x, .p, .class = NULL, ...)"},{"path":"https://rlang.r-lib.org/dev/reference/as_box.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert object to a box — as_box","text":"x, .x R object. class, .class box class. input already box class, returned . input needs boxed, class passed new_box(). .p predicate function. ... Arguments passed .p.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_closure.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform to a closure — as_closure","title":"Transform to a closure — as_closure","text":"as_closure() like as_function() also wraps primitive functions inside closures. special control flow primitives like , , break wrapped cause error.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_closure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform to a closure — as_closure","text":"","code":"as_closure(x, env = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/as_closure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform to a closure — as_closure","text":"x function formula. function, used . formula, e.g. ~ .x + 2, converted function two arguments: .x (single argument) .x .y (two arguments). . placeholder can used instead .x. allows create compact anonymous functions (lambdas) two inputs. Functions created formulas special class. Use is_lambda() test . string, function looked env. Note interface strictly user convenience scoping issues involved. Package developers avoid supplying functions name instead supply value. env Environment fetch function case x string.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_closure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform to a closure — as_closure","text":"","code":"# Primitive functions are regularised as closures as_closure(list) #> function (...)  #> .Primitive(\"list\")(...) as_closure(\"list\") #> function (...)  #> .Primitive(\"list\")(...)  # Operators have `.x` and `.y` as arguments, just like lambda # functions created with the formula syntax: as_closure(`+`) #> function (e1, e2, .x = e1, .y = e2)  #> { #>     if (missing(.x)) { #>         if (missing(e1)) { #>             abort(\"Must supply `e1` or `.x` to binary operator.\") #>         } #>         .x <- e1 #>     } #>     else if (!missing(e1)) { #>         abort(\"Can't supply both `e1` and `.x` to binary operator.\") #>     } #>     if (missing(.y) && !missing(e2)) { #>         .y <- e2 #>     } #>     else if (!missing(e2)) { #>         abort(\"Can't supply both `e2` and `.y` to binary operator.\") #>     } #>     if (missing(.y))  #>         .x #>     else .x + .y #> } #> <environment: 0x562dde0db798> as_closure(`~`) #> function (.x, .y)  #> { #>     if (is_missing(substitute(.y))) { #>         new_formula(NULL, substitute(.x), caller_env()) #>     } #>     else { #>         new_formula(substitute(.x), substitute(.y), caller_env()) #>     } #> } #> <bytecode: 0x562dd7556750> #> <environment: 0x562ddc90f758>"},{"path":"https://rlang.r-lib.org/dev/reference/as_data_mask.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a data mask — as_data_mask","title":"Create a data mask — as_data_mask","text":"data mask environment (possibly multiple environments forming ancestry) containing user-supplied objects. Objects mask precedence objects environment (.e. mask objects). Many R functions evaluate quoted expressions data mask expressions can refer objects within user data. functions let construct tidy eval data mask manually. meant developers tidy eval interfaces rather end users.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_data_mask.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a data mask — as_data_mask","text":"","code":"as_data_mask(data)  as_data_pronoun(data)  new_data_mask(bottom, top = bottom)"},{"path":"https://rlang.r-lib.org/dev/reference/as_data_mask.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a data mask — as_data_mask","text":"data data frame named vector masking data. bottom environment containing masking objects data mask one environment deep. bottom environment data mask comprises multiple environment. supplied top, must environment , .e. created . top last environment data mask. data mask one environment deep, top bottom. must environment , .e. created . parent top changed tidy eval engine considered undetermined. Never make assumption parent top.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_data_mask.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a data mask — as_data_mask","text":"data mask can supply eval_tidy().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_data_mask.html","id":"why-build-a-data-mask-","dir":"Reference","previous_headings":"","what":"Why build a data mask?","title":"Create a data mask — as_data_mask","text":"time can just call eval_tidy() list data frame data mask constructed automatically. three main use cases manual creation data masks: eval_tidy() called data tight loop. overhead creating tidy eval data masks, constructing mask reusing subsequent evaluations may improve performance. several expressions evaluated exact environment quoted expression might create new objects can referred quoted expressions evaluated later time. One example tibble::lst() new columns can refer previous ones. data mask requires special features. instance data frame columns dplyr data masks implemented active bindings.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_data_mask.html","id":"building-your-own-data-mask","dir":"Reference","previous_headings":"","what":"Building your own data mask","title":"Create a data mask — as_data_mask","text":"Unlike base::eval() takes kind environments data mask, eval_tidy() specific requirements order support quosures. reason supply bare environments. two ways constructing rlang data mask manually: as_data_mask() transforms list data frame data mask. automatically installs data pronoun .data. new_data_mask() bare bones data mask constructor environments. can supply bottom top environment case data mask comprises multiple environments (see section ). Unlike as_data_mask() install .data pronoun need provide one . can provide pronoun constructed as_data_pronoun() pronoun class. as_data_pronoun() create pronoun list, environment, rlang data mask. latter case, whole ancestry looked bottom top mask. Functions stored mask bypassed pronoun. built data mask, simply pass eval_tidy() data argument. can repeat many times needed. Note objects created (perhaps call <-) persist subsequent evaluations.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_data_mask.html","id":"top-and-bottom-of-data-mask","dir":"Reference","previous_headings":"","what":"Top and bottom of data mask","title":"Create a data mask — as_data_mask","text":"cases need several levels data mask. One good reason include functions mask. good idea keep data objects one level lower function objects, former override definitions latter (see examples). case, set environments keep track bottom child top parent. need pass new_data_mask(). Note parent top environment completely undetermined, expect remain times. parent replaced evaluation eval_tidy() one following environments: default environment passed env argument eval_tidy(). environment current quosure evaluated, applicable. Consequently, masking data contained bottom top environment data mask.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_data_mask.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a data mask — as_data_mask","text":"","code":"# Evaluating in a tidy evaluation environment enables all tidy # features: mask <- as_data_mask(mtcars) eval_tidy(quo(letters), mask) #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" #> [17] \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"  # You can install new pronouns in the mask: mask$.pronoun <- as_data_pronoun(list(foo = \"bar\", baz = \"bam\")) eval_tidy(quo(.pronoun$foo), mask) #> [1] \"bar\"  # In some cases the data mask can leak to the user, for example if # a function or formula is created in the data mask environment: cyl <- \"user variable from the context\" fn <- eval_tidy(quote(function() cyl), mask) fn() #>  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4  # If new objects are created in the mask, they persist in the # subsequent calls: eval_tidy(quote(new <- cyl + am), mask) eval_tidy(quote(new * 2), mask) #>  [1] 14 14 10 12 16 12 16  8  8 12 12 16 16 16 16 16 16 10 10 10  8 16 #> [23] 16 16 16 10 10 10 18 14 18 10   # In some cases your data mask is a whole chain of environments # rather than a single environment. You'll have to use # `new_data_mask()` and let it know about the bottom of the mask # (the last child of the environment chain) and the topmost parent.  # A common situation where you'll want a multiple-environment mask # is when you include functions in your mask. In that case you'll # put functions in the top environment and data in the bottom. This # will prevent the data from overwriting the functions. top <- new_environment(list(`+` = base::paste, c = base::paste))  # Let's add a middle environment just for sport: middle <- env(top)  # And finally the bottom environment containing data: bottom <- env(middle, a = \"a\", b = \"b\", c = \"c\")  # We can now create a mask by supplying the top and bottom # environments: mask <- new_data_mask(bottom, top = top)  # This data mask can be passed to eval_tidy() instead of a list or # data frame: eval_tidy(quote(a + b + c), data = mask) #> [1] \"a b c\"  # Note how the function `c()` and the object `c` are looked up # properly because of the multi-level structure: eval_tidy(quote(c(a, b, c)), data = mask) #> [1] \"a b c\"  # new_data_mask() does not create data pronouns, but # data pronouns can be added manually: mask$.fns <- as_data_pronoun(top)  # The `.data` pronoun should generally be created from the # mask. This will ensure data is looked up throughout the whole # ancestry. Only non-function objects are looked up from this # pronoun: mask$.data <- as_data_pronoun(mask) mask$.data$c #> [1] \"c\"  # Now we can reference values with the pronouns: eval_tidy(quote(c(.data$a, .data$b, .data$c)), data = mask) #> [1] \"a b c\""},{"path":"https://rlang.r-lib.org/dev/reference/as_environment.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to an environment — as_environment","title":"Coerce to an environment — as_environment","text":"as_environment() coerces named vectors (including lists) environment. names must unique. supplied unnamed string, returns corresponding package environment (see pkg_env()).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_environment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to an environment — as_environment","text":"","code":"as_environment(x, parent = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/as_environment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to an environment — as_environment","text":"x object coerce. parent parent environment, empty_env() default. argument used x data actually coerced environment (opposed data representing environment, like NULL representing empty environment).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_environment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coerce to an environment — as_environment","text":"x environment parent NULL, environment duplicated set new parent. return value therefore different environment x.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_environment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce to an environment — as_environment","text":"","code":"# Coerce a named vector to an environment: env <- as_environment(mtcars)  # By default it gets the empty environment as parent: identical(env_parent(env), empty_env()) #> [1] TRUE   # With strings it is a handy shortcut for pkg_env(): as_environment(\"base\") #> <environment: base> as_environment(\"rlang\") #> <environment: package:rlang> #> attr(,\"name\") #> [1] \"package:rlang\" #> attr(,\"path\") #> [1] \"/home/runner/work/_temp/Library/rlang\"  # With NULL it returns the empty environment: as_environment(NULL) #> <environment: R_EmptyEnv>"},{"path":"https://rlang.r-lib.org/dev/reference/as_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to function — as_function","title":"Convert to function — as_function","text":"as_function() transforms one-sided formula function. powers lambda syntax packages like purrr.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to function — as_function","text":"","code":"as_function(   x,   env = global_env(),   ...,   arg = caller_arg(x),   call = caller_env() )  is_lambda(x)"},{"path":"https://rlang.r-lib.org/dev/reference/as_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to function — as_function","text":"x function formula. function, used . formula, e.g. ~ .x + 2, converted function two arguments: .x (single argument) .x .y (two arguments). . placeholder can used instead .x. allows create compact anonymous functions (lambdas) two inputs. Functions created formulas special class. Use is_lambda() test . string, function looked env. Note interface strictly user convenience scoping issues involved. Package developers avoid supplying functions name instead supply value. env Environment fetch function case x string. ... dots future extensions must empty. arg argument name string. argument mentioned error messages input origin problem. call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert to function — as_function","text":"","code":"f <- as_function(~ .x + 1) f(10) #> [1] 11  g <- as_function(~ -1 * .) g(4) #> [1] -4  h <- as_function(~ .x - .y) h(6, 3) #> [1] 3  # Functions created from a formula have a special class: is_lambda(f) #> [1] TRUE is_lambda(as_function(function() \"foo\")) #> [1] FALSE"},{"path":"https://rlang.r-lib.org/dev/reference/as_label.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a default name for an R object — as_label","title":"Create a default name for an R object — as_label","text":"as_label() transforms R objects short, human-readable description. can use labels : Display object concise way, example labellise axes graphical plot. Give default names columns data frame. case, labelling first step name repair. See also as_name() transforming symbols back string. Unlike as_label(), as_name() well defined operation guarantees roundtrip symbol -> string -> symbol. general, know sure kind object dealing (call, symbol, unquoted constant), use as_label() make assumption resulting string. know symbol need name object refers , use as_name(). instance, use as_label() objects captured enquo() as_name() symbols captured ensym().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_label.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a default name for an R object — as_label","text":"","code":"as_label(x)"},{"path":"https://rlang.r-lib.org/dev/reference/as_label.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a default name for an R object — as_label","text":"x object.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_label.html","id":"transformation-to-string","dir":"Reference","previous_headings":"","what":"Transformation to string","title":"Create a default name for an R object — as_label","text":"Quosures squashed labelled. Symbols transformed string as_string(). Calls abbreviated. Numbers represented . constants represented type, <dbl> <data.frame>.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/as_label.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a default name for an R object — as_label","text":"","code":"# as_label() is useful with quoted expressions: as_label(expr(foo(bar))) #> [1] \"foo(bar)\"  as_label(expr(foobar)) #> [1] \"foobar\"  # It works with any R object. This is also useful for quoted # arguments because the user might unquote constant objects: as_label(1:3) #> [1] \"<int>\"  as_label(base::list) #> [1] \"<fn>\""},{"path":"https://rlang.r-lib.org/dev/reference/as_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract names from symbols — as_name","title":"Extract names from symbols — as_name","text":"as_name() converts symbols character strings. conversion deterministic. , roundtrip symbol -> name -> symbol always gives result. Use as_name() need transform symbol string refer object name. Use as_label() need transform kind object string represent object short description.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract names from symbols — as_name","text":"","code":"as_name(x)"},{"path":"https://rlang.r-lib.org/dev/reference/as_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract names from symbols — as_name","text":"x string symbol, possibly wrapped quosure. string, attributes removed, .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract names from symbols — as_name","text":"character vector length 1.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_name.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract names from symbols — as_name","text":"rlang::as_name() opposite base::.name(). writing base R code, recommend using base::.symbol() alias .name() follows modern terminology (R types instead S modes).","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/as_name.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract names from symbols — as_name","text":"","code":"# Let's create some symbols: foo <- quote(foo) bar <- sym(\"bar\")  # as_name() converts symbols to strings: foo #> foo as_name(foo) #> [1] \"foo\"  typeof(bar) #> [1] \"symbol\" typeof(as_name(bar)) #> [1] \"character\"  # as_name() unwraps quosured symbols automatically: as_name(quo(foo)) #> [1] \"foo\""},{"path":"https://rlang.r-lib.org/dev/reference/as_string.html","id":null,"dir":"Reference","previous_headings":"","what":"Cast symbol to string — as_string","title":"Cast symbol to string — as_string","text":"as_string() converts symbols character strings.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_string.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cast symbol to string — as_string","text":"","code":"as_string(x)"},{"path":"https://rlang.r-lib.org/dev/reference/as_string.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cast symbol to string — as_string","text":"x string symbol. string, attributes removed, .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_string.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cast symbol to string — as_string","text":"character vector length 1.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_string.html","id":"unicode-tags","dir":"Reference","previous_headings":"","what":"Unicode tags","title":"Cast symbol to string — as_string","text":"Unlike base::.symbol() base::.name(), as_string() automatically transforms unicode tags \"<U+5E78>\" proper UTF-8 character. important Windows : R Windows UTF-8 support, uses native encoding instead. native encodings cover Unicode characters. example, Western encodings support CKJ characters. lossy UTF-8 -> native transformation occurs, uncovered characters transformed ASCII unicode tag like \"<U+5E78>\". Symbols always encoded native. means transforming column names data frame symbols might lossy operation. operation common tidyverse data masking APIs like dplyr data frames transformed environments. names data frame stored character vector, bindings environments stored symbols. reencodes ASCII unicode tags UTF-8 representation, string -> symbol -> string roundtrip stable as_string().","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/as_string.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cast symbol to string — as_string","text":"","code":"# Let's create some symbols: foo <- quote(foo) bar <- sym(\"bar\")  # as_string() converts symbols to strings: foo #> foo as_string(foo) #> [1] \"foo\"  typeof(bar) #> [1] \"symbol\" typeof(as_string(bar)) #> [1] \"character\""},{"path":"https://rlang.r-lib.org/dev/reference/as_utf8_character.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a character vector and attempt encoding conversion — as_utf8_character","title":"Coerce to a character vector and attempt encoding conversion — as_utf8_character","text":"Unlike specifying encoding argument as_string() as_character(), declarative, functions actually attempt convert encoding input. two possible cases: string tagged UTF-8 latin1, two encodings R specific support. case, converting encoding -op, converting native always works expected, long native encoding, one specified LC_CTYPE locale support characters occurring strings. Unrepresentable characters serialised unicode points: \"<U+xxxx>\". string tagged. R assumes encoded native encoding. Conversion native -op, conversion UTF-8 work long string actually encoded locale codeset. translating UTF-8, strings parsed serialised unicode points (e.g. strings looking like \"U+xxxx\") chr_unserialise_unicode(). helps alleviate effects character--symbol--character roundtrips systems non-UTF-8 native encoding.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_utf8_character.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a character vector and attempt encoding conversion — as_utf8_character","text":"","code":"as_utf8_character(x)"},{"path":"https://rlang.r-lib.org/dev/reference/as_utf8_character.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a character vector and attempt encoding conversion — as_utf8_character","text":"x object coerce.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/as_utf8_character.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce to a character vector and attempt encoding conversion — as_utf8_character","text":"","code":"# Let's create a string marked as UTF-8 (which is guaranteed by the # Unicode escaping in the string): utf8 <- \"caf\\uE9\" Encoding(utf8) #> [1] \"UTF-8\" charToRaw(utf8) #> [1] 63 61 66 c3 a9"},{"path":"https://rlang.r-lib.org/dev/reference/bare-type-predicates.html","id":null,"dir":"Reference","previous_headings":"","what":"Bare type predicates — bare-type-predicates","title":"Bare type predicates — bare-type-predicates","text":"predicates check given type return TRUE bare R objects. Bare objects class attributes. example, data frame list, bare list.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/bare-type-predicates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bare type predicates — bare-type-predicates","text":"","code":"is_bare_list(x, n = NULL)  is_bare_atomic(x, n = NULL)  is_bare_vector(x, n = NULL)  is_bare_double(x, n = NULL)  is_bare_complex(x, n = NULL)  is_bare_integer(x, n = NULL)  is_bare_numeric(x, n = NULL)  is_bare_character(x, n = NULL)  is_bare_logical(x, n = NULL)  is_bare_raw(x, n = NULL)  is_bare_string(x, n = NULL)  is_bare_bytes(x, n = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/bare-type-predicates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bare type predicates — bare-type-predicates","text":"x Object tested. n Expected length vector.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/bare-type-predicates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bare type predicates — bare-type-predicates","text":"predicates vectors include n argument pattern-matching vector length. Like is_atomic() unlike base R .atomic() R < 4.4.0, is_bare_atomic() return TRUE NULL. Starting R 4.4.0, .atomic(NULL) returns FALSE. Unlike base R .numeric(), is_bare_double() returns TRUE floating point numbers.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/box.html","id":null,"dir":"Reference","previous_headings":"","what":"Box a value — box","title":"Box a value — box","text":"new_box() similar base::() protects value wrapping scalar list rather adding attribute. unbox() retrieves boxed value. is_box() tests whether object boxed optional class. as_box() ensures value wrapped box. as_box_if() value matches predicate.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/box.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Box a value — box","text":"","code":"new_box(.x, class = NULL, ...)  is_box(x, class = NULL)  unbox(box)"},{"path":"https://rlang.r-lib.org/dev/reference/box.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Box a value — box","text":"class new_box(), additional class boxed value (addition rlang_box). is_box(), class vector classes passed inherits_all(). ... Additional attributes passed base::structure(). x, .x R object. box boxed value unbox.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/box.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Box a value — box","text":"","code":"boxed <- new_box(letters, \"mybox\") is_box(boxed) #> [1] TRUE is_box(boxed, \"mybox\") #> [1] TRUE is_box(boxed, \"otherbox\") #> [1] FALSE  unbox(boxed) #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" #> [17] \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"  # as_box() avoids double-boxing: boxed2 <- as_box(boxed, \"mybox\") boxed2 #> [[1]] #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" #> [17] \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>  #> attr(,\"class\") #> [1] \"mybox\"     \"rlang_box\" unbox(boxed2) #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" #> [17] \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"  # Compare to: boxed_boxed <- new_box(boxed, \"mybox\") boxed_boxed #> [[1]] #> [[1]] #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" #> [17] \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>  #> attr(,\"class\") #> [1] \"mybox\"     \"rlang_box\" #>  #> attr(,\"class\") #> [1] \"mybox\"     \"rlang_box\" unbox(unbox(boxed_boxed)) #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" #> [17] \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"  # Use `as_box_if()` with a predicate if you need to ensure a box # only for a subset of values: as_box_if(NULL, is_null, \"null_box\") #> [[1]] #> NULL #>  #> attr(,\"class\") #> [1] \"null_box\"  \"rlang_box\" as_box_if(\"foo\", is_null, \"null_box\") #> [1] \"foo\""},{"path":"https://rlang.r-lib.org/dev/reference/bytes-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Human readable memory sizes — bytes-class","title":"Human readable memory sizes — bytes-class","text":"Construct, manipulate display vectors byte sizes. numeric vectors, can compare numerically, can also compared human readable values '10MB'. parse_bytes() takes character vector human-readable bytes returns structured bytes vector. as_bytes() generic conversion function objects representing bytes. Note: bytes() constructor exported soon.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/bytes-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Human readable memory sizes — bytes-class","text":"","code":"as_bytes(x)  parse_bytes(x)"},{"path":"https://rlang.r-lib.org/dev/reference/bytes-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Human readable memory sizes — bytes-class","text":"x numeric character vector. Character representations can use shorthand sizes (see examples).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/bytes-class.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Human readable memory sizes — bytes-class","text":"memory sizes always assumed base 1000, rather 1024.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/bytes-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Human readable memory sizes — bytes-class","text":"","code":"parse_bytes(\"1\") #> [1] 1 B parse_bytes(\"1K\") #> [1] 1 kB parse_bytes(\"1Kb\") #> [1] 1 kB parse_bytes(\"1KiB\") #> [1] 1 kB parse_bytes(\"1MB\") #> [1] 1 MB  parse_bytes(\"1KB\") < \"1MB\" #> [1] TRUE  sum(parse_bytes(c(\"1MB\", \"5MB\", \"500KB\"))) #> [1] 6.50 MB"},{"path":"https://rlang.r-lib.org/dev/reference/call2.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a call — call2","title":"Create a call — call2","text":"Quoted function calls one two types symbolic objects R. represent action calling function, possibly arguments. two ways creating quoted call: quoting . Quoting prevents functions called. Instead, get description function call R object. , quoted function call. constructing base::call(), base::.call(), call2(). case, pass call elements (function call arguments call ) separately. See section difference call2() base constructors.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a call — call2","text":"","code":"call2(.fn, ..., .ns = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/call2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a call — call2","text":".fn Function call. Must callable object: string, symbol, call, function. ... <dynamic> Arguments function call. Empty arguments preserved. .ns Namespace prefix .fn. Must string symbol.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call2.html","id":"difference-with-base-constructors","dir":"Reference","previous_headings":"","what":"Difference with base constructors","title":"Create a call — call2","text":"call2() flexible base::call(): function call can string callable object: symbol, another call (e.g. $ [[ call), function inline. base::call() supports strings need use base::.call() construct call callable object.   .ns argument convenient creating namespaced calls.   call2() dynamic dots support. can splice lists arguments !!! unquote argument name glue syntax.","code":"call2(list, 1, 2)  as.call(list(list, 1, 2)) call2(\"list\", 1, 2, .ns = \"base\")  # Equivalent to ns_call <- call(\"::\", as.symbol(\"list\"), as.symbol(\"base\")) as.call(list(ns_call, 1, 2)) args <- list(na.rm = TRUE, trim = 0)  call2(\"mean\", 1:10, !!!args)  # Equivalent to as.call(c(list(as.symbol(\"mean\"), 1:10), args))"},{"path":"https://rlang.r-lib.org/dev/reference/call2.html","id":"caveats-of-inlining-objects-in-calls","dir":"Reference","previous_headings":"","what":"Caveats of inlining objects in calls","title":"Create a call — call2","text":"call2() makes possible inline objects calls, function argument positions. Inlining object function advantage correct object used environments. components code inlined, can even evaluate empty environment. However inlining also drawbacks. can cause issues NSE functions expect symbolic arguments. objects may also leak representations call stack, traceback().","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/call2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a call — call2","text":"","code":"# fn can either be a string, a symbol or a call call2(\"f\", a = 1) #> f(a = 1) call2(quote(f), a = 1) #> f(a = 1) call2(quote(f()), a = 1) #> f()(a = 1)  #' Can supply arguments individually or in a list call2(quote(f), a = 1, b = 2) #> f(a = 1, b = 2) call2(quote(f), !!!list(a = 1, b = 2)) #> f(a = 1, b = 2)  # Creating namespaced calls is easy: call2(\"fun\", arg = quote(baz), .ns = \"mypkg\") #> mypkg::fun(arg = baz)  # Empty arguments are preserved: call2(\"[\", quote(x), , drop = ) #> x[, drop = ]"},{"path":"https://rlang.r-lib.org/dev/reference/call_args.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract arguments from a call — call_args","title":"Extract arguments from a call — call_args","text":"Extract arguments call","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_args.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract arguments from a call — call_args","text":"","code":"call_args(call)  call_args_names(call)"},{"path":"https://rlang.r-lib.org/dev/reference/call_args.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract arguments from a call — call_args","text":"call defused call.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_args.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract arguments from a call — call_args","text":"named list arguments.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/call_args.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract arguments from a call — call_args","text":"","code":"call <- quote(f(a, b))  # Subsetting a call returns the arguments converted to a language # object: call[-1] #> a(b)  # On the other hand, call_args() returns a regular list that is # often easier to work with: str(call_args(call)) #> List of 2 #>  $ : symbol a #>  $ : symbol b  # When the arguments are unnamed, a vector of empty strings is # supplied (rather than NULL): call_args_names(call) #> [1] \"\" \"\""},{"path":"https://rlang.r-lib.org/dev/reference/call_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract function from a call — call_fn","title":"Extract function from a call — call_fn","text":"Deprecated rlang 0.4.11.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract function from a call — call_fn","text":"","code":"call_fn(call, env = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/call_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract function from a call — call_fn","text":"call, env","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_inspect.html","id":null,"dir":"Reference","previous_headings":"","what":"Inspect a call — call_inspect","title":"Inspect a call — call_inspect","text":"function wrapper around base::match.call(). returns function call.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_inspect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inspect a call — call_inspect","text":"","code":"call_inspect(...)"},{"path":"https://rlang.r-lib.org/dev/reference/call_inspect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inspect a call — call_inspect","text":"... Arguments display returned call.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_inspect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inspect a call — call_inspect","text":"","code":"# When you call it directly, it simply returns what you typed call_inspect(foo(bar), \"\" %>% identity()) #> call_inspect(foo(bar), \"\" %>% identity())  # Pass `call_inspect` to functionals like `lapply()` or `map()` to # inspect the calls they create around the supplied function lapply(1:3, call_inspect) #> [[1]] #> FUN(X[[i]]) #>  #> [[2]] #> FUN(X[[i]]) #>  #> [[3]] #> FUN(X[[i]]) #>"},{"path":"https://rlang.r-lib.org/dev/reference/call_match.html","id":null,"dir":"Reference","previous_headings":"","what":"Match supplied arguments to function definition — call_match","title":"Match supplied arguments to function definition — call_match","text":"call_match() like match.call() differences: supports matching missing argument defaults function definition. requires little specific cases. Either arguments inferred call stack none (see Inference section).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_match.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match supplied arguments to function definition — call_match","text":"","code":"call_match(   call = NULL,   fn = NULL,   ...,   defaults = FALSE,   dots_env = NULL,   dots_expand = TRUE )"},{"path":"https://rlang.r-lib.org/dev/reference/call_match.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match supplied arguments to function definition — call_match","text":"call call. arguments matched fn. fn function definition match arguments . ... dots must empty. defaults Whether match missing arguments defaults. dots_env execution environment find dots. supplied dots exist environment, call includes ..., forwarded dots matched numbered dots (e.g. ..1, ..2, etc). default set empty environment means ... expands nothing. dots_expand FALSE, arguments passed ... spliced call. Instead, gathered pairlist assigned argument named .... Gathering dots arguments useful need separate named arguments. Note resulting call meant evaluated since R support passing dots named argument, even named \"...\".","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_match.html","id":"inference-from-the-call-stack","dir":"Reference","previous_headings":"","what":"Inference from the call stack","title":"Match supplied arguments to function definition — call_match","text":"call supplied, inferred call stack along fn dots_env. call fn inferred calling environment: sys.call(sys.parent()) sys.function(sys.parent()). dots_env inferred caller calling environment: caller_env(2). call supplied, must supply fn well. Also consider supplying dots_env set empty environment inferred.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_match.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match supplied arguments to function definition — call_match","text":"","code":"# `call_match()` supports matching missing arguments to their # defaults fn <- function(x = \"default\") fn call_match(quote(fn()), fn) #> fn() call_match(quote(fn()), fn, defaults = TRUE) #> fn(x = \"default\")"},{"path":"https://rlang.r-lib.org/dev/reference/call_modify.html","id":null,"dir":"Reference","previous_headings":"","what":"Modify the arguments of a call — call_modify","title":"Modify the arguments of a call — call_modify","text":"working user-supplied call, make sure arguments standardised call_match() modifying call.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_modify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modify the arguments of a call — call_modify","text":"","code":"call_modify(   .call,   ...,   .homonyms = c(\"keep\", \"first\", \"last\", \"error\"),   .standardise = NULL,   .env = caller_env() )"},{"path":"https://rlang.r-lib.org/dev/reference/call_modify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modify the arguments of a call — call_modify","text":".call Can call, formula quoting call right-hand side, frame object extract call expression. ... <dynamic> Named unnamed expressions (constants, names calls) used modify call. Use zap() remove arguments. Empty arguments preserved. .homonyms treat arguments name. default, \"keep\", preserves arguments. Set .homonyms \"first\" keep first occurrences, \"last\" keep last occurrences, \"error\" raise informative error indicate arguments duplicated names. .standardise, .env Deprecated rlang 0.3.0. Please call call_match() manually.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_modify.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modify the arguments of a call — call_modify","text":"quosure .call quosure, call otherwise.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_modify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modify the arguments of a call — call_modify","text":"","code":"call <- quote(mean(x, na.rm = TRUE))  # Modify an existing argument call_modify(call, na.rm = FALSE) #> mean(x, na.rm = FALSE) call_modify(call, x = quote(y)) #> mean(x, na.rm = TRUE, x = y)  # Remove an argument call_modify(call, na.rm = zap()) #> mean(x)  # Add a new argument call_modify(call, trim = 0.1) #> mean(x, na.rm = TRUE, trim = 0.1)  # Add an explicit missing argument: call_modify(call, na.rm = ) #> mean(x, na.rm = )  # Supply a list of new arguments with `!!!` newargs <- list(na.rm = zap(), trim = 0.1) call <- call_modify(call, !!!newargs) call #> mean(x, trim = 0.1)  # Remove multiple arguments by splicing zaps: newargs <- rep_named(c(\"na.rm\", \"trim\"), list(zap())) call <- call_modify(call, !!!newargs) call #> mean(x)   # Modify the `...` arguments as if it were a named argument: call <- call_modify(call, ... = ) call #> mean(x, ...)  call <- call_modify(call, ... = zap()) call #> mean(x)   # When you're working with a user-supplied call, standardise it # beforehand in case it includes unmatched arguments: user_call <- quote(matrix(x, nc = 3)) call_modify(user_call, ncol = 1) #> matrix(x, nc = 3, ncol = 1)  # `call_match()` applies R's argument matching rules. Matching # ensures you're modifying the intended argument. user_call <- call_match(user_call, matrix) user_call #> matrix(data = x, ncol = 3) call_modify(user_call, ncol = 1) #> matrix(data = x, ncol = 1)   # By default, arguments with the same name are kept. This has # subtle implications, for instance you can move an argument to # last position by removing it and remapping it: call <- quote(foo(bar = , baz)) call_modify(call, bar = zap(), bar = missing_arg()) #> foo(baz, bar = )  # You can also choose to keep only the first or last homonym # arguments: args <-  list(bar = zap(), bar = missing_arg()) call_modify(call, !!!args, .homonyms = \"first\") #> foo(baz) call_modify(call, !!!args, .homonyms = \"last\") #> foo(bar = , baz)"},{"path":"https://rlang.r-lib.org/dev/reference/call_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract function name or namespace of a call — call_name","title":"Extract function name or namespace of a call — call_name","text":"call_name() call_ns() extract function name namespace simple calls string. return NULL complex calls. Simple calls: foo(), bar::foo(). Complex calls: foo()(), bar::foo, foo$bar(), (function() NULL)(). is_call_simple() predicate helps determine whether call simple. two invariants can count : is_call_simple(x) returns TRUE, call_name(x) returns string. Otherwise returns NULL. is_call_simple(x, ns = TRUE) returns TRUE, call_ns() returns string. Otherwise returns NULL.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract function name or namespace of a call — call_name","text":"","code":"call_name(call)  call_ns(call)  is_call_simple(x, ns = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/call_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract function name or namespace of a call — call_name","text":"call defused call. x object test. ns Whether call namespaced. NULL, is_call_simple() insensitive namespaces. TRUE, is_call_simple() detects namespaced calls. FALSE, detects unnamespaced calls.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract function name or namespace of a call — call_name","text":"function name namespace string, NULL call named namespaced.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_name.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract function name or namespace of a call — call_name","text":"","code":"# Is the function named? is_call_simple(quote(foo())) #> [1] TRUE is_call_simple(quote(foo[[1]]())) #> [1] FALSE  # Is the function namespaced? is_call_simple(quote(list()), ns = TRUE) #> [1] FALSE is_call_simple(quote(base::list()), ns = TRUE) #> [1] TRUE  # Extract the function name from quoted calls: call_name(quote(foo(bar))) #> [1] \"foo\" call_name(quo(foo(bar))) #> [1] \"foo\"  # Namespaced calls are correctly handled: call_name(quote(base::matrix(baz))) #> [1] \"matrix\"  # Anonymous and subsetted functions return NULL: call_name(quote(foo$bar())) #> NULL call_name(quote(foo[[bar]]())) #> NULL call_name(quote(foo()())) #> NULL  # Extract namespace of a call with call_ns(): call_ns(quote(base::bar())) #> [1] \"base\"  # If not namespaced, call_ns() returns NULL: call_ns(quote(bar())) #> NULL"},{"path":"https://rlang.r-lib.org/dev/reference/call_standardise.html","id":null,"dir":"Reference","previous_headings":"","what":"Standardise a call — call_standardise","title":"Standardise a call — call_standardise","text":"Deprecated rlang 0.4.11 favour call_match(). call_standardise() designed call wrappers include environment like formulas quosures. function definition plucked environment. However practice rare use wrapped calls, easy forget supply environment. reasons, designed call_match() simpler wrapper around match.call(). essentially equivalent base::match.call(), experimental handling primitive functions.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_standardise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standardise a call — call_standardise","text":"","code":"call_standardise(call, env = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/call_standardise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Standardise a call — call_standardise","text":"call, env","code":""},{"path":"https://rlang.r-lib.org/dev/reference/call_standardise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Standardise a call — call_standardise","text":"quosure call quosure, raw call otherwise.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/caller_arg.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the caller argument for error messages — caller_arg","title":"Find the caller argument for error messages — caller_arg","text":"caller_arg() variant substitute() ensym() arguments reference arguments. Unlike substitute() returns expression, caller_arg() formats expression single line string can included error messages. included error message, resulting label generally formatted argument, instance using .arg cli package. Use @inheritParams rlang::args_error_context document arg error_arg argument takes error_arg() default.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/caller_arg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the caller argument for error messages — caller_arg","text":"arg argument name current function.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/caller_arg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find the caller argument for error messages — caller_arg","text":"","code":"arg_checker <- function(x, arg = caller_arg(x), call = caller_env()) {   cli::cli_abort(\"{.arg {arg}} must be a thingy.\", arg = arg, call = call) }  my_function <- function(my_arg) {   arg_checker(my_arg) }  try(my_function(NULL)) #> Error in my_function(NULL) : `my_arg` must be a thingy."},{"path":"https://rlang.r-lib.org/dev/reference/catch_cnd.html","id":null,"dir":"Reference","previous_headings":"","what":"Catch a condition — catch_cnd","title":"Catch a condition — catch_cnd","text":"small wrapper around tryCatch() captures condition signalled evaluating argument. useful situations expect specific condition signalled, debugging, unit testing.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/catch_cnd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Catch a condition — catch_cnd","text":"","code":"catch_cnd(expr, classes = \"condition\")"},{"path":"https://rlang.r-lib.org/dev/reference/catch_cnd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Catch a condition — catch_cnd","text":"expr Expression evaluated catching condition handler. classes character vector condition classes catch. default, catches conditions.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/catch_cnd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Catch a condition — catch_cnd","text":"condition signalled, NULL otherwise.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/catch_cnd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Catch a condition — catch_cnd","text":"","code":"catch_cnd(10) #> NULL catch_cnd(abort(\"an error\")) #> <error/rlang_error> #> Error: #> ! an error #> --- #> Backtrace: #>      ▆ #>   1. └─pkgdown::build_site_github_pages(new_process = FALSE, install = FALSE) #>   2.   └─pkgdown::build_site(...) #>   3.     └─pkgdown:::build_site_local(...) #>   4.       └─pkgdown::build_reference(...) #>   5.         ├─pkgdown:::unwrap_purrr_error(...) #>   6.         │ └─base::withCallingHandlers(...) #>   7.         └─purrr::map(...) #>   8.           └─purrr:::map_(\"list\", .x, .f, ..., .progress = .progress) #>   9.             ├─purrr:::with_indexed_errors(...) #>  10.             │ └─base::withCallingHandlers(...) #>  11.             ├─purrr:::call_with_cleanup(...) #>  12.             └─pkgdown (local) .f(.x[[i]], ...) #>  13.               ├─base::withCallingHandlers(...) #>  14.               └─pkgdown:::data_reference_topic(...) #>  15.                 └─pkgdown:::run_examples(...) #>  16.                   └─pkgdown:::highlight_examples(code, topic, env = env) #>  17.                     └─downlit::evaluate_and_highlight(...) #>  18.                       └─evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #>  19.                         ├─base::withRestarts(...) #>  20.                         │ └─base (local) withRestartList(expr, restarts) #>  21.                         │   ├─base (local) withOneRestart(withRestartList(expr, restarts[-nr]), restarts[[nr]]) #>  22.                         │   │ └─base (local) doWithOneRestart(return(expr), restart) #>  23.                         │   └─base (local) withRestartList(expr, restarts[-nr]) #>  24.                         │     └─base (local) withOneRestart(expr, restarts[[1L]]) #>  25.                         │       └─base (local) doWithOneRestart(return(expr), restart) #>  26.                         ├─evaluate:::with_handlers(...) #>  27.                         │ ├─base::eval(call) #>  28.                         │ │ └─base::eval(call) #>  29.                         │ └─base::withCallingHandlers(...) #>  30.                         ├─base::withVisible(eval(expr, envir)) #>  31.                         └─base::eval(expr, envir) #>  32.                           └─base::eval(expr, envir) catch_cnd(signal(\"my_condition\", message = \"a condition\")) #> <my_condition: a condition>"},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_empty.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that dots are empty — check_dots_empty","title":"Check that dots are empty — check_dots_empty","text":"... can inserted function signature force users fully name details arguments. case, supplying data ... almost always programming error. function checks ... empty fails otherwise.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_empty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that dots are empty — check_dots_empty","text":"","code":"check_dots_empty(   env = caller_env(),   error = NULL,   call = caller_env(),   action = abort )"},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_empty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that dots are empty — check_dots_empty","text":"env Environment look .... error optional error handler passed try_fetch(). Use e.g. demote error warning. call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. action","code":""},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_empty.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check that dots are empty — check_dots_empty","text":"packages, document ... standard tag:","code":"@inheritParams rlang::args_dots_empty"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_empty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that dots are empty — check_dots_empty","text":"","code":"f <- function(x, ..., foofy = 8) {   check_dots_empty()   x + foofy }  # This fails because `foofy` can't be matched positionally try(f(1, 4)) #> Error in f(1, 4) : `...` must be empty. #> ✖ Problematic argument: #> • ..1 = 4 #> ℹ Did you forget to name an argument?  # This fails because `foofy` can't be matched partially by name try(f(1, foof = 4)) #> Error in f(1, foof = 4) : `...` must be empty. #> ✖ Problematic argument: #> • foof = 4  # Thanks to `...`, it must be matched exactly f(1, foofy = 4) #> [1] 5"},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_empty0.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that dots are empty (low level variant) — check_dots_empty0","title":"Check that dots are empty (low level variant) — check_dots_empty0","text":"check_dots_empty0() efficient version check_dots_empty() slightly different interface. Instead inspecting current environment dots, directly takes .... meant low level functions couple microseconds make difference.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_empty0.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that dots are empty (low level variant) — check_dots_empty0","text":"","code":"check_dots_empty0(..., call = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_empty0.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that dots are empty (low level variant) — check_dots_empty0","text":"... Dots empty.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_unnamed.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that all dots are unnamed — check_dots_unnamed","title":"Check that all dots are unnamed — check_dots_unnamed","text":"functions like paste(), named arguments ... often sign misspelled argument names. Call check_dots_unnamed() fail error named arguments detected.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_unnamed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that all dots are unnamed — check_dots_unnamed","text":"","code":"check_dots_unnamed(   env = caller_env(),   error = NULL,   call = caller_env(),   action = abort )"},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_unnamed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that all dots are unnamed — check_dots_unnamed","text":"env Environment look .... error optional error handler passed try_fetch(). Use e.g. demote error warning. call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. action","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_unnamed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that all dots are unnamed — check_dots_unnamed","text":"","code":"f <- function(..., foofy = 8) {   check_dots_unnamed()   c(...) }  f(1, 2, 3, foofy = 4) #> [1] 1 2 3  try(f(1, 2, 3, foof = 4)) #> Error in f(1, 2, 3, foof = 4) :  #>   Arguments in `...` must be passed by position, not name. #> ✖ Problematic argument: #> • foof = 4"},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_used.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that all dots have been used — check_dots_used","title":"Check that all dots have been used — check_dots_used","text":"... arguments passed method, method match use arguments. case, often indicates programming error. Call check_dots_used() fail error unused arguments detected.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_used.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that all dots have been used — check_dots_used","text":"","code":"check_dots_used(   env = caller_env(),   call = caller_env(),   error = NULL,   action = deprecated() )"},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_used.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that all dots have been used — check_dots_used","text":"env Environment look ... set handler. call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. error optional error handler passed try_fetch(). Use e.g. demote error warning. action","code":""},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_used.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check that all dots have been used — check_dots_used","text":"packages, document ... standard tag:   check_dots_used() implicitly calls .exit() check elements ... used function exits. use .exit() elsewhere function, make sure use add = TRUE override handler set check_dots_used().","code":"@inheritParams rlang::args_dots_used"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/check_dots_used.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that all dots have been used — check_dots_used","text":"","code":"f <- function(...) {   check_dots_used()   g(...) }  g <- function(x, y, ...) {   x + y } f(x = 1, y = 2) #> [1] 3  try(f(x = 1, y = 2, z = 3)) #> Error in f(x = 1, y = 2, z = 3) : Arguments in `...` must be used. #> ✖ Problematic argument: #> • z = 3 #> ℹ Did you misspell an argument name?  try(f(x = 1, y = 2, 3, 4, 5)) #> Error in f(x = 1, y = 2, 3, 4, 5) :  #>   Arguments in `...` must be used. #> ✖ Problematic arguments: #> • ..1 = 3 #> • ..2 = 4 #> • ..3 = 5 #> ℹ Did you misspell an argument name?  # Use an `error` handler to handle the error differently. # For instance to demote the error to a warning: fn <- function(...) {   check_dots_empty(     error = function(cnd) {       warning(cnd)     }   )   \"out\" } fn() #> [1] \"out\""},{"path":"https://rlang.r-lib.org/dev/reference/check_exclusive.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that arguments are mutually exclusive — check_exclusive","title":"Check that arguments are mutually exclusive — check_exclusive","text":"check_exclusive() checks one argument supplied set mutually exclusive arguments. informative error thrown multiple arguments supplied.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/check_exclusive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that arguments are mutually exclusive — check_exclusive","text":"","code":"check_exclusive(..., .require = TRUE, .frame = caller_env(), .call = .frame)"},{"path":"https://rlang.r-lib.org/dev/reference/check_exclusive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that arguments are mutually exclusive — check_exclusive","text":"... Function arguments. .require Whether least one argument must supplied. .frame Environment arguments ... defined. .call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/check_exclusive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check that arguments are mutually exclusive — check_exclusive","text":"supplied argument name string. .require FALSE argument supplied, empty string \"\" returned.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/check_exclusive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that arguments are mutually exclusive — check_exclusive","text":"","code":"f <- function(x, y) {   switch(     check_exclusive(x, y),     x = message(\"`x` was supplied.\"),     y = message(\"`y` was supplied.\")   ) }  # Supplying zero or multiple arguments is forbidden try(f()) #> Error in f() : One of `x` or `y` must be supplied. try(f(NULL, NULL)) #> Error in f(NULL, NULL) :  #>   Exactly one of `x` or `y` must be supplied.  # The user must supply one of the mutually exclusive arguments f(NULL) #> `x` was supplied. f(y = NULL) #> `y` was supplied.   # With `.require` you can allow zero arguments f <- function(x, y) {   switch(     check_exclusive(x, y, .require = FALSE),     x = message(\"`x` was supplied.\"),     y = message(\"`y` was supplied.\"),     message(\"No arguments were supplied\")   ) } f() #> No arguments were supplied"},{"path":"https://rlang.r-lib.org/dev/reference/check_required.html","id":null,"dir":"Reference","previous_headings":"","what":"Check that argument is supplied — check_required","title":"Check that argument is supplied — check_required","text":"Throws error x missing.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/check_required.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check that argument is supplied — check_required","text":"","code":"check_required(x, arg = caller_arg(x), call = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/check_required.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check that argument is supplied — check_required","text":"x function argument. Must symbol. arg argument name string. argument mentioned error messages input origin problem. call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/check_required.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check that argument is supplied — check_required","text":"","code":"f <- function(x)  {   check_required(x) }  # Fails because `x` is not supplied try(f()) #> Error in f() : `x` is absent but must be supplied.  # Succeeds f(NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/child_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a child environment — child_env","title":"Create a child environment — child_env","text":"env() now supports creating child environments, please use instead.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/child_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a child environment — child_env","text":"","code":"child_env(.parent, ...)"},{"path":"https://rlang.r-lib.org/dev/reference/chr_unserialise_unicode.html","id":null,"dir":"Reference","previous_headings":"","what":"Translate unicode points to UTF-8 — chr_unserialise_unicode","title":"Translate unicode points to UTF-8 — chr_unserialise_unicode","text":"historical reasons, R translates strings native encoding converted symbols. string--symbol conversion rare occurrence happens instance names list arguments converted call .call(). string contains unicode characters represented native encoding, R serialises ASCII sequence representing unicode point. Windows users western locales often see strings looking like <U+xxxx>. alleviate pain, rlang parses strings looks serialised unicode points translate back proper UTF-8 representation. transformation occurs automatically functions like env_names() can manually triggered as_utf8_character() chr_unserialise_unicode().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/chr_unserialise_unicode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translate unicode points to UTF-8 — chr_unserialise_unicode","text":"","code":"chr_unserialise_unicode(chr)"},{"path":"https://rlang.r-lib.org/dev/reference/chr_unserialise_unicode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translate unicode points to UTF-8 — chr_unserialise_unicode","text":"chr character vector.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/chr_unserialise_unicode.html","id":"life-cycle","dir":"Reference","previous_headings":"","what":"Life cycle","title":"Translate unicode points to UTF-8 — chr_unserialise_unicode","text":"function experimental.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/chr_unserialise_unicode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Translate unicode points to UTF-8 — chr_unserialise_unicode","text":"","code":"ascii <- \"<U+5E78>\" chr_unserialise_unicode(ascii) #> [1] \"幸\"  identical(chr_unserialise_unicode(ascii), \"\\u5e78\") #> [1] TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/cnd.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a condition object — cnd","title":"Create a condition object — cnd","text":"constructors create subclassed conditions, objects power error, warning, message system R. cnd() creates bare conditions inherit condition. Conditions created error_cnd(), warning_cnd(), message_cnd() inherit \"error\", \"warning\", \"message\". error_cnd() creates subclassed errors. See \"rlang_error\". Use cnd_signal() emit relevant signal particular condition class.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a condition object — cnd","text":"","code":"cnd(class, ..., message = \"\", call = NULL, use_cli_format = NULL)  error_cnd(   class = NULL,   ...,   message = \"\",   call = NULL,   trace = NULL,   parent = NULL,   use_cli_format = NULL )  warning_cnd(   class = NULL,   ...,   message = \"\",   call = NULL,   use_cli_format = NULL )  message_cnd(   class = NULL,   ...,   message = \"\",   call = NULL,   use_cli_format = NULL )"},{"path":"https://rlang.r-lib.org/dev/reference/cnd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a condition object — cnd","text":"class condition subclass. ... <dynamic> Named data fields stored inside condition object. message default message inform user condition signalled. call function call included error message. execution environment running function, corresponding function call retrieved. use_cli_format Whether use cli package format message. See local_use_cli(). trace trace object created trace_back(). parent parent condition object.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/cnd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a condition object — cnd","text":"","code":"# Create a condition inheriting only from the S3 class \"foo\": cnd <- cnd(\"foo\")  # Signal the condition to potential handlers. Since this is a bare # condition the signal has no effect if no handlers are set up: cnd_signal(cnd)  # When a relevant handler is set up, the signal transfers control # to the handler with_handlers(cnd_signal(cnd), foo = function(c) \"caught!\") #> Warning: `with_handlers()` is deprecated as of rlang 1.0.0. #> ℹ Please use `tryCatch()`, `withCallingHandlers()`, or `try_fetch()`. #> This warning is displayed once every 8 hours. #> [1] \"caught!\" tryCatch(cnd_signal(cnd), foo = function(c) \"caught!\") #> [1] \"caught!\""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_inherits.html","id":null,"dir":"Reference","previous_headings":"","what":"Does a condition or its ancestors inherit from a class? — cnd_inherits","title":"Does a condition or its ancestors inherit from a class? — cnd_inherits","text":"Like R objects, errors captured catchers like tryCatch() class() can test inherits().  However, chained errors, class captured error might different error originally signalled. Use cnd_inherits() detect whether error parent inherits class. Whereas inherits() tells whether object particular kind error, cnd_inherits() answers question whether object particular kind error caused error. chained conditions carry parents inherited. See .inherit argument abort(), warn(), inform().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_inherits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does a condition or its ancestors inherit from a class? — cnd_inherits","text":"","code":"cnd_inherits(cnd, class)"},{"path":"https://rlang.r-lib.org/dev/reference/cnd_inherits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does a condition or its ancestors inherit from a class? — cnd_inherits","text":"cnd condition test. class class passed inherits().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_inherits.html","id":"capture-an-error-with-cnd-inherits-","dir":"Reference","previous_headings":"","what":"Capture an error with cnd_inherits()","title":"Does a condition or its ancestors inherit from a class? — cnd_inherits","text":"Error catchers like tryCatch() try_fetch() can match class condition, class parents. match class across ancestry error, need bit craftiness. Ancestry matching done tryCatch() need switch withCallingHandlers(). Alternatively, can use experimental rlang function try_fetch() able perform roles tryCatch() withCallingHandlers().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_inherits.html","id":"withcallinghandlers-","dir":"Reference","previous_headings":"","what":"withCallingHandlers()","title":"Does a condition or its ancestors inherit from a class? — cnd_inherits","text":"Unlike tryCatch(), withCallingHandlers() capture error. explicitly jump error value throw, nothing happens. Since want throw error, throw value using callCC():","code":"f <- function() {   parent <- error_cnd(\"bar\", message = \"Bar\")   abort(\"Foo\", parent = parent) }  cnd <- callCC(function(throw) {   withCallingHandlers(     f(),     error = function(x) if (cnd_inherits(x, \"bar\")) throw(x)   ) })  class(cnd) #> [1] \"rlang_error\" \"error\"       \"condition\" class(cnd$parent) #> [1] \"bar\"         \"rlang_error\" \"error\"       \"condition\""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_inherits.html","id":"try-fetch-","dir":"Reference","previous_headings":"","what":"try_fetch()","title":"Does a condition or its ancestors inherit from a class? — cnd_inherits","text":"pattern easier try_fetch(). Like withCallingHandlers(), capture matching error right away. Instead, captures handler return zap() value.   Note try_fetch() uses cnd_inherits() internally. makes easy match parent condition:","code":"cnd <- try_fetch(   f(),   error = function(x) if (cnd_inherits(x, \"bar\")) x else zap() )  class(cnd) #> [1] \"rlang_error\" \"error\"       \"condition\" class(cnd$parent) #> [1] \"bar\"         \"rlang_error\" \"error\"       \"condition\" cnd <- try_fetch(   f(),   bar = function(x) x )  # This is the parent class(cnd) #> [1] \"bar\"         \"rlang_error\" \"error\"       \"condition\""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_message.html","id":null,"dir":"Reference","previous_headings":"","what":"Build an error message from parts — cnd_message","title":"Build an error message from parts — cnd_message","text":"cnd_message() assembles error message three generics: cnd_header() cnd_body() cnd_footer() Methods generics must return character vector. elements combined single string newline separator. Bullets syntax supported, either rlang (see format_error_bullets()), cli condition use_cli_format set TRUE. default method error header returns message field condition object. default methods body footer return body footer fields , empty character vectors otherwise. cnd_message() automatically called conditionMessage() rlang errors, warnings, messages. Error classes created abort() need implement header, body footer methods. provides lot flexibility hierarchies error classes, instance inherit body error message parent class overriding header footer.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_message.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build an error message from parts — cnd_message","text":"","code":"cnd_message(cnd, ..., inherit = TRUE, prefix = FALSE)  cnd_header(cnd, ...)  cnd_body(cnd, ...)  cnd_footer(cnd, ...)"},{"path":"https://rlang.r-lib.org/dev/reference/cnd_message.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build an error message from parts — cnd_message","text":"cnd condition object. ... Arguments passed methods. inherit Wether include parent messages. Parent messages printed \"Caused error:\" prefix, even prefix FALSE. prefix Whether print full message, including condition prefix (Error:, Warning:, Message:, Condition:). prefix mentions call field present, srcref info present. cnd parent field (.e. condition chained), parent messages included message Caused prefix.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_message.html","id":"overriding-header-body-and-footer-methods","dir":"Reference","previous_headings":"","what":"Overriding header, body, and footer methods","title":"Build an error message from parts — cnd_message","text":"Sometimes contents error message depends state checking routine. case, can tricky lazily generate error messages cnd_header(), cnd_body(), cnd_footer(): choice overspecifying error class hierarchies one class per state, replicating type-checking control flow within cnd_body() method. None options ideal. better option define header, body, footer fields condition object. can static string, lambda-formula, function signature cnd_header(), cnd_body(), cnd_footer(). fields override message generics make easy generate error message tailored state error constructed.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_muffle.html","id":null,"dir":"Reference","previous_headings":"","what":"Muffle a condition — cnd_muffle","title":"Muffle a condition — cnd_muffle","text":"Unlike exiting() handlers, calling() handlers must explicit handled condition stop propagating handlers. Use cnd_muffle() within calling handler (calling handler, see examples) prevent handlers called condition.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_muffle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Muffle a condition — cnd_muffle","text":"","code":"cnd_muffle(cnd)"},{"path":"https://rlang.r-lib.org/dev/reference/cnd_muffle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Muffle a condition — cnd_muffle","text":"cnd condition muffle.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_muffle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Muffle a condition — cnd_muffle","text":"cnd mufflable, cnd_muffle() jumps muffle restart return. Otherwise, returns FALSE.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_muffle.html","id":"mufflable-conditions","dir":"Reference","previous_headings":"","what":"Mufflable conditions","title":"Muffle a condition — cnd_muffle","text":"conditions signalled base R muffable, although name restart varies. cnd_muffle() automatically call correct restart . compatible following conditions: warning message conditions. case cnd_muffle() equivalent base::suppressMessages() base::suppressWarnings(). Bare conditions signalled signal() cnd_signal(). Note conditions signalled base::signalCondition() mufflable. Interrupts sometimes signalled resume restart recent R versions. case, can muffle interrupt cnd_muffle(). Check restart available base::findRestart(\"resume\"). call cnd_muffle() condition mufflable cause new error signalled. Errors mufflable since signalled critical situations execution continue safely. Conditions captured base::tryCatch(), with_handlers() catch_cnd() longer mufflable. Muffling restarts must called calling handler.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_muffle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Muffle a condition — cnd_muffle","text":"","code":"fn <- function() {   inform(\"Beware!\", \"my_particular_msg\")   inform(\"On your guard!\")   \"foobar\" }  # Let's install a muffling handler for the condition thrown by `fn()`. # This will suppress all `my_particular_wng` warnings but let other # types of warnings go through: with_handlers(fn(),   my_particular_msg = calling(function(cnd) {     inform(\"Dealt with this particular message\")     cnd_muffle(cnd)   }) ) #> Warning: `calling()` is deprecated as of rlang 1.0.0. #> This warning is displayed once every 8 hours. #> Dealt with this particular message #> On your guard! #> [1] \"foobar\"  # Note how execution of `fn()` continued normally after dealing # with that particular message.  # cnd_muffle() can also be passed to with_handlers() as a calling # handler: with_handlers(fn(),   my_particular_msg = calling(cnd_muffle) ) #> On your guard! #> [1] \"foobar\""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_signal.html","id":null,"dir":"Reference","previous_headings":"","what":"Signal a condition object — cnd_signal","title":"Signal a condition object — cnd_signal","text":"cnd_signal() takes condition argument emits corresponding signal. type signal depends class condition: message signalled condition inherits \"message\". equivalent signalling inform() base::message(). warning signalled condition inherits \"warning\". equivalent signalling warn() base::warning(). error signalled condition inherits \"error\". equivalent signalling abort() base::stop(). interrupt signalled condition inherits \"interrupt\". equivalent signalling interrupt().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_signal.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Signal a condition object — cnd_signal","text":"","code":"cnd_signal(cnd, ...)"},{"path":"https://rlang.r-lib.org/dev/reference/cnd_signal.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Signal a condition object — cnd_signal","text":"cnd condition object (see cnd()). NULL, cnd_signal() returns without signalling condition. ... dots future extensions must empty.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/cnd_signal.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Signal a condition object — cnd_signal","text":"","code":"# The type of signal depends on the class. If the condition # inherits from \"warning\", a warning is issued: cnd <- warning_cnd(\"my_warning_class\", message = \"This is a warning\") cnd_signal(cnd) #> Warning: This is a warning  # If it inherits from \"error\", an error is raised: cnd <- error_cnd(\"my_error_class\", message = \"This is an error\") try(cnd_signal(cnd)) #> Error : This is an error"},{"path":"https://rlang.r-lib.org/dev/reference/cnd_type.html","id":null,"dir":"Reference","previous_headings":"","what":"What type is a condition? — cnd_type","title":"What type is a condition? — cnd_type","text":"Use cnd_type() check type condition .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"What type is a condition? — cnd_type","text":"","code":"cnd_type(cnd)"},{"path":"https://rlang.r-lib.org/dev/reference/cnd_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"What type is a condition? — cnd_type","text":"cnd condition object.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"What type is a condition? — cnd_type","text":"string, either \"condition\", \"message\", \"warning\", \"error\" \"interrupt\".","code":""},{"path":"https://rlang.r-lib.org/dev/reference/cnd_type.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"What type is a condition? — cnd_type","text":"","code":"cnd_type(catch_cnd(abort(\"Abort!\"))) #> [1] \"error\" cnd_type(catch_cnd(interrupt())) #> [1] \"interrupt\""},{"path":"https://rlang.r-lib.org/dev/reference/defusing-advanced.html","id":null,"dir":"Reference","previous_headings":"","what":"Advanced defusal operators — defusing-advanced","title":"Advanced defusal operators — defusing-advanced","text":"advanced operators defuse R expressions. expr(), enquo(), enquos() sufficient purposes rlang provides operations, either completeness useful experts. exprs() plural variant expr(). returns list expressions. like base::alist() injection support. quo() quos() like expr() exprs() return quosures instead naked expressions. defusing local expressions (opposition function arguments non-local expressions supplied users), generally need attach current environment quosure. See quosures needed?. enexpr() enexprs() like enquo() enquos() return naked expressions instead quosures. operators rarely used lose track environment defused arguments. ensym() ensyms() like enexpr() enexprs() throw error defused expressions simple symbols. also support strings interpreted symbols. functions modelled behaviour left-hand side = <- can supply symbols strings interchangeably.   enquo0 enquos0() like enquo() enquos() without injection support. injection operators !!, !!!, {{ processed, instead preserved defused expression. makes possible defuse expressions potentially contain injection operators meant later use. trade makes harder users inject expressions function. enable injection explicitly inject(). None features dynamic dots available defusing enquos0(). instance, trailing empty arguments automatically trimmed.","code":"\"foo\" <- NULL list(\"foo\" = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/defusing-advanced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Advanced defusal operators — defusing-advanced","text":"","code":"enexpr(arg)  exprs(   ...,   .named = FALSE,   .ignore_empty = c(\"trailing\", \"none\", \"all\"),   .unquote_names = TRUE )  enexprs(   ...,   .named = FALSE,   .ignore_empty = c(\"trailing\", \"none\", \"all\"),   .ignore_null = c(\"none\", \"all\"),   .unquote_names = TRUE,   .homonyms = c(\"keep\", \"first\", \"last\", \"error\"),   .check_assign = FALSE )  ensym(arg)  ensyms(   ...,   .named = FALSE,   .ignore_empty = c(\"trailing\", \"none\", \"all\"),   .ignore_null = c(\"none\", \"all\"),   .unquote_names = TRUE,   .homonyms = c(\"keep\", \"first\", \"last\", \"error\"),   .check_assign = FALSE )  quo(expr)  quos(   ...,   .named = FALSE,   .ignore_empty = c(\"trailing\", \"none\", \"all\"),   .unquote_names = TRUE )  enquo0(arg)  enquos0(...)"},{"path":"https://rlang.r-lib.org/dev/reference/defusing-advanced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Advanced defusal operators — defusing-advanced","text":"arg unquoted argument name. expression supplied argument defused returned. ... enexprs(), ensyms() enquos(), names arguments defuse. exprs() quos(), expressions defuse. .named TRUE, unnamed inputs automatically named as_label(). equivalent applying exprs_auto_name() result. FALSE, unnamed elements left , fully unnamed, list given minimal names (vector \"\"). NULL, fully unnamed results left NULL names. .ignore_empty Whether ignore empty arguments. Can one \"trailing\", \"none\", \"\". \"trailing\", last argument ignored empty. Named arguments considered empty. .unquote_names Whether treat := =. Unlike =, := syntax supports names injection. .ignore_null Whether ignore unnamed null arguments. Can \"none\" \"\". .homonyms treat arguments name. default, \"keep\", preserves arguments. Set .homonyms \"first\" keep first occurrences, \"last\" keep last occurrences, \"error\" raise informative error indicate arguments duplicated names. .check_assign Whether check <- calls. TRUE warning recommends users use = meant match function parameter wrap <- call curly braces otherwise. ensures assignments explicit. expr expression defuse.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/defusing-advanced.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Advanced defusal operators — defusing-advanced","text":"","code":"# `exprs()` is the plural variant of `expr()` exprs(foo, bar, bar) #> [[1]] #> foo #>  #> [[2]] #> bar #>  #> [[3]] #> bar #>   # `quo()` and `quos()` are the quosure variants of `expr()` and `exprs()` quo(foo) #> <quosure> #> expr: ^foo #> env:  0x562dd817b6c8 quos(foo, bar) #> <list_of<quosure>> #>  #> [[1]] #> <quosure> #> expr: ^foo #> env:  0x562dd817b6c8 #>  #> [[2]] #> <quosure> #> expr: ^bar #> env:  0x562dd817b6c8 #>   # `enexpr()` and `enexprs()` are the naked variants of `enquo()` and `enquos()` my_function1 <- function(arg) enexpr(arg) my_function2 <- function(arg, ...) enexprs(arg, ...) my_function1(1 + 1) #> 1 + 1 my_function2(1 + 1, 10 * 2) #> [[1]] #> 1 + 1 #>  #> [[2]] #> 10 * 2 #>    # `ensym()` and `ensyms()` are symbol variants of `enexpr()` and `enexprs()` my_function3 <- function(arg) ensym(arg) my_function4 <- function(arg, ...) ensyms(arg, ...)  # The user must supply symbols my_function3(foo) #> foo my_function4(foo, bar) #> [[1]] #> foo #>  #> [[2]] #> bar #>   # Complex expressions are an error try(my_function3(1 + 1)) #> Error in ensym(arg) : Can't convert to a symbol. try(my_function4(1 + 1, 10 * 2)) #> Error in sym(expr) : Can't convert a call to a symbol.   # `enquo0()` and `enquos0()` disable injection operators automatic_injection <- function(x) enquo(x) no_injection <- function(x) enquo0(x)  automatic_injection(foo(!!!1:3)) #> <quosure> #> expr: ^foo(1L, 2L, 3L) #> env:  0x562dd817b6c8 no_injection(foo(!!!1:3)) #> <quosure> #> expr: ^foo(!!!1:3) #> env:  0x562dd817b6c8  # Injection can still be done explicitly inject(no_injection(foo(!!!1:3))) #> <quosure> #> expr: ^foo(1L, 2L, 3L) #> env:  0x562dd817b6c8"},{"path":"https://rlang.r-lib.org/dev/reference/dev-notes-dots.html","id":null,"dir":"Reference","previous_headings":"","what":"Development notes - dots.R — dev-notes-dots","title":"Development notes - dots.R — dev-notes-dots","text":"Development notes - dots.R","code":""},{"path":"https://rlang.r-lib.org/dev/reference/dev-notes-dots.html","id":"-error-call-flag-in-dots-collectors","dir":"Reference","previous_headings":"","what":".__error_call__. flag in dots collectors","title":"Development notes - dots.R — dev-notes-dots","text":"Dots collectors like dots_list() little tricky may error different situations. want forward context, .e. set call flag calling environment? Collectors throw errors cases: checking parameters, case relevant context collector forward. collecting dots, evaluation supplied arguments. case forwarding irrelevant expressions ... evaluated environment connected collector's context. collecting dots, argument constraints checks determined .homonyms argument. case want forward context caller dots collector one determines constraints users.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/done.html","id":null,"dir":"Reference","previous_headings":"","what":"Box a final value for early termination — done","title":"Box a final value for early termination — done","text":"value boxed done() signals caller stop iterating. Use shortcircuit loop.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/done.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Box a final value for early termination — done","text":"","code":"done(x)  is_done_box(x, empty = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/done.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Box a final value for early termination — done","text":"x done(), value box. is_done_box(), value test. empty Whether box empty. NULL, is_done_box() returns TRUE done boxes. TRUE, returns TRUE empty boxes. Otherwise returns TRUE non-empty boxes.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/done.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Box a final value for early termination — done","text":"boxed value.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/done.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Box a final value for early termination — done","text":"","code":"done(3) #> <done> #> [1] 3  x <- done(3) is_done_box(x) #> [1] TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/dot-data.html","id":null,"dir":"Reference","previous_headings":"","what":".data and .env pronouns — dot-data","title":".data and .env pronouns — dot-data","text":".data .env pronouns make explicit find objects programming data-masked functions.   .data retrieves data-variables data frame. .env retrieves env-variables environment. lookup explicit, ambiguity kinds variables. Compare:   Note .data pronoun, real data frame. means take names map function contents .data. Similarly, .env actual R environment. instance, parent subsetting operators behave differently.","code":"m <- 10 mtcars %>% mutate(disp = .data$disp * .env$m) disp <- 10 mtcars %>% mutate(disp = .data$disp * .env$disp) mtcars %>% mutate(disp = disp * disp)"},{"path":"https://rlang.r-lib.org/dev/reference/dot-data.html","id":"-data-versus-the-magrittr-pronoun-","dir":"Reference","previous_headings":"","what":".data versus the magrittr pronoun .","title":".data and .env pronouns — dot-data","text":"magrittr pipeline, .data necessarily interchangeable magrittr pronoun .. grouped data frames particular, .data represents current group slice whereas pronoun . represents whole data frame. Always prefer using .data data-masked context.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/dot-data.html","id":"where-does-data-live-","dir":"Reference","previous_headings":"","what":"Where does .data live?","title":".data and .env pronouns — dot-data","text":".data pronoun automatically created data-masking functions using tidy eval framework. need import rlang::.data use library(rlang) work pronoun. However, .data object exported rlang useful import package namespace avoid R CMD check note referring objects data mask. R way knowing presence absence .data particular scope need import explicitly equivalently declare utils::globalVariables(\".data\"). Note rlang::.data \"fake\" pronoun. refer rlang::.data rlang:: qualifier data masking code. Use unqualified .data symbol automatically put scope data-masking functions.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/dots_n.html","id":null,"dir":"Reference","previous_headings":"","what":"How many arguments are currently forwarded in dots? — dots_n","title":"How many arguments are currently forwarded in dots? — dots_n","text":"returns number arguments currently forwarded ... integer.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/dots_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"How many arguments are currently forwarded in dots? — dots_n","text":"","code":"dots_n(...)"},{"path":"https://rlang.r-lib.org/dev/reference/dots_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"How many arguments are currently forwarded in dots? — dots_n","text":"... Forwarded arguments.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/dots_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"How many arguments are currently forwarded in dots? — dots_n","text":"","code":"fn <- function(...) dots_n(..., baz) fn(foo, bar) #> [1] 3"},{"path":"https://rlang.r-lib.org/dev/reference/dots_splice.html","id":null,"dir":"Reference","previous_headings":"","what":"Splice lists — dots_splice","title":"Splice lists — dots_splice","text":"dots_splice() like dots_list() automatically splices list inputs.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/dots_splice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Splice lists — dots_splice","text":"","code":"dots_splice(   ...,   .ignore_empty = c(\"trailing\", \"none\", \"all\"),   .preserve_empty = FALSE,   .homonyms = c(\"keep\", \"first\", \"last\", \"error\"),   .check_assign = FALSE )"},{"path":"https://rlang.r-lib.org/dev/reference/dots_splice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Splice lists — dots_splice","text":"... Arguments collect list. dots dynamic. .ignore_empty Whether ignore empty arguments. Can one \"trailing\", \"none\", \"\". \"trailing\", last argument ignored empty. .preserve_empty Whether preserve empty arguments ignored. TRUE, empty arguments stored missing_arg() values. FALSE (default) error thrown empty argument detected. .homonyms treat arguments name. default, \"keep\", preserves arguments. Set .homonyms \"first\" keep first occurrences, \"last\" keep last occurrences, \"error\" raise informative error indicate arguments duplicated names. .check_assign Whether check <- calls. TRUE warning recommends users use = meant match function parameter wrap <- call curly braces otherwise. ensures assignments explicit.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/dots_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate dots with preliminary splicing — dots_values","title":"Evaluate dots with preliminary splicing — dots_values","text":"tool advanced users. captures dots, processes unquoting splicing operators, evaluates . Unlike dots_list(), flatten spliced objects, instead attributed spliced class (see splice()). can process spliced objects manually, perhaps custom predicate (see flatten_if()).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/dots_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate dots with preliminary splicing — dots_values","text":"","code":"dots_values(   ...,   .ignore_empty = c(\"trailing\", \"none\", \"all\"),   .preserve_empty = FALSE,   .homonyms = c(\"keep\", \"first\", \"last\", \"error\"),   .check_assign = FALSE )"},{"path":"https://rlang.r-lib.org/dev/reference/dots_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate dots with preliminary splicing — dots_values","text":"... Arguments evaluate process splicing operators. .ignore_empty Whether ignore empty arguments. Can one \"trailing\", \"none\", \"\". \"trailing\", last argument ignored empty. .preserve_empty Whether preserve empty arguments ignored. TRUE, empty arguments stored missing_arg() values. FALSE (default) error thrown empty argument detected. .homonyms treat arguments name. default, \"keep\", preserves arguments. Set .homonyms \"first\" keep first occurrences, \"last\" keep last occurrences, \"error\" raise informative error indicate arguments duplicated names. .check_assign Whether check <- calls. TRUE warning recommends users use = meant match function parameter wrap <- call curly braces otherwise. ensures assignments explicit.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/dots_values.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate dots with preliminary splicing — dots_values","text":"","code":"dots <- dots_values(!!! list(1, 2), 3) dots #> [[1]] #> <spliced> #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #>  #> [[2]] #> [1] 3 #>   # Flatten the objects marked as spliced: flatten_if(dots, is_spliced) #> Warning: `flatten_if()` is deprecated as of rlang 1.1.0. #> This warning is displayed once every 8 hours. #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>"},{"path":"https://rlang.r-lib.org/dev/reference/duplicate.html","id":null,"dir":"Reference","previous_headings":"","what":"Duplicate an R object — duplicate","title":"Duplicate an R object — duplicate","text":"duplicate() interface C-level duplicate() shallow_duplicate() functions. mostly meant users C API R, e.g. debugging, experimenting, prototyping C code R.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/duplicate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Duplicate an R object — duplicate","text":"","code":"duplicate(x, shallow = FALSE)"},{"path":"https://rlang.r-lib.org/dev/reference/duplicate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Duplicate an R object — duplicate","text":"x R object. Uncopyable objects like symbols environments returned (just like <-). shallow Recursive data structures like lists, calls pairlists duplicated full default. shallow copy duplicates top-level data structure.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/dyn-dots.html","id":null,"dir":"Reference","previous_headings":"","what":"Dynamic dots features — dyn-dots","title":"Dynamic dots features — dyn-dots","text":"base ... syntax supports: Forwarding arguments function function, matching along way arguments. Collecting arguments inside data structures, e.g. c() list(). Dynamic dots offer additional features, injection particular: can splice arguments saved list splice operator !!!. can inject names glue syntax left-hand side :=. Trailing commas ignored, making easier copy paste lines arguments.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/dyn-dots.html","id":"add-dynamic-dots-support-in-your-functions","dir":"Reference","previous_headings":"","what":"Add dynamic dots support in your functions","title":"Dynamic dots features — dyn-dots","text":"function takes dots, adding support dynamic features easy collecting dots list2() instead list(). See also dots_list(), offers control collection. general, passing ... function supports dynamic dots causes function inherit dynamic behaviour. packages, document dynamic dots standard tag:","code":"@param ... <[`dynamic-dots`][rlang::dyn-dots]> What these dots do."},{"path":"https://rlang.r-lib.org/dev/reference/dyn-dots.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dynamic dots features — dyn-dots","text":"","code":"f <- function(...) {   out <- list2(...)   rev(out) }  # Trailing commas are ignored f(this = \"that\", ) #> $this #> [1] \"that\" #>   # Splice lists of arguments with `!!!` x <- list(alpha = \"first\", omega = \"last\") f(!!!x) #> $omega #> [1] \"last\" #>  #> $alpha #> [1] \"first\" #>   # Inject a name using glue syntax if (is_installed(\"glue\")) {   nm <- \"key\"   f(\"{nm}\" := \"value\")   f(\"prefix_{nm}\" := \"value\") } #> $prefix_key #> [1] \"value\" #>"},{"path":"https://rlang.r-lib.org/dev/reference/embrace-operator.html","id":null,"dir":"Reference","previous_headings":"","what":"Embrace operator {{ — embrace-operator","title":"Embrace operator {{ — embrace-operator","text":"embrace operator {{ used create functions call data-masking functions. transports data-masked argument (argument can refer columns data frame) one function another.","code":"my_mean <- function(data, var) {   dplyr::summarise(data, mean = mean({{ var }})) }"},{"path":"https://rlang.r-lib.org/dev/reference/embrace-operator.html","id":"under-the-hood","dir":"Reference","previous_headings":"","what":"Under the hood","title":"Embrace operator {{ — embrace-operator","text":"{{ combines enquo() !! one step. snippet equivalent :","code":"my_mean <- function(data, var) {   var <- enquo(var)   dplyr::summarise(data, mean = mean(!!var)) }"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/empty_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the empty environment — empty_env","title":"Get the empty environment — empty_env","text":"empty environment one parent. always used tail environment chain search path (see search_envs()).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/empty_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the empty environment — empty_env","text":"","code":"empty_env()"},{"path":"https://rlang.r-lib.org/dev/reference/empty_env.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the empty environment — empty_env","text":"","code":"# Create environments with nothing in scope: child_env(empty_env()) #> <environment: 0x562dd58c3478>"},{"path":"https://rlang.r-lib.org/dev/reference/englue.html","id":null,"dir":"Reference","previous_headings":"","what":"Defuse function arguments with glue — englue","title":"Defuse function arguments with glue — englue","text":"englue() creates string glue operators { {{. operators normally used inject names within dynamic dots. englue() makes available anywhere within function. englue() must used inside function. englue(\"{{ var }}\") defuses argument var transforms string using default name operation.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/englue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defuse function arguments with glue — englue","text":"","code":"englue(x, env = caller_env(), error_call = current_env(), error_arg = \"x\")"},{"path":"https://rlang.r-lib.org/dev/reference/englue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Defuse function arguments with glue — englue","text":"x string interpolate glue operators. env User environment interpolation data lives case wrapping englue() another function. error_call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information. error_arg argument name string. argument mentioned error messages input origin problem.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/englue.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Defuse function arguments with glue — englue","text":"englue(\"{{ var }}\") equivalent as_label(enquo(var)). defuses arg transforms expression string as_label(). dynamic dots, using { allowed. englue() must use {{ least . Use glue::glue() simple interpolation. using englue() package, first ensure glue installed adding Imports: section.","code":"usethis::use_package(\"glue\", \"Imports\")"},{"path":"https://rlang.r-lib.org/dev/reference/englue.html","id":"wrapping-englue-","dir":"Reference","previous_headings":"","what":"Wrapping englue()","title":"Defuse function arguments with glue — englue","text":"can provide englue semantics user provided string supplying env. example create variant englue() supports special .qux pronoun : Creating environment masked_env inherits user env, one data lives. Overriding error_arg error_call arguments point argument name call environment. pattern slightly different usual error context passing englue() backend function uses error context default (checking function uses error context default).   creating low level package top englue(), also consider exposing env, error_arg error_call englue() wrapper users can wrap wrapper.","code":"my_englue <- function(text) {   masked_env <- env(caller_env(), .qux = \"QUX\")    englue(     text,     env = masked_env,     error_arg = \"text\",     error_call = current_env()   ) }  # Users can then use your wrapper as they would use `englue()`: fn <- function(x) {   foo <- \"FOO\"   my_englue(\"{{ x }}_{.qux}_{foo}\") }  fn(bar) #> [1] \"bar_QUX_FOO\""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/englue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Defuse function arguments with glue — englue","text":"","code":"g <- function(var) englue(\"{{ var }}\") g(cyl) #> [1] \"cyl\" g(1 + 1) #> [1] \"1 + 1\" g(!!letters) #> [1] \"<chr>\"  # These are equivalent to as_label(quote(cyl)) #> [1] \"cyl\" as_label(quote(1 + 1)) #> [1] \"1 + 1\" as_label(letters) #> [1] \"<chr>\""},{"path":"https://rlang.r-lib.org/dev/reference/enquo.html","id":null,"dir":"Reference","previous_headings":"","what":"Defuse function arguments — enquo","title":"Defuse function arguments — enquo","text":"enquo() enquos() defuse function arguments. defused expression can examined, modified, injected expressions. Defusing function arguments useful : Creating data-masking functions. Interfacing another data-masking function using defuse--inject pattern. advanced tools. Make sure first learn embrace operator {{ Data mask programming patterns. {{ easier work less theory, sufficient applications.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/enquo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Defuse function arguments — enquo","text":"","code":"enquo(arg)  enquos(   ...,   .named = FALSE,   .ignore_empty = c(\"trailing\", \"none\", \"all\"),   .ignore_null = c(\"none\", \"all\"),   .unquote_names = TRUE,   .homonyms = c(\"keep\", \"first\", \"last\", \"error\"),   .check_assign = FALSE )"},{"path":"https://rlang.r-lib.org/dev/reference/enquo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Defuse function arguments — enquo","text":"arg unquoted argument name. expression supplied argument defused returned. ... Names arguments defuse. .named TRUE, unnamed inputs automatically named as_label(). equivalent applying exprs_auto_name() result. FALSE, unnamed elements left , fully unnamed, list given minimal names (vector \"\"). NULL, fully unnamed results left NULL names. .ignore_empty Whether ignore empty arguments. Can one \"trailing\", \"none\", \"\". \"trailing\", last argument ignored empty. Named arguments considered empty. .ignore_null Whether ignore unnamed null arguments. Can \"none\" \"\". .unquote_names Whether treat := =. Unlike =, := syntax supports names injection. .homonyms treat arguments name. default, \"keep\", preserves arguments. Set .homonyms \"first\" keep first occurrences, \"last\" keep last occurrences, \"error\" raise informative error indicate arguments duplicated names. .check_assign Whether check <- calls. TRUE warning recommends users use = meant match function parameter wrap <- call curly braces otherwise. ensures assignments explicit.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/enquo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Defuse function arguments — enquo","text":"enquo() returns quosure enquos() returns list quosures.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/enquo.html","id":"implicit-injection","dir":"Reference","previous_headings":"","what":"Implicit injection","title":"Defuse function arguments — enquo","text":"Arguments defused enquo() enquos() automatically gain injection support.   See enquo0() enquos0() variants enable injection.","code":"my_mean <- function(data, var) {   var <- enquo(var)   dplyr::summarise(data, mean(!!var)) }  # Can now use `!!` and `{{` my_mean(mtcars, !!sym(\"cyl\"))"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/enquo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Defuse function arguments — enquo","text":"","code":"# `enquo()` defuses the expression supplied by your user f <- function(arg) {   enquo(arg) }  f(1 + 1) #> <quosure> #> expr: ^1 + 1 #> env:  0x562ddd882610  # `enquos()` works with arguments and dots. It returns a list of # expressions f <- function(...) {   enquos(...) }  f(1 + 1, 2 * 10) #> <list_of<quosure>> #>  #> [[1]] #> <quosure> #> expr: ^1 + 1 #> env:  0x562ddd882610 #>  #> [[2]] #> <quosure> #> expr: ^2 * 10 #> env:  0x562ddd882610 #>    # `enquo()` and `enquos()` enable _injection_ and _embracing_ for # your users g <- function(arg) {   f({{ arg }} * 2) } g(100) #> <list_of<quosure>> #>  #> [[1]] #> <quosure> #> expr: ^(^100) * 2 #> env:  0x562ddab846f0 #>   column <- sym(\"cyl\") g(!!column) #> <list_of<quosure>> #>  #> [[1]] #> <quosure> #> expr: ^(^cyl) * 2 #> env:  0x562dda712db8 #>"},{"path":"https://rlang.r-lib.org/dev/reference/entrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Add backtrace from error handler — entrace","title":"Add backtrace from error handler — entrace","text":"entrace() low level function. See global_entrace() user-friendly way enriching errors conditions RProfile. entrace() meant used global handler. enriches conditions backtrace. Errors saved last_error() rethrown immediately. Messages warnings recorded last_messages() last_warnings() let . cnd_entrace() adds backtrace condition object, without effect. called condition handler. entrace() also works option(error = ) handler compatibility versions R older 4.0. used calling handler, rlang trims handler invokation context backtrace.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/entrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add backtrace from error handler — entrace","text":"","code":"entrace(cnd, ..., top = NULL, bottom = NULL)  cnd_entrace(cnd, ..., top = NULL, bottom = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/entrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add backtrace from error handler — entrace","text":"cnd entrace() used calling handler, cnd condition handle. ... Unused. dots future extensions. top first frame environment included backtrace. becomes top backtrace tree represents oldest call backtrace. needed particular call trace_back() indirectly larger context, example tests inside RMarkdown document want knitr evaluation mechanisms appear backtrace. supplied, rlang_trace_top_env global option consulted. makes possible trim embedding context backtraces created option set. knitr progress, default value option knitr::knit_global() knitr context trimmed backtraces. bottom last frame environment included backtrace. becomes rightmost leaf backtrace tree represents youngest call backtrace. Set like capture backtrace without capture context. Can also integer passed caller_env().","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/entrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add backtrace from error handler — entrace","text":"","code":"quote({  # Not run  # Set `entrace()` globally in your RProfile globalCallingHandlers(error = rlang::entrace)  # On older R versions which don't feature `globalCallingHandlers`, # set the error handler like this: options(error = rlang::entrace)  }) #> { #>     globalCallingHandlers(error = rlang::entrace) #>     options(error = rlang::entrace) #> }"},{"path":"https://rlang.r-lib.org/dev/reference/env.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new environment — env","title":"Create a new environment — env","text":"functions create new environments. env() creates child current environment default takes variable number named objects populate . new_environment() creates child empty environment default takes named list objects populate .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new environment — env","text":"","code":"env(...)  new_environment(data = list(), parent = empty_env())"},{"path":"https://rlang.r-lib.org/dev/reference/env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new environment — env","text":"..., data <dynamic> Named values. can supply one unnamed specify custom parent, otherwise defaults current environment. parent parent environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env.html","id":"environments-as-objects","dir":"Reference","previous_headings":"","what":"Environments as objects","title":"Create a new environment — env","text":"Environments containers uniquely named objects. common use provide scope evaluation R expressions. languages first class environments, .e. can manipulate scope regular objects. Reification scope one powerful features R allows change objects function expression sees evaluated. Environments also constitute data structure right. collection uniquely named objects, subsettable name modifiable reference. latter property (see section reference semantics) especially useful creating mutable OO systems (cf R6 package ggproto system extending ggplot2).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env.html","id":"inheritance","dir":"Reference","previous_headings":"","what":"Inheritance","title":"Create a new environment — env","text":"R environments (except empty environment) defined parent environment. environment grandparents thus form linear hierarchy basis lexical scoping R. R evaluates expression, looks symbols given environment. find symbols , keeps looking parent environments. way, objects defined child environments precedence objects defined parent environments. ability overriding specific definitions used tidyeval framework create powerful domain-specific grammars. common use masking put data frame columns scope. See example as_data_mask().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env.html","id":"reference-semantics","dir":"Reference","previous_headings":"","what":"Reference semantics","title":"Create a new environment — env","text":"Unlike regular objects vectors, environments uncopyable object type. means multiple references given environment (assigning environment another symbol <- passing environment argument function), modifying bindings one references changes references well.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/env.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a new environment — env","text":"","code":"# env() creates a new environment that inherits from the current # environment by default env <- env(a = 1, b = \"foo\") env$b #> [1] \"foo\" identical(env_parent(env), current_env()) #> [1] TRUE  # Supply one unnamed argument to inherit from another environment: env <- env(base_env(), a = 1, b = \"foo\") identical(env_parent(env), base_env()) #> [1] TRUE   # Both env() and child_env() support tidy dots features: objs <- list(b = \"foo\", c = \"bar\") env <- env(a = 1, !!! objs) env$c #> [1] \"bar\"  # You can also unquote names with the definition operator `:=` var <- \"a\" env <- env(!!var := \"A\") env$a #> [1] \"A\"   # Use new_environment() to create containers with the empty # environment as parent: env <- new_environment() env_parent(env) #> <environment: R_EmptyEnv>  # Like other new_ constructors, it takes an object rather than dots: new_environment(list(a = \"foo\", b = \"bar\")) #> <environment: 0x562dde80c290>"},{"path":"https://rlang.r-lib.org/dev/reference/env_bind.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind symbols to objects in an environment — env_bind","title":"Bind symbols to objects in an environment — env_bind","text":"functions create bindings environment. bindings supplied ... pairs names values expressions. env_bind() equivalent evaluating <- expression within given environment. function take care majority use cases variants can useful specific problems. env_bind() takes named values bound .env. env_bind() equivalent base::assign(). env_bind_active() takes named functions creates active bindings .env. equivalent base::makeActiveBinding(). active binding executes function time evaluated. arguments passed as_function() can supply formulas instead functions. Remember functions scoped environment. functions can thus refer symbols enclosure actually scope dynamic environment active bindings invoked. allows creative solutions difficult problems (see implementations dplyr::() methods example). env_bind_lazy() takes named expressions. equivalent base::delayedAssign(). arguments captured exprs() (thus support call-splicing unquoting) assigned symbols .env. expressions evaluated immediately lazily. symbol evaluated, corresponding expression evaluated turn value bound symbol (expressions thus evaluated , ). %<~% shortcut env_bind_lazy(). works like <- RHS evaluated lazily.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_bind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind symbols to objects in an environment — env_bind","text":"","code":"env_bind(.env, ...)  env_bind_lazy(.env, ..., .eval_env = caller_env())  env_bind_active(.env, ...)  lhs %<~% rhs"},{"path":"https://rlang.r-lib.org/dev/reference/env_bind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bind symbols to objects in an environment — env_bind","text":".env environment. ... <dynamic> Named objects (env_bind()), expressions env_bind_lazy(), functions (env_bind_active()). Use zap() remove bindings. .eval_env environment expressions evaluated symbols forced. lhs variable name rhs lazily assigned. rhs expression lazily evaluated assigned lhs.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_bind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bind symbols to objects in an environment — env_bind","text":"input object .env, associated environment modified place, invisibly.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_bind.html","id":"side-effects","dir":"Reference","previous_headings":"","what":"Side effects","title":"Bind symbols to objects in an environment — env_bind","text":"Since environments reference semantics (see relevant section env() documentation), modifying bindings environment produces effects references environment. words, env_bind() variants side effects. Like side-effecty functions like par() options(), env_bind() variants return old values invisibly.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/env_bind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bind symbols to objects in an environment — env_bind","text":"","code":"# env_bind() is a programmatic way of assigning values to symbols # with `<-`. We can add bindings in the current environment: env_bind(current_env(), foo = \"bar\") foo #> [1] \"bar\"  # Or modify those bindings: bar <- \"bar\" env_bind(current_env(), bar = \"BAR\") bar #> [1] \"BAR\"  # You can remove bindings by supplying zap sentinels: env_bind(current_env(), foo = zap()) try(foo) #> Error in eval(expr, envir) : object 'foo' not found  # Unquote-splice a named list of zaps zaps <- rep_named(c(\"foo\", \"bar\"), list(zap())) env_bind(current_env(), !!!zaps) try(bar) #> Error in eval(expr, envir) : object 'bar' not found  # It is most useful to change other environments: my_env <- env() env_bind(my_env, foo = \"foo\") my_env$foo #> [1] \"foo\"  # A useful feature is to splice lists of named values: vals <- list(a = 10, b = 20) env_bind(my_env, !!!vals, c = 30) my_env$b #> [1] 20 my_env$c #> [1] 30  # You can also unquote a variable referring to a symbol or a string # as binding name: var <- \"baz\" env_bind(my_env, !!var := \"BAZ\") my_env$baz #> [1] \"BAZ\"   # The old values of the bindings are returned invisibly: old <- env_bind(my_env, a = 1, b = 2, baz = \"baz\") old #> $a #> [1] 10 #>  #> $b #> [1] 20 #>  #> $baz #> [1] \"BAZ\" #>   # You can restore the original environment state by supplying the # old values back: env_bind(my_env, !!!old)  # env_bind_lazy() assigns expressions lazily: env <- env() env_bind_lazy(env, name = { cat(\"forced!\\n\"); \"value\" })  # Referring to the binding will cause evaluation: env$name #> forced! #> [1] \"value\"  # But only once, subsequent references yield the final value: env$name #> [1] \"value\"  # You can unquote expressions: expr <- quote(message(\"forced!\")) env_bind_lazy(env, name = !!expr) env$name #> forced! #> NULL   # By default the expressions are evaluated in the current # environment. For instance we can create a local binding and refer # to it, even though the variable is bound in a different # environment: who <- \"mickey\" env_bind_lazy(env, name = paste(who, \"mouse\")) env$name #> [1] \"mickey mouse\"  # You can specify another evaluation environment with `.eval_env`: eval_env <- env(who = \"minnie\") env_bind_lazy(env, name = paste(who, \"mouse\"), .eval_env = eval_env) env$name #> [1] \"minnie mouse\"  # Or by unquoting a quosure: quo <- local({   who <- \"fievel\"   quo(paste(who, \"mouse\")) }) env_bind_lazy(env, name = !!quo) env$name #> [1] \"fievel mouse\"  # You can create active bindings with env_bind_active(). Active # bindings execute a function each time they are evaluated: fn <- function() {   cat(\"I have been called\\n\")   rnorm(1) }  env <- env() env_bind_active(env, symbol = fn)  # `fn` is executed each time `symbol` is evaluated or retrieved: env$symbol #> I have been called #> [1] -1.400044 env$symbol #> I have been called #> [1] 0.2553171 eval_bare(quote(symbol), env) #> I have been called #> [1] -2.437264 eval_bare(quote(symbol), env) #> I have been called #> [1] -0.005571287  # All arguments are passed to as_function() so you can use the # formula shortcut: env_bind_active(env, foo = ~ runif(1)) env$foo #> [1] 0.732882 env$foo #> [1] 0.7725215"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/env_binding_are_active.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"What kind of environment binding? — env_binding_are_active","text":"","code":"env_binding_are_active(env, nms = NULL)  env_binding_are_lazy(env, nms = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/env_binding_are_active.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"What kind of environment binding? — env_binding_are_active","text":"env environment. nms Names bindings. Defaults bindings env.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_binding_are_active.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"What kind of environment binding? — env_binding_are_active","text":"logical vector long nms named .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_binding_lock.html","id":null,"dir":"Reference","previous_headings":"","what":"Lock or unlock environment bindings — env_binding_lock","title":"Lock or unlock environment bindings — env_binding_lock","text":"Locked environment bindings trigger error attempt made redefine binding.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_binding_lock.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lock or unlock environment bindings — env_binding_lock","text":"","code":"env_binding_lock(env, nms = NULL)  env_binding_unlock(env, nms = NULL)  env_binding_are_locked(env, nms = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/env_binding_lock.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lock or unlock environment bindings — env_binding_lock","text":"env environment. nms Names bindings. Defaults bindings env.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_binding_lock.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lock or unlock environment bindings — env_binding_lock","text":"env_binding_are_unlocked() returns logical vector long nms named . env_binding_lock() env_binding_unlock() return old value env_binding_are_unlocked() invisibly.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/env_binding_lock.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lock or unlock environment bindings — env_binding_lock","text":"","code":"# Bindings are unlocked by default: env <- env(a = \"A\", b = \"B\") env_binding_are_locked(env) #>     a     b  #> FALSE FALSE   # But can optionally be locked: env_binding_lock(env, \"a\") env_binding_are_locked(env) #>     a     b  #>  TRUE FALSE   # If run, the following would now return an error because `a` is locked: # env_bind(env, a = \"foo\") # with_env(env, a <- \"bar\")  # Let's unlock it. Note that the return value indicate which # bindings were locked: were_locked <- env_binding_unlock(env) were_locked #>     a     b  #>  TRUE FALSE   # Now that it is unlocked we can modify it again: env_bind(env, a = \"foo\") with_env(env, a <- \"bar\") env$a #> [1] \"bar\""},{"path":"https://rlang.r-lib.org/dev/reference/env_browse.html","id":null,"dir":"Reference","previous_headings":"","what":"Browse environments — env_browse","title":"Browse environments — env_browse","text":"env_browse(env) equivalent evaluating browser() env. persistently sets environment step-debugging. Supply value = FALSE disable browsing. env_is_browsed() predicate inspects whether environment browsed.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_browse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Browse environments — env_browse","text":"","code":"env_browse(env, value = TRUE)  env_is_browsed(env)"},{"path":"https://rlang.r-lib.org/dev/reference/env_browse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Browse environments — env_browse","text":"env environment. value Whether browse env.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_browse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Browse environments — env_browse","text":"env_browse() returns previous value env_is_browsed() (logical), invisibly.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_bury.html","id":null,"dir":"Reference","previous_headings":"","what":"Mask bindings by defining symbols deeper in a scope — env_bury","title":"Mask bindings by defining symbols deeper in a scope — env_bury","text":"function superseded. Please use env() (possibly set_env() masking bindings another object like closure formula) instead. env_bury() like env_bind() creates bindings new child environment. makes sure new bindings precedence old ones, without altering existing environments. Unlike env_bind(), function side effects returns new environment (object wrapping environment).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_bury.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mask bindings by defining symbols deeper in a scope — env_bury","text":"","code":"env_bury(.env, ...)"},{"path":"https://rlang.r-lib.org/dev/reference/env_bury.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mask bindings by defining symbols deeper in a scope — env_bury","text":".env environment. ... <dynamic> Named objects (env_bind()), expressions env_bind_lazy(), functions (env_bind_active()). Use zap() remove bindings.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_bury.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mask bindings by defining symbols deeper in a scope — env_bury","text":"copy .env enclosing new environment containing bindings ... arguments.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/env_bury.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mask bindings by defining symbols deeper in a scope — env_bury","text":"","code":"orig_env <- env(a = 10) fn <- set_env(function() a, orig_env)  # fn() currently sees `a` as the value `10`: fn() #> [1] 10  # env_bury() will bury the current scope of fn() behind a new # environment: fn <- env_bury(fn, a = 1000) fn() #> [1] 1000  # Even though the symbol `a` is still defined deeper in the scope: orig_env$a #> [1] 10"},{"path":"https://rlang.r-lib.org/dev/reference/env_cache.html","id":null,"dir":"Reference","previous_headings":"","what":"Cache a value in an environment — env_cache","title":"Cache a value in an environment — env_cache","text":"env_cache() wrapper around env_get() env_poke() designed retrieve cached value env. nm binding exists, returns value. Otherwise, stores default value env returns .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_cache.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cache a value in an environment — env_cache","text":"","code":"env_cache(env, nm, default)"},{"path":"https://rlang.r-lib.org/dev/reference/env_cache.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cache a value in an environment — env_cache","text":"env environment. nm Name binding, string. default default value store env nm exist yet.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_cache.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cache a value in an environment — env_cache","text":"Either value nm default exist yet.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_cache.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cache a value in an environment — env_cache","text":"","code":"e <- env(a = \"foo\")  # Returns existing binding env_cache(e, \"a\", \"default\") #> [1] \"foo\"  # Creates a `b` binding and returns its default value env_cache(e, \"b\", \"default\") #> [1] \"default\"  # Now `b` is defined e$b #> [1] \"default\""},{"path":"https://rlang.r-lib.org/dev/reference/env_clone.html","id":null,"dir":"Reference","previous_headings":"","what":"Clone or coalesce an environment — env_clone","title":"Clone or coalesce an environment — env_clone","text":"env_clone() creates new environment containing exactly bindings input, optionally new parent. env_coalesce() copies binding RHS environment LHS. RHS already contains bindings name LHS, kept . functions preserve active bindings promises (latter preserved R >= 4.0.0).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_clone.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clone or coalesce an environment — env_clone","text":"","code":"env_clone(env, parent = env_parent(env))  env_coalesce(env, from)"},{"path":"https://rlang.r-lib.org/dev/reference/env_clone.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clone or coalesce an environment — env_clone","text":"env environment. parent parent cloned environment. Environment copy bindings .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_clone.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clone or coalesce an environment — env_clone","text":"","code":"# A clone initially contains the same bindings as the original # environment env <- env(a = 1, b = 2) clone <- env_clone(env)  env_print(clone) #> <environment: 0x562dd672a5c8> #> Parent: <environment: 0x562dd745fb80> #> Bindings: #> • a: <dbl> #> • b: <dbl> env_print(env) #> <environment: 0x562dd5960ad0> #> Parent: <environment: 0x562dd745fb80> #> Bindings: #> • a: <dbl> #> • b: <dbl>  # But it can acquire new bindings or change existing ones without # impacting the original environment env_bind(clone, a = \"foo\", c = 3)  env_print(clone) #> <environment: 0x562dd672a5c8> #> Parent: <environment: 0x562dd745fb80> #> Bindings: #> • a: <chr> #> • b: <dbl> #> • c: <dbl> env_print(env) #> <environment: 0x562dd5960ad0> #> Parent: <environment: 0x562dd745fb80> #> Bindings: #> • a: <dbl> #> • b: <dbl>   # `env_coalesce()` copies bindings from one environment to another lhs <- env(a = 1) rhs <- env(a = \"a\", b = \"b\", c = \"c\") env_coalesce(lhs, rhs) env_print(lhs) #> <environment: 0x562dde498120> #> Parent: <environment: 0x562dd745fb80> #> Bindings: #> • a: <dbl> #> • b: <chr> #> • c: <chr>  # To copy all the bindings from `rhs` into `lhs`, first delete the # conflicting bindings from `rhs` env_unbind(lhs, env_names(rhs)) env_coalesce(lhs, rhs) env_print(lhs) #> <environment: 0x562dde498120> #> Parent: <environment: 0x562dd745fb80> #> Bindings: #> • a: <chr> #> • b: <chr> #> • c: <chr>"},{"path":"https://rlang.r-lib.org/dev/reference/env_depth.html","id":null,"dir":"Reference","previous_headings":"","what":"Depth of an environment chain — env_depth","title":"Depth of an environment chain — env_depth","text":"function returns number environments env empty environment, including env. depth env also number parents env (since empty environment counts parent).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_depth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Depth of an environment chain — env_depth","text":"","code":"env_depth(env)"},{"path":"https://rlang.r-lib.org/dev/reference/env_depth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Depth of an environment chain — env_depth","text":"env environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_depth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Depth of an environment chain — env_depth","text":"integer.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/env_depth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Depth of an environment chain — env_depth","text":"","code":"env_depth(empty_env()) #> [1] 0 env_depth(pkg_env(\"rlang\")) #> [1] 9"},{"path":"https://rlang.r-lib.org/dev/reference/env_get.html","id":null,"dir":"Reference","previous_headings":"","what":"Get an object in an environment — env_get","title":"Get an object in an environment — env_get","text":"env_get() extracts object enviroment env. default, look parent environments. env_get_list() extracts multiple objects environment named list.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_get.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get an object in an environment — env_get","text":"","code":"env_get(env = caller_env(), nm, default, inherit = FALSE, last = empty_env())  env_get_list(   env = caller_env(),   nms,   default,   inherit = FALSE,   last = empty_env() )"},{"path":"https://rlang.r-lib.org/dev/reference/env_get.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get an object in an environment — env_get","text":"env environment. nm Name binding, string. default default value case binding nm env. inherit Whether look bindings parent environments. last Last environment inspected inherit TRUE. Can useful conjunction base::topenv(). nms Names bindings, character vector.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_get.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get an object in an environment — env_get","text":"object exists. Otherwise, throws error.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/env_get.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get an object in an environment — env_get","text":"","code":"parent <- child_env(NULL, foo = \"foo\") env <- child_env(parent, bar = \"bar\")  # This throws an error because `foo` is not directly defined in env: # env_get(env, \"foo\")  # However `foo` can be fetched in the parent environment: env_get(env, \"foo\", inherit = TRUE) #> [1] \"foo\"  # You can also avoid an error by supplying a default value: env_get(env, \"foo\", default = \"FOO\") #> [1] \"FOO\""},{"path":"https://rlang.r-lib.org/dev/reference/env_has.html","id":null,"dir":"Reference","previous_headings":"","what":"Does an environment have or see bindings? — env_has","title":"Does an environment have or see bindings? — env_has","text":"env_has() vectorised predicate queries whether environment owns bindings personally (inherit set FALSE, default), sees environment parents (inherit = TRUE).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_has.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does an environment have or see bindings? — env_has","text":"","code":"env_has(env = caller_env(), nms, inherit = FALSE)"},{"path":"https://rlang.r-lib.org/dev/reference/env_has.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does an environment have or see bindings? — env_has","text":"env environment. nms character vector binding names check existence. inherit Whether look bindings parent environments.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_has.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Does an environment have or see bindings? — env_has","text":"named logical vector long nms.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_has.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Does an environment have or see bindings? — env_has","text":"","code":"parent <- child_env(NULL, foo = \"foo\") env <- child_env(parent, bar = \"bar\")  # env does not own `foo` but sees it in its parent environment: env_has(env, \"foo\") #>   foo  #> FALSE  env_has(env, \"foo\", inherit = TRUE) #>  foo  #> TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/env_inherits.html","id":null,"dir":"Reference","previous_headings":"","what":"Does environment inherit from another environment? — env_inherits","title":"Does environment inherit from another environment? — env_inherits","text":"returns TRUE x ancestor among parents.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_inherits.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does environment inherit from another environment? — env_inherits","text":"","code":"env_inherits(env, ancestor)"},{"path":"https://rlang.r-lib.org/dev/reference/env_inherits.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does environment inherit from another environment? — env_inherits","text":"env environment. ancestor Another environment x might inherit.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_is_user_facing.html","id":null,"dir":"Reference","previous_headings":"","what":"Is frame environment user facing? — env_is_user_facing","title":"Is frame environment user facing? — env_is_user_facing","text":"Detects env user-facing, , whether environment inherits : global environment, happen called interactively package currently tested either true, consider env belong evaluation frame called directly end user. contrast indirect calls third party functions user facing. instance lifecycle package uses env_is_user_facing() figure whether deprecated function called directly indirectly, select appropriate verbosity level function .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_is_user_facing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is frame environment user facing? — env_is_user_facing","text":"","code":"env_is_user_facing(env)"},{"path":"https://rlang.r-lib.org/dev/reference/env_is_user_facing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is frame environment user facing? — env_is_user_facing","text":"env environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_is_user_facing.html","id":"escape-hatch","dir":"Reference","previous_headings":"","what":"Escape hatch","title":"Is frame environment user facing? — env_is_user_facing","text":"can override return value env_is_user_facing() setting global option \"rlang_user_facing\" : TRUE FALSE. package name string. env_is_user_facing(x) returns TRUE x inherits namespace corresponding package name.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_is_user_facing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is frame environment user facing? — env_is_user_facing","text":"","code":"fn <- function() {   env_is_user_facing(caller_env()) }  # Direct call of `fn()` from the global env with(global_env(), fn()) #> Error in fn(): could not find function \"fn\"  # Indirect call of `fn()` from a package with(ns_env(\"utils\"), fn()) #> Error in fn(): could not find function \"fn\""},{"path":"https://rlang.r-lib.org/dev/reference/env_lock.html","id":null,"dir":"Reference","previous_headings":"","what":"Lock an environment — env_lock","title":"Lock an environment — env_lock","text":"Locked environments modified. important example namespace environments locked R loaded session. environment locked normally unlocked. Note environment container locked, individual bindings. remove add binding can still modify values existing bindings. See env_binding_lock() locking individual bindings.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_lock.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lock an environment — env_lock","text":"","code":"env_lock(env)  env_is_locked(env)"},{"path":"https://rlang.r-lib.org/dev/reference/env_lock.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lock an environment — env_lock","text":"env environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_lock.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lock an environment — env_lock","text":"old value env_is_locked() invisibly.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/env_lock.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lock an environment — env_lock","text":"","code":"# New environments are unlocked by default: env <- env(a = 1) env_is_locked(env) #> [1] FALSE  # Use env_lock() to lock them: env_lock(env) env_is_locked(env) #> [1] TRUE  # Now that `env` is locked, it is no longer possible to remove or # add bindings. If run, the following would fail: # env_unbind(env, \"a\") # env_bind(env, b = 2)  # Note that even though the environment as a container is locked, # the individual bindings are still unlocked and can be modified: env$a <- 10"},{"path":"https://rlang.r-lib.org/dev/reference/env_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Label of an environment — env_name","title":"Label of an environment — env_name","text":"Special environments like global environment names. env_name() returns: \"global\" global environment. \"empty\" empty environment. \"base\" base package environment (last environment search path). \"namespace:pkg\" env namespace package \"pkg\". name attribute env exists. package environments imports environments store names. name package environments typically \"package:pkg\". empty string \"\" otherwise. env_label() exactly like env_name() returns memory address anonymous environments fallback.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label of an environment — env_name","text":"","code":"env_name(env)  env_label(env)"},{"path":"https://rlang.r-lib.org/dev/reference/env_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label of an environment — env_name","text":"env environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_name.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label of an environment — env_name","text":"","code":"# Some environments have specific names: env_name(global_env()) #> [1] \"global\" env_name(ns_env(\"rlang\")) #> [1] \"namespace:rlang\"  # Anonymous environments don't have names but are labelled by their # address in memory: env_name(env()) #> [1] \"\" env_label(env()) #> [1] \"0x562dda820348\""},{"path":"https://rlang.r-lib.org/dev/reference/env_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Names and numbers of symbols bound in an environment — env_names","title":"Names and numbers of symbols bound in an environment — env_names","text":"env_names() returns object names enviroment env character vector. names returned, even starting dot. env_length() returns number bindings.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Names and numbers of symbols bound in an environment — env_names","text":"","code":"env_names(env)  env_length(env)"},{"path":"https://rlang.r-lib.org/dev/reference/env_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Names and numbers of symbols bound in an environment — env_names","text":"env environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Names and numbers of symbols bound in an environment — env_names","text":"character vector object names.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_names.html","id":"names-of-symbols-and-objects","dir":"Reference","previous_headings":"","what":"Names of symbols and objects","title":"Names and numbers of symbols bound in an environment — env_names","text":"Technically, objects bound symbols rather strings, since R interpreter evaluates symbols (see is_expression() discussion symbolic objects versus literal objects). However often convenient work strings. rlang terminology, string corresponding symbol called name symbol (extension name object bound symbol).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_names.html","id":"encoding","dir":"Reference","previous_headings":"","what":"Encoding","title":"Names and numbers of symbols bound in an environment — env_names","text":"deep encoding issues convert string symbol vice versa. Symbols always native encoding. encoding (say latin1) support characters, characters serialised ASCII. sometimes see strings looking like <U+1234>, especially running Windows (R support UTF-8 native encoding platform). alleviate encoding pain, env_names() always returns UTF-8 character vector (fine even Windows) ASCII unicode points translated back UTF-8.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Names and numbers of symbols bound in an environment — env_names","text":"","code":"env <- env(a = 1, b = 2) env_names(env) #> [1] \"a\" \"b\""},{"path":"https://rlang.r-lib.org/dev/reference/env_parent.html","id":null,"dir":"Reference","previous_headings":"","what":"Get parent environments — env_parent","title":"Get parent environments — env_parent","text":"env_parent() returns parent environment env called n = 1, grandparent n = 2, etc. env_tail() searches parents returns one empty_env() parent. env_parents() returns list parents, including empty environment. list named using env_name(). See section inheritance env()'s documentation.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_parent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get parent environments — env_parent","text":"","code":"env_parent(env = caller_env(), n = 1)  env_tail(env = caller_env(), last = global_env())  env_parents(env = caller_env(), last = global_env())"},{"path":"https://rlang.r-lib.org/dev/reference/env_parent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get parent environments — env_parent","text":"env environment. n number generations go . last environment stop. Defaults global environment. empty environment always stopping condition safe leave default even taking tail parents environment search path. env_tail() returns environment last parent env_parents() returns list environments last.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_parent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get parent environments — env_parent","text":"environment env_parent() env_tail(), list environments env_parents().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_parent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get parent environments — env_parent","text":"","code":"# Get the parent environment with env_parent(): env_parent(global_env()) #> <environment: package:rlang> #> attr(,\"name\") #> [1] \"package:rlang\" #> attr(,\"path\") #> [1] \"/home/runner/work/_temp/Library/rlang\"  # Or the tail environment with env_tail(): env_tail(global_env()) #> <environment: base>  # By default, env_parent() returns the parent environment of the # current evaluation frame. If called at top-level (the global # frame), the following two expressions are equivalent: env_parent() #> <environment: 0x562dd970dbd0> env_parent(base_env()) #> <environment: R_EmptyEnv>  # This default is more handy when called within a function. In this # case, the enclosure environment of the function is returned # (since it is the parent of the evaluation frame): enclos_env <- env() fn <- set_env(function() env_parent(), enclos_env) identical(enclos_env, fn()) #> [1] TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/env_poke.html","id":null,"dir":"Reference","previous_headings":"","what":"Poke an object in an environment — env_poke","title":"Poke an object in an environment — env_poke","text":"env_poke() assign reassign binding env create TRUE. create FALSE binding already exists, error issued.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_poke.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Poke an object in an environment — env_poke","text":"","code":"env_poke(env = caller_env(), nm, value, inherit = FALSE, create = !inherit)"},{"path":"https://rlang.r-lib.org/dev/reference/env_poke.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Poke an object in an environment — env_poke","text":"env environment. nm Name binding, string. value value new binding. inherit Whether look bindings parent environments. create Whether create binding already exist environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_poke.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Poke an object in an environment — env_poke","text":"old value nm zap sentinel binding exist yet.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_poke.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Poke an object in an environment — env_poke","text":"inherit TRUE, parents environments checked existing binding reassign. found create TRUE, new binding created env. default value create function inherit: FALSE inheriting, TRUE otherwise. default makes sense inheriting case mostly overriding existing binding. found, something probably went wrong safer issue error. Note different base R operator <<- create binding global environment instead current environment existing binding found parents.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/env_print.html","id":null,"dir":"Reference","previous_headings":"","what":"Pretty-print an environment — env_print","title":"Pretty-print an environment — env_print","text":"prints: label parent label. Whether environment locked. bindings environment (20 bindings). printed succintly using pillar::type_sum() (available, otherwise uses internal version generic). addition fancy bindings (actives promises) indicated . Locked bindings get [L] tag Note printing package namespace (see ns_env()) env_print() typically tag function bindings <lazy> evaluated first time. package functions lazily-loaded disk improve performance loading package.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pretty-print an environment — env_print","text":"","code":"env_print(env = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/env_print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pretty-print an environment — env_print","text":"env environment, object can converted environment get_env().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_unbind.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove bindings from an environment — env_unbind","title":"Remove bindings from an environment — env_unbind","text":"env_unbind() complement env_bind(). Like env_has(), ignores parent environments env default. Set inherit TRUE track bindings parent environments.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_unbind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove bindings from an environment — env_unbind","text":"","code":"env_unbind(env = caller_env(), nms, inherit = FALSE)"},{"path":"https://rlang.r-lib.org/dev/reference/env_unbind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove bindings from an environment — env_unbind","text":"env environment. nms character vector binding names remove. inherit Whether look bindings parent environments.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_unbind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove bindings from an environment — env_unbind","text":"input object env associated environment modified place, invisibly.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_unbind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove bindings from an environment — env_unbind","text":"","code":"env <- env(foo = 1, bar = 2) env_has(env, c(\"foo\", \"bar\")) #>  foo  bar  #> TRUE TRUE   # Remove bindings with `env_unbind()` env_unbind(env, c(\"foo\", \"bar\")) env_has(env, c(\"foo\", \"bar\")) #>   foo   bar  #> FALSE FALSE   # With inherit = TRUE, it removes bindings in parent environments # as well: parent <- env(empty_env(), foo = 1, bar = 2) env <- env(parent, foo = \"b\")  env_unbind(env, \"foo\", inherit = TRUE) env_has(env, c(\"foo\", \"bar\")) #>   foo   bar  #> FALSE FALSE  env_has(env, c(\"foo\", \"bar\"), inherit = TRUE) #>  foo  bar  #> TRUE TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/env_unlock.html","id":null,"dir":"Reference","previous_headings":"","what":"Unlock an environment — env_unlock","title":"Unlock an environment — env_unlock","text":". function now defunct recent versions R longer make possible unlock environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_unlock.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unlock an environment — env_unlock","text":"","code":"env_unlock(env)"},{"path":"https://rlang.r-lib.org/dev/reference/env_unlock.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unlock an environment — env_unlock","text":"env environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/env_unlock.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unlock an environment — env_unlock","text":"Whether environment unlocked.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/eval_bare.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate an expression in an environment — eval_bare","title":"Evaluate an expression in an environment — eval_bare","text":"eval_bare() lower-level version function base::eval(). Technically, simple wrapper around C function Rf_eval(). generally need use eval_bare() instead eval(). main advantage handles stack-sensitive calls (return(), .exit() parent.frame()) consistently pass enviroment frame call stack.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/eval_bare.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate an expression in an environment — eval_bare","text":"","code":"eval_bare(expr, env = parent.frame())"},{"path":"https://rlang.r-lib.org/dev/reference/eval_bare.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate an expression in an environment — eval_bare","text":"expr expression evaluate. env environment evaluate expression.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/eval_bare.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate an expression in an environment — eval_bare","text":"semantics possible eval_bare() creates one frame call stack whereas eval() creates two frames, second user-supplied environment frame environment. supply existing frame environment base::eval() two frames stack frame environment. Stack-sensitive functions detect topmost frames. call evaluation semantics \"stack inconsistent\". Evaluating expressions actual frame environment useful practical implications eval_bare(): return() calls evaluated frame environments might burried deep call stack. causes long return unwinds multiple frames (triggering .exit() event frame). contrast eval() returns eval() call, one level . .exit(), parent.frame(), sys.call(), generally stack inspection functions sys.xxx() evaluated correct frame environment. similar type calls can evaluated deep call stack lazy evaluation, force argument passed around several times. flip side semantics eval_bare() evaluate break next expressions even called within loop.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/eval_bare.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate an expression in an environment — eval_bare","text":"","code":"# eval_bare() works just like base::eval() but you have to create # the evaluation environment yourself: eval_bare(quote(foo), env(foo = \"bar\")) #> [1] \"bar\"  # eval() has different evaluation semantics than eval_bare(). It # can return from the supplied environment even if its an # environment that is not on the call stack (i.e. because you've # created it yourself). The following would trigger an error with # eval_bare(): ret <- quote(return(\"foo\")) eval(ret, env()) #> [1] \"foo\" # eval_bare(ret, env())  # \"no function to return from\" error  # Another feature of eval() is that you can control surround loops: bail <- quote(break) while (TRUE) {   eval(bail)   # eval_bare(bail)  # \"no loop for break/next\" error }  # To explore the consequences of stack inconsistent semantics, let's # create a function that evaluates `parent.frame()` deep in the call # stack, in an environment corresponding to a frame in the middle of # the stack. For consistency with R's lazy evaluation semantics, we'd # expect to get the caller of that frame as result: fn <- function(eval_fn) {   list(     returned_env = middle(eval_fn),     actual_env = current_env()   ) } middle <- function(eval_fn) {   deep(eval_fn, current_env()) } deep <- function(eval_fn, eval_env) {   expr <- quote(parent.frame())   eval_fn(expr, eval_env) }  # With eval_bare(), we do get the expected environment: fn(rlang::eval_bare) #> $returned_env #> <environment: 0x562ddf473ed0> #>  #> $actual_env #> <environment: 0x562ddf473ed0> #>   # But that's not the case with base::eval(): fn(base::eval) #> $returned_env #> <environment: 0x562ddf8550e0> #>  #> $actual_env #> <environment: 0x562ddcfd6ba8> #>"},{"path":"https://rlang.r-lib.org/dev/reference/eval_tidy.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate an expression with quosures and pronoun support — eval_tidy","title":"Evaluate an expression with quosures and pronoun support — eval_tidy","text":"eval_tidy() variant base::eval() powers tidy evaluation framework. Like eval() accepts user data argument. Whereas eval() simply transforms data environment, eval_tidy() transforms data mask as_data_mask(). Evaluating data mask enables following features: Quosures. Quosures expressions bundled environment. data supplied, objects data mask always precedence quosure environment, .e. data masks environment. Pronouns. data supplied, .env .data pronouns installed data mask. .env reference calling environment .data refers data argument. pronouns escape hatch data mask ambiguity problem.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/eval_tidy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate an expression with quosures and pronoun support — eval_tidy","text":"","code":"eval_tidy(expr, data = NULL, env = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/eval_tidy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate an expression with quosures and pronoun support — eval_tidy","text":"expr expression quosure evaluate. data data frame, named list vector. Alternatively, data mask created as_data_mask() new_data_mask(). Objects data priority env. See section data masking. env environment evaluate expr. environment applicable quosures environments.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/eval_tidy.html","id":"when-should-eval-tidy-be-used-instead-of-eval-","dir":"Reference","previous_headings":"","what":"When should eval_tidy() be used instead of eval()?","title":"Evaluate an expression with quosures and pronoun support — eval_tidy","text":"base::eval() sufficient simple evaluation. Use eval_tidy() like support expressions referring .data pronoun, need support quosures. evaluating expression captured injection support, recommended use eval_tidy() users may inject quosures. Note unwrapping quosure quo_get_expr() guarantee quosures inside expression. Quosures might unquoted anywhere expression tree. instance, following work reliably presence nested quosures:","code":"my_quoting_fn <- function(x) {   x <- enquo(x)   expr <- quo_get_expr(x)   env <- quo_get_env(x)   eval(expr, env) }  # Works: my_quoting_fn(toupper(letters))  # Fails because of a nested quosure: my_quoting_fn(toupper(!!quo(letters)))"},{"path":"https://rlang.r-lib.org/dev/reference/eval_tidy.html","id":"stack-semantics-of-eval-tidy-","dir":"Reference","previous_headings":"","what":"Stack semantics of eval_tidy()","title":"Evaluate an expression with quosures and pronoun support — eval_tidy","text":"eval_tidy() always evaluates data mask, even data NULL. , different stack semantics base::eval(): Lexical side effects, assignment <-, occur mask rather env. Functions require evaluation environment correspond frame call stack work. return() called quosure work. mask environment creates new branch tree representation backtraces (can visualise browser() session lobstr::cst()). See also eval_bare() information differences.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/eval_tidy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate an expression with quosures and pronoun support — eval_tidy","text":"","code":"# With simple defused expressions eval_tidy() works the same way as # eval(): fruit <- \"apple\" vegetable <- \"potato\" expr <- quote(paste(fruit, vegetable, sep = \" or \")) expr #> paste(fruit, vegetable, sep = \" or \")  eval(expr) #> [1] \"apple or potato\" eval_tidy(expr) #> [1] \"apple or potato\"  # Both accept a data mask as argument: data <- list(fruit = \"banana\", vegetable = \"carrot\") eval(expr, data) #> [1] \"banana or carrot\" eval_tidy(expr, data) #> [1] \"banana or carrot\"  # The main difference is that eval_tidy() supports quosures: with_data <- function(data, expr) {   quo <- enquo(expr)   eval_tidy(quo, data) } with_data(NULL, fruit) #> [1] \"apple\" with_data(data, fruit) #> [1] \"banana\"  # eval_tidy() installs the `.data` and `.env` pronouns to allow # users to be explicit about variable references: with_data(data, .data$fruit) #> [1] \"banana\" with_data(data, .env$fruit) #> [1] \"apple\""},{"path":"https://rlang.r-lib.org/dev/reference/exec.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute a function — exec","title":"Execute a function — exec","text":"function constructs evaluates call .fn. two primary uses: call function arguments stored list (function support dynamic dots). Splice list arguments !!!. call every function stored list (conjunction map()/ lapply())","code":""},{"path":"https://rlang.r-lib.org/dev/reference/exec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute a function — exec","text":"","code":"exec(.fn, ..., .env = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/exec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Execute a function — exec","text":".fn function, function name string. ... <dynamic> Arguments .fn. .env Environment evaluate call. useful .fn string, function side-effects.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/exec.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Execute a function — exec","text":"","code":"args <- list(x = c(1:10, 100, NA), na.rm = TRUE) exec(\"mean\", !!!args) #> [1] 14.09091 exec(\"mean\", !!!args, trim = 0.2) #> [1] 6  fs <- list(a = function() \"a\", b = function() \"b\") lapply(fs, exec) #> $a #> [1] \"a\" #>  #> $b #> [1] \"b\" #>   # Compare to do.call it will not automatically inline expressions # into the evaluated call. x <- 10 args <- exprs(x1 = x + 1, x2 = x * 2) exec(list, !!!args) #> $x1 #> x + 1 #>  #> $x2 #> x * 2 #>  do.call(list, args) #> $x1 #> [1] 11 #>  #> $x2 #> [1] 20 #>   # exec() is not designed to generate pretty function calls. This is # most easily seen if you call a function that captures the call: f <- disp ~ cyl exec(\"lm\", f, data = mtcars) #>  #> Call: #> lm(formula = .Primitive(\"quote\")(disp ~ cyl), data = structure(list( #>     mpg = c(21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8,  #>     19.2, 17.8, 16.4, 17.3, 15.2, 10.4, 10.4, 14.7, 32.4, 30.4,  #>     33.9, 21.5, 15.5, 15.2, 13.3, 19.2, 27.3, 26, 30.4, 15.8,  #>     19.7, 15, 21.4), cyl = c(6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6,  #>     8, 8, 8, 8, 8, 8, 4, 4, 4, 4, 8, 8, 8, 8, 4, 4, 4, 8, 6,  #>     8, 4), disp = c(160, 160, 108, 258, 360, 225, 360, 146.7,  #>     140.8, 167.6, 167.6, 275.8, 275.8, 275.8, 472, 460, 440,  #>     78.7, 75.7, 71.1, 120.1, 318, 304, 350, 400, 79, 120.3, 95.1,  #>     351, 145, 301, 121), hp = c(110, 110, 93, 110, 175, 105,  #>     245, 62, 95, 123, 123, 180, 180, 180, 205, 215, 230, 66,  #>     52, 65, 97, 150, 150, 245, 175, 66, 91, 113, 264, 175, 335,  #>     109), drat = c(3.9, 3.9, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69,  #>     3.92, 3.92, 3.92, 3.07, 3.07, 3.07, 2.93, 3, 3.23, 4.08,  #>     4.93, 4.22, 3.7, 2.76, 3.15, 3.73, 3.08, 4.08, 4.43, 3.77,  #>     4.22, 3.62, 3.54, 4.11), wt = c(2.62, 2.875, 2.32, 3.215,  #>     3.44, 3.46, 3.57, 3.19, 3.15, 3.44, 3.44, 4.07, 3.73, 3.78,  #>     5.25, 5.424, 5.345, 2.2, 1.615, 1.835, 2.465, 3.52, 3.435,  #>     3.84, 3.845, 1.935, 2.14, 1.513, 3.17, 2.77, 3.57, 2.78),  #>     qsec = c(16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84,  #>     20, 22.9, 18.3, 18.9, 17.4, 17.6, 18, 17.98, 17.82, 17.42,  #>     19.47, 18.52, 19.9, 20.01, 16.87, 17.3, 15.41, 17.05, 18.9,  #>     16.7, 16.9, 14.5, 15.5, 14.6, 18.6), vs = c(0, 0, 1, 1, 0,  #>     1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0,  #>     0, 1, 0, 1, 0, 0, 0, 1), am = c(1, 1, 1, 0, 0, 0, 0, 0, 0,  #>     0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1,  #>     1, 1, 1, 1), gear = c(4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3,  #>     3, 3, 3, 3, 3, 4, 4, 4, 3, 3, 3, 3, 3, 4, 5, 5, 5, 5, 5,  #>     4), carb = c(4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4,  #>     4, 4, 1, 2, 1, 1, 2, 2, 4, 2, 1, 2, 2, 4, 6, 8, 2)), row.names = c(\"Mazda RX4\",  #> \"Mazda RX4 Wag\", \"Datsun 710\", \"Hornet 4 Drive\", \"Hornet Sportabout\",  #> \"Valiant\", \"Duster 360\", \"Merc 240D\", \"Merc 230\", \"Merc 280\",  #> \"Merc 280C\", \"Merc 450SE\", \"Merc 450SL\", \"Merc 450SLC\", \"Cadillac Fleetwood\",  #> \"Lincoln Continental\", \"Chrysler Imperial\", \"Fiat 128\", \"Honda Civic\",  #> \"Toyota Corolla\", \"Toyota Corona\", \"Dodge Challenger\", \"AMC Javelin\",  #> \"Camaro Z28\", \"Pontiac Firebird\", \"Fiat X1-9\", \"Porsche 914-2\",  #> \"Lotus Europa\", \"Ford Pantera L\", \"Ferrari Dino\", \"Maserati Bora\",  #> \"Volvo 142E\"), class = \"data.frame\")) #>  #> Coefficients: #> (Intercept)          cyl   #>      -156.6         62.6   #>   # If you need finer control over the generated call, you'll need to # construct it yourself. This may require creating a new environment # with carefully constructed bindings data_env <- env(data = mtcars) eval(expr(lm(!!f, data)), data_env) #>  #> Call: #> lm(formula = disp ~ cyl, data = data) #>  #> Coefficients: #> (Intercept)          cyl   #>      -156.6         62.6   #>"},{"path":"https://rlang.r-lib.org/dev/reference/expr.html","id":null,"dir":"Reference","previous_headings":"","what":"Defuse an R expression — expr","title":"Defuse an R expression — expr","text":"expr() defuses R expression injection support. equivalent base::bquote().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/expr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Defuse an R expression — expr","text":"expr expression defuse.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/expr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Defuse an R expression — expr","text":"","code":"# R normally returns the result of an expression 1 + 1 #> [1] 2  # `expr()` defuses the expression that you have supplied and # returns it instead of its value expr(1 + 1) #> 1 + 1  expr(toupper(letters)) #> toupper(letters)  # It supports _injection_ with `!!` and `!!!`. This is a convenient # way of modifying part of an expression by injecting other # objects. var <- \"cyl\" expr(with(mtcars, mean(!!sym(var)))) #> with(mtcars, mean(cyl))  vars <- c(\"cyl\", \"am\") expr(with(mtcars, c(!!!syms(vars)))) #> with(mtcars, c(cyl, am))  # Compare to the normal way of building expressions call(\"with\", call(\"mean\", sym(var))) #> with(mean(cyl))  call(\"with\", call2(\"c\", !!!syms(vars))) #> with(c(cyl, am))"},{"path":"https://rlang.r-lib.org/dev/reference/expr_interp.html","id":null,"dir":"Reference","previous_headings":"","what":"Process unquote operators in a captured expression — expr_interp","title":"Process unquote operators in a captured expression — expr_interp","text":"expr_interp() deprecated, please use inject() instead.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/expr_interp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Process unquote operators in a captured expression — expr_interp","text":"","code":"expr_interp(x, env = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/expr_interp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Process unquote operators in a captured expression — expr_interp","text":"x, env","code":""},{"path":"https://rlang.r-lib.org/dev/reference/expr_label.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn an expression to a label — expr_label","title":"Turn an expression to a label — expr_label","text":"expr_text() turns expression single string, might multi-line. expr_name() suitable formatting names. works best symbols scalar types, also accepts calls. expr_label() formats expression nicely use messages.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/expr_label.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn an expression to a label — expr_label","text":"","code":"expr_label(expr)  expr_name(expr)  expr_text(expr, width = 60L, nlines = Inf)"},{"path":"https://rlang.r-lib.org/dev/reference/expr_label.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turn an expression to a label — expr_label","text":"expr expression labellise. width Width line. nlines Maximum number lines extract.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/expr_label.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turn an expression to a label — expr_label","text":"","code":"# To labellise a function argument, first capture it with # substitute(): fn <- function(x) expr_label(substitute(x)) fn(x:y) #> [1] \"`x:y`\"  # Strings are encoded expr_label(\"a\\nb\") #> [1] \"\\\"a\\\\nb\\\"\"  # Names and expressions are quoted with `` expr_label(quote(x)) #> [1] \"`x`\" expr_label(quote(a + b + c)) #> [1] \"`a + b + c`\"  # Long expressions are collapsed expr_label(quote(foo({   1 + 2   print(x) }))) #> [1] \"`foo(...)`\""},{"path":"https://rlang.r-lib.org/dev/reference/expr_print.html","id":null,"dir":"Reference","previous_headings":"","what":"Print an expression — expr_print","title":"Print an expression — expr_print","text":"expr_print(), powered expr_deparse(), alternative printer R expressions improvements base R printer. colourises quosures according environment. Quosures global environment printed normally quosures local environments printed unique colour (italic colours taken). wraps inlined objects angular brackets. instance, integer vector unquoted function call (e.g. expr(foo(!!(1:3)))) printed like : foo(<int: 1L, 2L, 3L>) default R prints code create vector: foo(1:3) ambiguous. respects width boundary (global option width) cases.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/expr_print.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print an expression — expr_print","text":"","code":"expr_print(x, ...)  expr_deparse(x, ..., width = peek_option(\"width\"))"},{"path":"https://rlang.r-lib.org/dev/reference/expr_print.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print an expression — expr_print","text":"x object expression print. ... Arguments passed expr_deparse(). width width deparsed printed expression. Defaults global option width.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/expr_print.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print an expression — expr_print","text":"expr_deparse() returns character vector lines. expr_print() returns input invisibly.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/expr_print.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print an expression — expr_print","text":"","code":"# It supports any object. Non-symbolic objects are always printed # within angular brackets: expr_print(1:3) #> <int: 1L, 2L, 3L> expr_print(function() NULL) #> <function() NULL>  # Contrast this to how the code to create these objects is printed: expr_print(quote(1:3)) #> 1:3 expr_print(quote(function() NULL)) #> function() NULL  # The main cause of non-symbolic objects in expressions is # quasiquotation: expr_print(expr(foo(!!(1:3)))) #> foo(<int: 1L, 2L, 3L>)   # Quosures from the global environment are printed normally: expr_print(quo(foo)) #> ^foo expr_print(quo(foo(!!quo(bar)))) #> ^foo(^bar)  # Quosures from local environments are colourised according to # their environments (if you have crayon installed): local_quo <- local(quo(foo)) expr_print(local_quo) #> ^foo  wrapper_quo <- local(quo(bar(!!local_quo, baz))) expr_print(wrapper_quo) #> ^bar(^foo, baz)"},{"path":"https://rlang.r-lib.org/dev/reference/exprs_auto_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure that all elements of a list of expressions are named — exprs_auto_name","title":"Ensure that all elements of a list of expressions are named — exprs_auto_name","text":"gives default names unnamed elements list expressions (expression wrappers formulas quosures), deparsed as_label().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/exprs_auto_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure that all elements of a list of expressions are named — exprs_auto_name","text":"","code":"exprs_auto_name(   exprs,   ...,   repair_auto = c(\"minimal\", \"unique\"),   repair_quiet = FALSE )  quos_auto_name(quos)"},{"path":"https://rlang.r-lib.org/dev/reference/exprs_auto_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Ensure that all elements of a list of expressions are named — exprs_auto_name","text":"exprs list expressions. ... dots future extensions must empty. repair_auto Whether repair automatic names. default, minimal names returned. See ?vctrs::vec_as_names information name repairing. repair_quiet Whether inform user repaired names. quos list quosures.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/f_rhs.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or set formula components — f_rhs","title":"Get or set formula components — f_rhs","text":"f_rhs extracts righthand side, f_lhs extracts lefthand side, f_env extracts environment. functions throw error f formula.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/f_rhs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or set formula components — f_rhs","text":"","code":"f_rhs(f)  f_rhs(x) <- value  f_lhs(f)  f_lhs(x) <- value  f_env(f)  f_env(x) <- value"},{"path":"https://rlang.r-lib.org/dev/reference/f_rhs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or set formula components — f_rhs","text":"f, x formula value value replace .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/f_rhs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get or set formula components — f_rhs","text":"f_rhs f_lhs return language objects (.e.  atomic vectors length 1, name, call). f_env returns environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/f_rhs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get or set formula components — f_rhs","text":"","code":"f_rhs(~ 1 + 2 + 3) #> 1 + 2 + 3 f_rhs(~ x) #> x f_rhs(~ \"A\") #> [1] \"A\" f_rhs(1 ~ 2) #> [1] 2  f_lhs(~ y) #> NULL f_lhs(x ~ y) #> x  f_env(~ x) #> <environment: 0x562dddf6cd18>"},{"path":"https://rlang.r-lib.org/dev/reference/f_text.html","id":null,"dir":"Reference","previous_headings":"","what":"Turn RHS of formula into a string or label — f_text","title":"Turn RHS of formula into a string or label — f_text","text":"Equivalent expr_text() expr_label() formulas.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/f_text.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Turn RHS of formula into a string or label — f_text","text":"","code":"f_text(x, width = 60L, nlines = Inf)  f_name(x)  f_label(x)"},{"path":"https://rlang.r-lib.org/dev/reference/f_text.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Turn RHS of formula into a string or label — f_text","text":"x formula. width Width line. nlines Maximum number lines extract.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/f_text.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Turn RHS of formula into a string or label — f_text","text":"","code":"f <- ~ a + b + bc f_text(f) #> [1] \"a + b + bc\" f_label(f) #> [1] \"`a + b + bc`\"  # Names a quoted with `` f_label(~ x) #> [1] \"`x`\" # Strings are encoded f_label(~ \"a\\nb\") #> [1] \"\\\"a\\\\nb\\\"\" # Long expressions are collapsed f_label(~ foo({   1 + 2   print(x) })) #> [1] \"`foo(...)`\""},{"path":"https://rlang.r-lib.org/dev/reference/faq-options.html","id":null,"dir":"Reference","previous_headings":"","what":"Global options for rlang — faq-options","title":"Global options for rlang — faq-options","text":"rlang several options may set globally control behavior. brief description given . functions referenced, refer documentation additional details. rlang_interactive: logical value used is_interactive(). can set TRUE test interactive behavior unit tests, example. rlang_backtrace_on_error: character string controls whether backtraces displayed error messages, level detail print. See rlang_backtrace_on_error possible option values. rlang_trace_format_srcrefs: logical value used control whether srcrefs printed part backtrace. rlang_trace_top_env: environment treated top-level environment printing traces. See trace_back() examples.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/ffi_standalone_types_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal API for standalone-types-check — ffi_standalone_types_check","title":"Internal API for standalone-types-check — ffi_standalone_types_check","text":"Internal API standalone-types-check","code":""},{"path":"https://rlang.r-lib.org/dev/reference/flatten.html","id":null,"dir":"Reference","previous_headings":"","what":"Flatten or squash a list of lists into a simpler vector — flatten","title":"Flatten or squash a list of lists into a simpler vector — flatten","text":"functions deprecated favour purrr::list_c() purrr::list_flatten(). flatten() removes one level hierarchy list, squash() removes levels. functions similar unlist() type-stable always know type output .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/flatten.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flatten or squash a list of lists into a simpler vector — flatten","text":"","code":"flatten(x)  flatten_lgl(x)  flatten_int(x)  flatten_dbl(x)  flatten_cpl(x)  flatten_chr(x)  flatten_raw(x)  squash(x)  squash_lgl(x)  squash_int(x)  squash_dbl(x)  squash_cpl(x)  squash_chr(x)  squash_raw(x)  flatten_if(x, predicate = is_spliced)  squash_if(x, predicate = is_spliced)"},{"path":"https://rlang.r-lib.org/dev/reference/flatten.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flatten or squash a list of lists into a simpler vector — flatten","text":"x list flatten squash. contents list can anything unsuffixed functions flatten() squash() (list returned), contents must match type functions. predicate function one argument returning whether spliced.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/flatten.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Flatten or squash a list of lists into a simpler vector — flatten","text":"flatten() returns list, flatten_lgl() logical vector, flatten_int() integer vector, flatten_dbl() double vector, flatten_chr() character vector. Similarly squash() typed variants (squash_lgl() etc).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/flatten.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Flatten or squash a list of lists into a simpler vector — flatten","text":"","code":"x <- replicate(2, sample(4), simplify = FALSE) x #> [[1]] #> [1] 2 1 3 4 #>  #> [[2]] #> [1] 3 4 1 2 #>   flatten(x) #> Warning: `flatten()` is deprecated as of rlang 1.1.0. #> ℹ Please use `purrr::list_flatten()` or `purrr::list_c()`. #> This warning is displayed once every 8 hours. #> [[1]] #> [1] 2 1 3 4 #>  #> [[2]] #> [1] 3 4 1 2 #>  flatten_int(x) #> Warning: `flatten_int()` is deprecated as of rlang 1.1.0. #> ℹ Please use `purrr::list_flatten()` and/or `purrr::list_c()`. #> This warning is displayed once every 8 hours. #> [1] 2 1 3 4 3 4 1 2  # With flatten(), only one level gets removed at a time: deep <- list(1, list(2, list(3))) flatten(deep) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [[3]][[1]] #> [1] 3 #>  #>  flatten(flatten(deep)) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>   # But squash() removes all levels: squash(deep) #> Warning: `squash()` is deprecated as of rlang 1.1.0. #> This warning is displayed once every 8 hours. #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>  squash_dbl(deep) #> Warning: `squash_dbl()` is deprecated as of rlang 1.1.0. #> This warning is displayed once every 8 hours. #> [1] 1 2 3  # The typed flatten functions remove one level and coerce to an atomic # vector at the same time: flatten_dbl(list(1, list(2))) #> Warning: `flatten_dbl()` is deprecated as of rlang 1.1.0. #> ℹ Please use `purrr::list_flatten()` and/or `purrr::list_c()`. #> This warning is displayed once every 8 hours. #> [1] 1 2  # Only bare lists are flattened, but you can splice S3 lists # explicitly: foo <- set_attrs(list(\"bar\"), class = \"foo\") #> Warning: `set_attrs()` is deprecated as of rlang 0.3.0 #> This warning is displayed once every 8 hours. str(flatten(list(1, foo, list(100)))) #> List of 3 #>  $ : num 1 #>  $ :List of 1 #>   ..$ : chr \"bar\" #>   ..- attr(*, \"class\")= chr \"foo\" #>  $ : num 100 str(flatten(list(1, splice(foo), list(100)))) #> List of 3 #>  $ : num 1 #>  $ : chr \"bar\" #>  $ : num 100  # Instead of splicing manually, flatten_if() and squash_if() let # you specify a predicate function: is_foo <- function(x) inherits(x, \"foo\") || is_bare_list(x) str(flatten_if(list(1, foo, list(100)), is_foo)) #> List of 3 #>  $ : num 1 #>  $ : chr \"bar\" #>  $ : num 100  # squash_if() does the same with deep lists: deep_foo <- list(1, list(foo, list(foo, 100))) str(deep_foo) #> List of 2 #>  $ : num 1 #>  $ :List of 2 #>   ..$ :List of 1 #>   .. ..$ : chr \"bar\" #>   .. ..- attr(*, \"class\")= chr \"foo\" #>   ..$ :List of 2 #>   .. ..$ :List of 1 #>   .. .. ..$ : chr \"bar\" #>   .. .. ..- attr(*, \"class\")= chr \"foo\" #>   .. ..$ : num 100  str(squash(deep_foo)) #> List of 4 #>  $ : num 1 #>  $ :List of 1 #>   ..$ : chr \"bar\" #>   ..- attr(*, \"class\")= chr \"foo\" #>  $ :List of 1 #>   ..$ : chr \"bar\" #>   ..- attr(*, \"class\")= chr \"foo\" #>  $ : num 100 str(squash_if(deep_foo, is_foo)) #> Warning: `squash_if()` is deprecated as of rlang 1.1.0. #> This warning is displayed once every 8 hours. #> List of 4 #>  $ : num 1 #>  $ : chr \"bar\" #>  $ : chr \"bar\" #>  $ : num 100"},{"path":"https://rlang.r-lib.org/dev/reference/fn_body.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or set function body — fn_body","title":"Get or set function body — fn_body","text":"fn_body() simple wrapper around base::body(). always returns \\{ expression throws error input primitive function (whereas body() returns NULL). setter version preserves attributes, unlike body<-.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/fn_body.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or set function body — fn_body","text":"","code":"fn_body(fn = caller_fn())  fn_body(fn) <- value"},{"path":"https://rlang.r-lib.org/dev/reference/fn_body.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or set function body — fn_body","text":"fn function. looked calling frame supplied. value New formals formals names fn.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/fn_body.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get or set function body — fn_body","text":"","code":"# fn_body() is like body() but always returns a block: fn <- function() do() body(fn) #> do() fn_body(fn) #> { #>     do() #> }  # It also throws an error when used on a primitive function: try(fn_body(base::list)) #> Error in fn_body(base::list) :  #>   `fn` must be an R function, not a primitive function."},{"path":"https://rlang.r-lib.org/dev/reference/fn_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the closure environment of a function — fn_env","title":"Return the closure environment of a function — fn_env","text":"Closure environments define scope functions (see env()). function call evaluated, R creates evaluation frame inherits closure environment. makes objects defined closure environment parents available code executed within function.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/fn_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the closure environment of a function — fn_env","text":"","code":"fn_env(fn)  fn_env(x) <- value"},{"path":"https://rlang.r-lib.org/dev/reference/fn_env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the closure environment of a function — fn_env","text":"fn, x function. value new closure environment function.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/fn_env.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Return the closure environment of a function — fn_env","text":"fn_env() returns closure environment fn. also assignment method set new closure environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/fn_env.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return the closure environment of a function — fn_env","text":"","code":"env <- child_env(\"base\") fn <- with_env(env, function() NULL) identical(fn_env(fn), env) #> [1] TRUE  other_env <- child_env(\"base\") fn_env(fn) <- other_env identical(fn_env(fn), other_env) #> [1] TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/fn_fmls.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract arguments from a function — fn_fmls","title":"Extract arguments from a function — fn_fmls","text":"fn_fmls() returns named list formal arguments. fn_fmls_names() returns names arguments. fn_fmls_syms() returns formals named list symbols. especially useful forwarding arguments constructed calls.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/fn_fmls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract arguments from a function — fn_fmls","text":"","code":"fn_fmls(fn = caller_fn())  fn_fmls_names(fn = caller_fn())  fn_fmls_syms(fn = caller_fn())  fn_fmls(fn) <- value  fn_fmls_names(fn) <- value"},{"path":"https://rlang.r-lib.org/dev/reference/fn_fmls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract arguments from a function — fn_fmls","text":"fn function. looked calling frame supplied. value New formals formals names fn.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/fn_fmls.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract arguments from a function — fn_fmls","text":"Unlike formals(), helpers throw error primitive functions instead returning NULL.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/fn_fmls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract arguments from a function — fn_fmls","text":"","code":"# Extract from current call: fn <- function(a = 1, b = 2) fn_fmls() fn() #> $a #> [1] 1 #>  #> $b #> [1] 2 #>   # fn_fmls_syms() makes it easy to forward arguments: call2(\"apply\", !!! fn_fmls_syms(lapply)) #> apply(X = X, FUN = FUN, ...)  # You can also change the formals: fn_fmls(fn) <- list(A = 10, B = 20) fn() #> $A #> [1] 10 #>  #> $B #> [1] 20 #>   fn_fmls_names(fn) <- c(\"foo\", \"bar\") fn() #> $foo #> [1] 10 #>  #> $bar #> [1] 20 #>"},{"path":"https://rlang.r-lib.org/dev/reference/format_error_bullets.html","id":null,"dir":"Reference","previous_headings":"","what":"Format bullets for error messages — format_error_bullets","title":"Format bullets for error messages — format_error_bullets","text":"format_error_bullets() takes character vector returns single string (empty vector input empty). elements input vector assembled list bullets, depending names: Unnamed elements unindented. act titles subtitles. Elements named \"*\" bulleted cyan \"bullet\" symbol. Elements named \"\" bulleted blue \"info\" symbol. Elements named \"x\" bulleted red \"cross\" symbol. Elements named \"v\" bulleted green \"tick\" symbol. Elements named \"!\" bulleted yellow \"warning\" symbol. Elements named \">\" bulleted \"arrow\" symbol. Elements named \" \" start indented line break. convenience, vector fully unnamed, elements formatted \"*\" bullets. bullet formatting errors follows idea sentences error messages best kept short simple. best way present information cnd_body() method error conditon bullet list simple sentences containing single clause. info cross symbols bullets provide hints interpret bullet relative general error issue, supplied cnd_header().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/format_error_bullets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format bullets for error messages — format_error_bullets","text":"","code":"format_error_bullets(x)"},{"path":"https://rlang.r-lib.org/dev/reference/format_error_bullets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format bullets for error messages — format_error_bullets","text":"x named character vector messages. Named elements prefixed corresponding bullet. Elements named single space \" \" trigger line break previous bullet.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/format_error_bullets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format bullets for error messages — format_error_bullets","text":"","code":"# All bullets writeLines(format_error_bullets(c(\"foo\", \"bar\"))) #> • foo #> • bar  # This is equivalent to writeLines(format_error_bullets(set_names(c(\"foo\", \"bar\"), \"*\"))) #> • foo #> • bar  # Supply named elements to format info, cross, and tick bullets writeLines(format_error_bullets(c(i = \"foo\", x = \"bar\", v = \"baz\", \"*\" = \"quux\"))) #> ℹ foo #> ✖ bar #> ✔ baz #> • quux  # An unnamed element breaks the line writeLines(format_error_bullets(c(i = \"foo\\nbar\"))) #> ℹ foo #> bar  # A \" \" element breaks the line within a bullet (with indentation) writeLines(format_error_bullets(c(i = \"foo\", \" \" = \"bar\"))) #> ℹ foo #>   bar"},{"path":"https://rlang.r-lib.org/dev/reference/format_error_call.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate and format a function call for use in error messages — format_error_call","title":"Validate and format a function call for use in error messages — format_error_call","text":"error_call() takes either frame environment call. input environment, error_call() acts like frame_call() additional logic, e.g. S3 methods frames local_error_call(). format_error_call() simplifies input simple call (see section ) formats result code (using cli available). Use function generate \"\" part error message stack frame call. format_error_call() first passes input error_call() fetch calls frame environments.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/format_error_call.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate and format a function call for use in error messages — format_error_call","text":"","code":"format_error_call(call)  error_call(call)"},{"path":"https://rlang.r-lib.org/dev/reference/format_error_call.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate and format a function call for use in error messages — format_error_call","text":"call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/format_error_call.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate and format a function call for use in error messages — format_error_call","text":"Either string formatted code NULL simple call generated.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/format_error_call.html","id":"details-of-formatting","dir":"Reference","previous_headings":"","what":"Details of formatting","title":"Validate and format a function call for use in error messages — format_error_call","text":"arguments function calls stripped. Complex function calls containing inlined objects return NULL. Calls preserve condition since might informative. Branches dropped. Calls operators special syntax formatted using names rather potentially confusing function form.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/format_error_call.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate and format a function call for use in error messages — format_error_call","text":"","code":"# Arguments are stripped writeLines(format_error_call(quote(foo(bar, baz)))) #> `foo()`  # Returns `NULL` with complex calls such as those that contain # inlined functions format_error_call(call2(list)) #> NULL  # Operators are formatted using their names rather than in # function call form writeLines(format_error_call(quote(1 + 2))) #> `1 + 2`"},{"path":"https://rlang.r-lib.org/dev/reference/friendly_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Format a type for error messages — friendly_type","title":"Format a type for error messages — friendly_type","text":"friendly_type() deprecated. Please use standalone-obj-type.R file instead. can import package usethis::use_standalone(\"r-lib/rlang\", \"obj-type\").","code":""},{"path":"https://rlang.r-lib.org/dev/reference/friendly_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format a type for error messages — friendly_type","text":"","code":"friendly_type(type)"},{"path":"https://rlang.r-lib.org/dev/reference/friendly_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format a type for error messages — friendly_type","text":"type type returned typeof().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/friendly_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format a type for error messages — friendly_type","text":"string prettified type, qualified indefinite article.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/get_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or set the environment of an object — get_env","title":"Get or set the environment of an object — get_env","text":"functions dispatch internally methods functions, formulas frames. called missing argument, environment current evaluation frame returned. call get_env() environment, acts identity function environment simply returned (helps simplifying code writing generic functions environments).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/get_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or set the environment of an object — get_env","text":"","code":"get_env(env, default = NULL)  set_env(env, new_env = caller_env())  env_poke_parent(env, new_env)"},{"path":"https://rlang.r-lib.org/dev/reference/get_env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or set the environment of an object — get_env","text":"env environment. default default environment case env wrap environment. NULL environment extracted, error issued. new_env environment replace env .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/get_env.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get or set the environment of an object — get_env","text":"set_env() returns modified copy side effects, env_poke_parent() operates changes environment side effect. environments uncopyable. careful change environments , e.g. parent environment function package.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/get_env.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get or set the environment of an object — get_env","text":"","code":"# Environment of closure functions: fn <- function() \"foo\" get_env(fn) #> <environment: 0x562dda92f550>  # Or of quosures or formulas: get_env(~foo) #> <environment: 0x562dda92f550> get_env(quo(foo)) #> <environment: 0x562dda92f550>   # Provide a default in case the object doesn't bundle an environment. # Let's create an unevaluated formula: f <- quote(~foo)  # The following line would fail if run because unevaluated formulas # don't bundle an environment (they didn't have the chance to # record one yet): # get_env(f)  # It is often useful to provide a default when you're writing # functions accepting formulas as input: default <- env() identical(get_env(f, default), default) #> [1] TRUE  # set_env() can be used to set the enclosure of functions and # formulas. Let's create a function with a particular environment: env <- child_env(\"base\") fn <- set_env(function() NULL, env)  # That function now has `env` as enclosure: identical(get_env(fn), env) #> [1] TRUE identical(get_env(fn), current_env()) #> [1] FALSE  # set_env() does not work by side effect. Setting a new environment # for fn has no effect on the original function: other_env <- child_env(NULL) set_env(fn, other_env) #> function ()  #> NULL #> <environment: 0x562dda594608> identical(get_env(fn), other_env) #> [1] FALSE  # Since set_env() returns a new function with a different # environment, you'll need to reassign the result: fn <- set_env(fn, other_env) identical(get_env(fn), other_env) #> [1] TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/global_entrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Entrace unexpected errors — global_entrace","title":"Entrace unexpected errors — global_entrace","text":"global_entrace() enriches base errors, warnings, messages rlang features. assigned backtrace. can configure whether display backtrace error rlang_backtrace_on_error global option. recorded last_error(), last_warnings(), last_messages(). can inspect backtraces time calling functions. Set global entracing RProfile :","code":"rlang::global_entrace()"},{"path":"https://rlang.r-lib.org/dev/reference/global_entrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Entrace unexpected errors — global_entrace","text":"","code":"global_entrace(enable = TRUE, class = c(\"error\", \"warning\", \"message\"))"},{"path":"https://rlang.r-lib.org/dev/reference/global_entrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Entrace unexpected errors — global_entrace","text":"enable Whether enable disable global handling. class character vector one several classes conditions entraced.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/global_entrace.html","id":"inside-rmarkdown-documents","dir":"Reference","previous_headings":"","what":"Inside RMarkdown documents","title":"Entrace unexpected errors — global_entrace","text":"Call global_entrace() inside RMarkdown document cause errors warnings promoted rlang conditions include backtrace. needs done separate setup chunk first error warning. useful conjunction rlang_backtrace_on_error_report rlang_backtrace_on_warning_report. get full entracing Rmd document, include setup chunk first error warning signalled.","code":"```{r setup} rlang::global_entrace() options(rlang_backtrace_on_warning_report = \"full\") options(rlang_backtrace_on_error_report = \"full\") ```"},{"path":"https://rlang.r-lib.org/dev/reference/global_entrace.html","id":"under-the-hood","dir":"Reference","previous_headings":"","what":"Under the hood","title":"Entrace unexpected errors — global_entrace","text":"R 4.0 newer, global_entrace() installs global handler globalCallingHandlers(). older R versions, entrace() set option(error = ) handler. latter method disadvantage one handler can set time. means need manually switch entrace() handlers like recover(). Also causes conflict IDE handlers (e.g. RStudio).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/global_handle.html","id":null,"dir":"Reference","previous_headings":"","what":"Register default global handlers — global_handle","title":"Register default global handlers — global_handle","text":"global_handle() sets default configuration error, warning, message handling. calls: global_entrace() enable rlang errors warnings globally. global_prompt_install() recover packageNotFoundErrors user prompt install missing package. Note time writing (R 4.1), limited situations handler works.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/global_handle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register default global handlers — global_handle","text":"","code":"global_handle(entrace = TRUE, prompt_install = TRUE)"},{"path":"https://rlang.r-lib.org/dev/reference/global_handle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register default global handlers — global_handle","text":"entrace Passed enable argument global_entrace(). prompt_install Passed enable argument global_prompt_install().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/global_prompt_install.html","id":null,"dir":"Reference","previous_headings":"","what":"Prompt user to install missing packages — global_prompt_install","title":"Prompt user to install missing packages — global_prompt_install","text":"enabled, packageNotFoundError thrown loadNamespace() cause user prompt install missing package continue without interrupting current program. similar check_installed() prompts users install required packages. uses install strategy, using pak available install.packages() otherwise.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/global_prompt_install.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prompt user to install missing packages — global_prompt_install","text":"","code":"global_prompt_install(enable = TRUE)"},{"path":"https://rlang.r-lib.org/dev/reference/global_prompt_install.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prompt user to install missing packages — global_prompt_install","text":"enable Whether enable disable global handling.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/glue-operators.html","id":null,"dir":"Reference","previous_headings":"","what":"Name injection with ","title":"Name injection with ","text":"Dynamic dots (data-masked dots dynamic default) built-support names interpolation glue package.   Inside functions, embracing argument {{ inserts expression supplied argument string. gives indication variable computation supplied argument:   See also englue() string-embrace outside dynamic dots.   Technically, \"{{\" defuses function argument, calls as_label() expression supplied argument, inserts result string.","code":"tibble::tibble(foo = 1) #> # A tibble: 1 x 1 #>     foo #>   <dbl> #> 1     1  foo <- \"name\" tibble::tibble(\"{foo}\" := 1) #> # A tibble: 1 x 1 #>    name #>   <dbl> #> 1     1 tib <- function(x) {   tibble::tibble(\"var: {{ x }}\" := x) }  tib(1 + 1) #> # A tibble: 1 x 1 #>   `var: 1 + 1` #>          <dbl> #> 1            2 g <- function(x) {   englue(\"var: {{ x }}\") }  g(1 + 1) #> [1] \"var: 1 + 1\""},{"path":"https://rlang.r-lib.org/dev/reference/glue-operators.html","id":"-and-","dir":"Reference","previous_headings":"","what":"\"{\" and \"{{\"","title":"Name injection with ","text":"glue::glue() supports \"{\", dynamic dots support \"{\" \"{{\". double brace variant similar embrace operator {{ available data-masked arguments. following example, embrace operator used glue string name result default name represents expression supplied argument:   \"{{\" meant inserting expression supplied argument function. result expression inspected used. interpolate string stored variable, use regular glue operator \"{\" instead:   Using wrong operator causes unexpected results:   Ideally, using {{ regular objects error. However technical reasons possible make distinction function arguments ordinary variables. See {{ work regular objects? information limitation.","code":"my_mean <- function(data, var) {   data %>% dplyr::summarise(\"{{ var }}\" := mean({{ var }})) }  mtcars %>% my_mean(cyl) #> # A tibble: 1 x 1 #>     cyl #>   <dbl> #> 1  6.19  mtcars %>% my_mean(cyl * am) #> # A tibble: 1 x 1 #>   `cyl * am` #>        <dbl> #> 1       2.06 my_mean <- function(data, var, name = \"mean\") {   data %>% dplyr::summarise(\"{name}\" := mean({{ var }})) }  mtcars %>% my_mean(cyl) #> # A tibble: 1 x 1 #>    mean #>   <dbl> #> 1  6.19  mtcars %>% my_mean(cyl, name = \"cyl\") #> # A tibble: 1 x 1 #>     cyl #>   <dbl> #> 1  6.19 x <- \"name\"  list2(\"{{ x }}\" := 1) #> $`\"name\"` #> [1] 1  list2(\"{x}\" := 1) #> $name #> [1] 1"},{"path":"https://rlang.r-lib.org/dev/reference/glue-operators.html","id":"allow-overriding-default-names","dir":"Reference","previous_headings":"","what":"Allow overriding default names","title":"Name injection with ","text":"implementation my_mean() previous section forces default name onto result. caller wants give different name? functions take dots, possible just supply named expression override default. function like my_mean() takes named argument need different approach. englue() becomes useful. can pull default name creation another user-facing argument like :   Now user may supply name needed:","code":"my_mean <- function(data, var, name = englue(\"{{ var }}\")) {   data %>% dplyr::summarise(\"{name}\" := mean({{ var }})) } mtcars %>% my_mean(cyl * am) #> # A tibble: 1 x 1 #>   `cyl * am` #>        <dbl> #> 1       2.06  mtcars %>% my_mean(cyl * am, name = \"mean_cyl_am\") #> # A tibble: 1 x 1 #>   mean_cyl_am #>         <dbl> #> 1        2.06"},{"path":"https://rlang.r-lib.org/dev/reference/glue-operators.html","id":"what-s-the-deal-with-","dir":"Reference","previous_headings":"","what":"What's the deal with :=?","title":"Name injection with ","text":"Name injection dynamic dots originally implemented := instead = allow complex expressions LHS:   Name-injection glue operations extension existing feature inherited interface. However, technical barrier using glue strings LHS =.","code":"x <- \"name\" list2(!!x := 1) #> $name #> [1] 1"},{"path":"https://rlang.r-lib.org/dev/reference/glue-operators.html","id":"using-glue-syntax-in-packages","dir":"Reference","previous_headings":"","what":"Using glue syntax in packages","title":"Name injection with ","text":"Since rlang depend directly glue, ensure glue installed adding Imports: section.","code":"usethis::use_package(\"glue\", \"Imports\")"},{"path":"https://rlang.r-lib.org/dev/reference/has_length.html","id":null,"dir":"Reference","previous_headings":"","what":"How long is an object? — has_length","title":"How long is an object? — has_length","text":"function common task testing length object. checks length object non-generic way: base::length() methods ignored.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/has_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"How long is an object? — has_length","text":"","code":"has_length(x, n = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/has_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"How long is an object? — has_length","text":"x R object. n specific length test x . NULL, has_length() returns TRUE x length greater zero, FALSE otherwise.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/has_length.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"How long is an object? — has_length","text":"","code":"has_length(list()) #> [1] FALSE has_length(list(), 0) #> [1] TRUE  has_length(letters) #> [1] TRUE has_length(letters, 20) #> [1] FALSE has_length(letters, 26) #> [1] TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/has_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Does an object have an element with this name? — has_name","title":"Does an object have an element with this name? — has_name","text":"function returns logical value indicates data frame another named object contains element specific name. Note has_name() works vectors. instance, environments need specialised function env_has().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/has_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does an object have an element with this name? — has_name","text":"","code":"has_name(x, name)"},{"path":"https://rlang.r-lib.org/dev/reference/has_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does an object have an element with this name? — has_name","text":"x data frame another named object name Element name(s) check","code":""},{"path":"https://rlang.r-lib.org/dev/reference/has_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Does an object have an element with this name? — has_name","text":"logical vector length name","code":""},{"path":"https://rlang.r-lib.org/dev/reference/has_name.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Does an object have an element with this name? — has_name","text":"Unnamed objects treated names empty strings. NA input gives FALSE output.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/has_name.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Does an object have an element with this name? — has_name","text":"","code":"has_name(iris, \"Species\") #> [1] TRUE has_name(mtcars, \"gears\") #> [1] FALSE"},{"path":"https://rlang.r-lib.org/dev/reference/hash.html","id":null,"dir":"Reference","previous_headings":"","what":"Hashing — hash","title":"Hashing — hash","text":"hash() hashes arbitrary R object. hash_file() hashes data contained file. generated hash guaranteed reproducible across platforms endianness using R version.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/hash.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hashing — hash","text":"","code":"hash(x)  hash_file(path)"},{"path":"https://rlang.r-lib.org/dev/reference/hash.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hashing — hash","text":"x object. path character vector paths files hashed.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/hash.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hashing — hash","text":"hash(), single character string containing hash. hash_file(), character vector containing one hash per file.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/hash.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hashing — hash","text":"hashers use XXH128 hash algorithm xxHash library, generates 128-bit hash. implemented streaming hashes, generate hash minimal extra memory usage. hash(), objects converted binary using R's native serialization tools. R >= 3.5.0, serialization version 3 used, otherwise version 2 used. See serialize() information serialization version.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/hash.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hashing — hash","text":"","code":"hash(c(1, 2, 3)) #> [1] \"702f7dd6e81ea41d26ea3b248627ece4\" hash(mtcars) #> [1] \"d0487363db4e6cc64fdb740cb6617fc0\"  authors <- file.path(R.home(\"doc\"), \"AUTHORS\") copying <- file.path(R.home(\"doc\"), \"COPYING\") hashes <- hash_file(c(authors, copying)) hashes #> [1] \"75e0b18fa50ddd8296f143c587e3eb43\" #> [2] \"cdb3a24318136e74f38209c219ca104b\"  # If you need a single hash for multiple files, # hash the result of `hash_file()` hash(hashes) #> [1] \"fb8152f9b31bfbcf4e8778c4cbc8c6b7\""},{"path":"https://rlang.r-lib.org/dev/reference/inherits_any.html","id":null,"dir":"Reference","previous_headings":"","what":"Does an object inherit from a set of classes? — inherits_any","title":"Does an object inherit from a set of classes? — inherits_any","text":"inherits_any() like base::inherits() explicit behaviour multiple classes. classes contains several elements object inherits least one , inherits_any() returns TRUE. inherits_all() tests object inherits classes supplied order. usually best way test inheritance multiple classes. inherits_only() tests class vectors identical. shortcut identical(class(x), class).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/inherits_any.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Does an object inherit from a set of classes? — inherits_any","text":"","code":"inherits_any(x, class)  inherits_all(x, class)  inherits_only(x, class)"},{"path":"https://rlang.r-lib.org/dev/reference/inherits_any.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Does an object inherit from a set of classes? — inherits_any","text":"x object test inheritance. class character vector classes.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/inherits_any.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Does an object inherit from a set of classes? — inherits_any","text":"","code":"obj <- structure(list(), class = c(\"foo\", \"bar\", \"baz\"))  # With the _any variant only one class must match: inherits_any(obj, c(\"foobar\", \"bazbaz\")) #> [1] FALSE inherits_any(obj, c(\"foo\", \"bazbaz\")) #> [1] TRUE  # With the _all variant all classes must match: inherits_all(obj, c(\"foo\", \"bazbaz\")) #> [1] FALSE inherits_all(obj, c(\"foo\", \"baz\")) #> [1] TRUE  # The order of classes must match as well: inherits_all(obj, c(\"baz\", \"foo\")) #> [1] FALSE  # inherits_only() checks that the class vectors are identical: inherits_only(obj, c(\"foo\", \"baz\")) #> [1] FALSE inherits_only(obj, c(\"foo\", \"bar\", \"baz\")) #> [1] TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/inject.html","id":null,"dir":"Reference","previous_headings":"","what":"Inject objects in an R expression — inject","title":"Inject objects in an R expression — inject","text":"inject() evaluates expression injection support. three main usages: Splicing lists arguments function call. Inline objects expressions expression !! !!!. instance create functions formulas programmatically. Pass arguments NSE functions defuse arguments without injection support (see instance enquo0()). can use {{ arg }} functions documented support quosures. Otherwise, use !!enexpr(arg).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/inject.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inject objects in an R expression — inject","text":"","code":"inject(expr, env = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/inject.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inject objects in an R expression — inject","text":"expr argument evaluate. argument immediately evaluated env (current environment default) injected objects expressions. env environment evaluate expr. Defaults current environment. expert use .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/inject.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inject objects in an R expression — inject","text":"","code":"# inject() simply evaluates its argument with injection # support. These expressions are equivalent: 2 * 3 #> [1] 6 inject(2 * 3) #> [1] 6 inject(!!2 * !!3) #> [1] 6  # Injection with `!!` can be useful to insert objects or # expressions within other expressions, like formulas: lhs <- sym(\"foo\") rhs <- sym(\"bar\") inject(!!lhs ~ !!rhs + 10) #> foo ~ bar + 10 #> <environment: 0x562ddd03e418>  # Injection with `!!!` splices lists of arguments in function # calls: args <- list(na.rm = TRUE, finite = 0.2) inject(mean(1:10, !!!args)) #> [1] 5.5"},{"path":"https://rlang.r-lib.org/dev/reference/injection-operator.html","id":null,"dir":"Reference","previous_headings":"","what":"Injection operator !! — injection-operator","title":"Injection operator !! — injection-operator","text":"injection operator !! injects value expression inside another expression. words, modifies piece code R evaluates . two main cases injection. can inject constant values work around issues scoping ambiguity, can inject defused expressions like symbolised column names.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/injection-operator.html","id":"where-does-work-","dir":"Reference","previous_headings":"","what":"Where does !! work?","title":"Injection operator !! — injection-operator","text":"!! work everywhere, can use within certain special functions: Functions taking defused data-masked arguments. Technically, means function arguments defused {{ en-prefixed operators like enquo(), enexpr(), etc. Inside inject(). data-masking verbs tidyverse support injection operators box. base functions, need use inject() enable !!. Using !! context may lead incorrect results, see happens use injection operators context?. examples built around base function (). Since tidyverse function use inject() enable !! usage.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/injection-operator.html","id":"injecting-values","dir":"Reference","previous_headings":"","what":"Injecting values","title":"Injection operator !! — injection-operator","text":"Data-masking functions like () handy can refer column names computations. comes price data mask ambiguity: defined env-variable name data-variable, get name collisions. collision always resolved giving precedence data-variable (masks env-variable):   injection operator offers one way solving . Use inject env-variable inside data-masked expression:   Note .env pronoun simpler way solving ambiguity. See data mask ambiguity .","code":"cyl <- c(100, 110) with(mtcars, mean(cyl)) #> [1] 6.1875 inject(   with(mtcars, mean(!!cyl)) ) #> [1] 105"},{"path":"https://rlang.r-lib.org/dev/reference/injection-operator.html","id":"injecting-expressions","dir":"Reference","previous_headings":"","what":"Injecting expressions","title":"Injection operator !! — injection-operator","text":"Injection also useful modifying parts defused expression. following example use symbolise--inject pattern inject column name inside data-masked expression.   Since () base function, inject quosures, naked symbols calls. problem injecting name data frame column. environment important, try injecting pre-computed value instead.","code":"var <- sym(\"cyl\") inject(   with(mtcars, mean(!!var)) ) #> [1] 6.1875"},{"path":"https://rlang.r-lib.org/dev/reference/injection-operator.html","id":"when-do-i-need-","dir":"Reference","previous_headings":"","what":"When do I need !!?","title":"Injection operator !! — injection-operator","text":"tidyverse APIs, injecting expressions !! longer common pattern. First, .env pronoun solves ambiguity problem intuitive way:   Second, embrace operator {{ makes defuse--inject pattern easier learn use.   !! good tool learn advanced applications hope needed common data analysis cases.","code":"cyl <- 100 mtcars %>% dplyr::mutate(cyl = cyl * .env$cyl) my_mean <- function(data, var) {   data %>% dplyr::summarise(mean({{ var }})) }  # Equivalent to my_mean <- function(data, var) {   data %>% dplyr::summarise(mean(!!enquo(var))) }"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/interrupt.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate interrupt condition — interrupt","title":"Simulate interrupt condition — interrupt","text":"interrupt() simulates user interrupt kind signalled Ctrl-C. currently possible create custom interrupt condition objects.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/interrupt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate interrupt condition — interrupt","text":"","code":"interrupt()"},{"path":"https://rlang.r-lib.org/dev/reference/invoke.html","id":null,"dir":"Reference","previous_headings":"","what":"Invoke a function with a list of arguments — invoke","title":"Invoke a function with a list of arguments — invoke","text":"Deprecated rlang 0.4.0 favour exec().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/invoke.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Invoke a function with a list of arguments — invoke","text":"","code":"invoke(.fn, .args = list(), ..., .env = caller_env(), .bury = c(\".fn\", \"\"))"},{"path":"https://rlang.r-lib.org/dev/reference/invoke.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Invoke a function with a list of arguments — invoke","text":".fn, args, ..., .env, .bury","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_call.html","id":null,"dir":"Reference","previous_headings":"","what":"Is object a call? — is_call","title":"Is object a call? — is_call","text":"function tests x call. pattern-matching predicate returns FALSE name n supplied call match properties.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_call.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is object a call? — is_call","text":"","code":"is_call(x, name = NULL, n = NULL, ns = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/is_call.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is object a call? — is_call","text":"x object test. Formulas quosures treated literally. name optional name call match. passed sym() matching. argument vectorised can supply vector names match. case, is_call() returns TRUE least one name matches. n optional number arguments call match. ns namespace call. NULL, namespace participate pattern-matching. empty string \"\" x namespaced call, is_call() returns FALSE. string, is_call() checks x namespaced within ns. Can character vector namespaces, case call match least one , otherwise is_call() returns FALSE.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/is_call.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is object a call? — is_call","text":"","code":"is_call(quote(foo(bar))) #> [1] TRUE  # You can pattern-match the call with additional arguments: is_call(quote(foo(bar)), \"foo\") #> [1] TRUE is_call(quote(foo(bar)), \"bar\") #> [1] FALSE is_call(quote(foo(bar)), quote(foo)) #> [1] TRUE  # Match the number of arguments with is_call(): is_call(quote(foo(bar)), \"foo\", 1) #> [1] TRUE is_call(quote(foo(bar)), \"foo\", 2) #> [1] FALSE   # By default, namespaced calls are tested unqualified: ns_expr <- quote(base::list()) is_call(ns_expr, \"list\") #> [1] TRUE  # You can also specify whether the call shouldn't be namespaced by # supplying an empty string: is_call(ns_expr, \"list\", ns = \"\") #> [1] FALSE  # Or if it should have a namespace: is_call(ns_expr, \"list\", ns = \"utils\") #> [1] FALSE is_call(ns_expr, \"list\", ns = \"base\") #> [1] TRUE  # You can supply multiple namespaces: is_call(ns_expr, \"list\", ns = c(\"utils\", \"base\")) #> [1] TRUE is_call(ns_expr, \"list\", ns = c(\"utils\", \"stats\")) #> [1] FALSE  # If one of them is \"\", unnamespaced calls will match as well: is_call(quote(list()), \"list\", ns = \"base\") #> [1] FALSE is_call(quote(list()), \"list\", ns = c(\"base\", \"\")) #> [1] TRUE is_call(quote(base::list()), \"list\", ns = c(\"base\", \"\")) #> [1] TRUE   # The name argument is vectorised so you can supply a list of names # to match with: is_call(quote(foo(bar)), c(\"bar\", \"baz\")) #> [1] FALSE is_call(quote(foo(bar)), c(\"bar\", \"foo\")) #> [1] TRUE is_call(quote(base::list), c(\"::\", \":::\", \"$\", \"@\")) #> [1] TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/is_callable.html","id":null,"dir":"Reference","previous_headings":"","what":"Is an object callable? — is_callable","title":"Is an object callable? — is_callable","text":"callable object object can appear function position call (opposed argument position). includes symbolic objects evaluate function literal functions embedded call.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_callable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is an object callable? — is_callable","text":"","code":"is_callable(x)"},{"path":"https://rlang.r-lib.org/dev/reference/is_callable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is an object callable? — is_callable","text":"x object test.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_callable.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Is an object callable? — is_callable","text":"Note strings may look like callable objects expressions form \"list\"() valid R code. However, R parser transforms strings symbols. legal manually set language heads strings.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_callable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is an object callable? — is_callable","text":"","code":"# Symbolic objects and functions are callable: is_callable(quote(foo)) #> [1] TRUE is_callable(base::identity) #> [1] TRUE  # node_poke_car() lets you modify calls without any checking: lang <- quote(foo(10)) node_poke_car(lang, current_env())  # Use is_callable() to check an input object is safe to put as CAR: obj <- base::identity  if (is_callable(obj)) {   lang <- node_poke_car(lang, obj) } else {   abort(\"`obj` must be callable\") }  eval_bare(lang) #> [1] 10"},{"path":"https://rlang.r-lib.org/dev/reference/is_condition.html","id":null,"dir":"Reference","previous_headings":"","what":"Is object a condition? — is_condition","title":"Is object a condition? — is_condition","text":"object condition?","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_condition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is object a condition? — is_condition","text":"","code":"is_condition(x)  is_error(x)  is_warning(x)  is_message(x)"},{"path":"https://rlang.r-lib.org/dev/reference/is_condition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is object a condition? — is_condition","text":"x object test.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_copyable.html","id":null,"dir":"Reference","previous_headings":"","what":"Is an object copyable? — is_copyable","title":"Is an object copyable? — is_copyable","text":"object modified, R generally copies (sometimes lazily) enforce value semantics. However, internal types uncopyable. try copy , either <- argument passing, actually create references original object rather actual copies. Modifying references can thus far reaching side effects.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_copyable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is an object copyable? — is_copyable","text":"","code":"is_copyable(x)"},{"path":"https://rlang.r-lib.org/dev/reference/is_copyable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is an object copyable? — is_copyable","text":"x object test.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_copyable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is an object copyable? — is_copyable","text":"","code":"# Let's add attributes with structure() to uncopyable types. Since # they are not copied, the attributes are changed in place: env <- env() structure(env, foo = \"bar\") #> <environment: 0x562ddca668e0> #> attr(,\"foo\") #> [1] \"bar\" env #> <environment: 0x562ddca668e0> #> attr(,\"foo\") #> [1] \"bar\"  # These objects that can only be changed with side effect are not # copyable: is_copyable(env) #> [1] FALSE"},{"path":"https://rlang.r-lib.org/dev/reference/is_dictionaryish.html","id":null,"dir":"Reference","previous_headings":"","what":"Is a vector uniquely named? — is_dictionaryish","title":"Is a vector uniquely named? — is_dictionaryish","text":"Like is_named() also checks names unique.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_dictionaryish.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is a vector uniquely named? — is_dictionaryish","text":"","code":"is_dictionaryish(x)"},{"path":"https://rlang.r-lib.org/dev/reference/is_dictionaryish.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is a vector uniquely named? — is_dictionaryish","text":"x vector.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_empty.html","id":null,"dir":"Reference","previous_headings":"","what":"Is object an empty vector or NULL? — is_empty","title":"Is object an empty vector or NULL? — is_empty","text":"object empty vector NULL?","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_empty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is object an empty vector or NULL? — is_empty","text":"","code":"is_empty(x)"},{"path":"https://rlang.r-lib.org/dev/reference/is_empty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is object an empty vector or NULL? — is_empty","text":"x object test","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_empty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is object an empty vector or NULL? — is_empty","text":"","code":"is_empty(NULL) #> [1] TRUE is_empty(list()) #> [1] TRUE is_empty(list(NULL)) #> [1] FALSE"},{"path":"https://rlang.r-lib.org/dev/reference/is_environment.html","id":null,"dir":"Reference","previous_headings":"","what":"Is object an environment? — is_environment","title":"Is object an environment? — is_environment","text":"is_bare_environment() tests whether x environment without s3 s4 class.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_environment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is object an environment? — is_environment","text":"","code":"is_environment(x)  is_bare_environment(x)"},{"path":"https://rlang.r-lib.org/dev/reference/is_environment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is object an environment? — is_environment","text":"x object test","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_expression.html","id":null,"dir":"Reference","previous_headings":"","what":"Is an object an expression? — is_expression","title":"Is an object an expression? — is_expression","text":"rlang, expression return type parse_expr(), set objects can obtained parsing R code. definition expressions include numbers, strings, NULL, symbols, function calls. objects can classified : Symbolic objects, .e. symbols function calls (is_symbolic() returns TRUE) Syntactic literals, .e. scalar atomic objects NULL (testable is_syntactic_literal()) is_expression() returns TRUE input either symbolic object syntactic literal. call, elements call must expressions well. Unparsable calls considered expressions narrow definition. Note base R, exists expression() vectors, data type similar list supports special attributes created parser called source references. data type supported rlang.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_expression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is an object an expression? — is_expression","text":"","code":"is_expression(x)  is_syntactic_literal(x)  is_symbolic(x)"},{"path":"https://rlang.r-lib.org/dev/reference/is_expression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is an object an expression? — is_expression","text":"x object test.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_expression.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Is an object an expression? — is_expression","text":"is_symbolic() returns TRUE symbols calls (objects type language). Symbolic objects replaced value evaluation. Literals complement symbolic objects. value return evaluation. is_syntactic_literal() predicate returns TRUE subset literals created R parsing text (see parse_expr()): numbers, strings NULL. Along symbols, literals terminating nodes AST. Note general sense, literal R object evaluates can evaluated empty environment. instance, quote(c(1, 2)) literal, call. However, result evaluating base_env() literal(case atomic vector). data structure function arguments, pairlists also kind language objects. However, since mostly internal data structure returned parser, is_expression() returns FALSE pairlists.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/is_expression.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is an object an expression? — is_expression","text":"","code":"q1 <- quote(1) is_expression(q1) #> [1] TRUE is_syntactic_literal(q1) #> [1] TRUE  q2 <- quote(x) is_expression(q2) #> [1] TRUE is_symbol(q2) #> [1] TRUE  q3 <- quote(x + 1) is_expression(q3) #> [1] TRUE is_call(q3) #> [1] TRUE   # Atomic expressions are the terminating nodes of a call tree: # NULL or a scalar atomic vector: is_syntactic_literal(\"string\") #> [1] TRUE is_syntactic_literal(NULL) #> [1] TRUE  is_syntactic_literal(letters) #> [1] FALSE is_syntactic_literal(quote(call())) #> [1] FALSE  # Parsable literals have the property of being self-quoting: identical(\"foo\", quote(\"foo\")) #> [1] TRUE identical(1L, quote(1L)) #> [1] TRUE identical(NULL, quote(NULL)) #> [1] TRUE  # Like any literals, they can be evaluated within the empty # environment: eval_bare(quote(1L), empty_env()) #> [1] 1  # Whereas it would fail for symbolic expressions: # eval_bare(quote(c(1L, 2L)), empty_env())   # Pairlists are also language objects representing argument lists. # You will usually encounter them with extracted formals: fmls <- formals(is_expression) typeof(fmls) #> [1] \"pairlist\"  # Since they are mostly an internal data structure, is_expression() # returns FALSE for pairlists, so you will have to check explicitly # for them: is_expression(fmls) #> [1] FALSE is_pairlist(fmls) #> [1] TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/is_formula.html","id":null,"dir":"Reference","previous_headings":"","what":"Is object a formula? — is_formula","title":"Is object a formula? — is_formula","text":"is_formula() tests whether x call ~. is_bare_formula() tests addition x inherit anything else \"formula\". Note: first implemented is_formula(), thought best treat unevaluated formulas formulas default (see section ). Now think default introduces many edge cases normal code. recommend always supplying scoped = TRUE. Unevaluated formulas can handled via is_call(x, \"~\") branch.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_formula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is object a formula? — is_formula","text":"","code":"is_formula(x, scoped = NULL, lhs = NULL)  is_bare_formula(x, scoped = TRUE, lhs = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/is_formula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is object a formula? — is_formula","text":"x object test. scoped boolean indicating whether quosure scoped, , valid environment attribute inherits \"formula\". NULL, scope inspected. lhs boolean indicating whether formula left-hand side. NULL, LHS inspected is_formula() returns TRUE one- two-sided formulas.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_formula.html","id":"dealing-with-unevaluated-formulas","dir":"Reference","previous_headings":"","what":"Dealing with unevaluated formulas","title":"Is object a formula? — is_formula","text":"parse time, formula simple call ~ class environment. evaluated, ~ call becomes properly structured formula. Unevaluated formulas arise quotation, e.g. ~~foo, quote(~foo), substitute(arg) arg supplied formula. Use scoped argument check whether formula carries environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_formula.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is object a formula? — is_formula","text":"","code":"is_formula(~10) #> [1] TRUE is_formula(10) #> [1] FALSE  # If you don't supply `lhs`, both one-sided and two-sided formulas # will return `TRUE` is_formula(disp ~ am) #> [1] TRUE is_formula(~am) #> [1] TRUE  # You can also specify whether you expect a LHS: is_formula(disp ~ am, lhs = TRUE) #> [1] TRUE is_formula(disp ~ am, lhs = FALSE) #> [1] FALSE is_formula(~am, lhs = TRUE) #> [1] FALSE is_formula(~am, lhs = FALSE) #> [1] TRUE  # Handling of unevaluated formulas is a bit tricky. These formulas # are special because they don't inherit from `\"formula\"` and they # don't carry an environment (they are not scoped): f <- quote(~foo) f_env(f) #> NULL  # By default unevaluated formulas are treated as formulas is_formula(f) #> [1] TRUE  # Supply `scoped = TRUE` to ensure you have an evaluated formula is_formula(f, scoped = TRUE) #> [1] FALSE  # By default unevaluated formulas not treated as bare formulas is_bare_formula(f) #> [1] FALSE  # If you supply `scoped = TRUE`, they will be considered bare # formulas even though they don't inherit from `\"formula\"` is_bare_formula(f, scoped = TRUE) #> [1] FALSE"},{"path":"https://rlang.r-lib.org/dev/reference/is_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Is object a function? — is_function","title":"Is object a function? — is_function","text":"R language defines two different types functions: primitive functions, low-level, closures, regular kind functions.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is object a function? — is_function","text":"","code":"is_function(x)  is_closure(x)  is_primitive(x)  is_primitive_eager(x)  is_primitive_lazy(x)"},{"path":"https://rlang.r-lib.org/dev/reference/is_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is object a function? — is_function","text":"x Object tested.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_function.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Is object a function? — is_function","text":"Closures functions written R, named way arguments scoped within nested environments (see https://en.wikipedia.org/wiki/Closure_(computer_programming)). root environment closure called closure environment. closures evaluated, new environment called evaluation frame created closure environment parent. body closure evaluated. closure frames appear evaluation stack, opposed primitive functions necessarily evaluation frame never appear stack. Primitive functions efficient closures two reasons. First, written entirely fast low-level code. Second, mechanism passed arguments efficient often need full procedure argument matching (dealing positional versus named arguments, partial matching, etc). One practical consequence special way primitives passed arguments technically formal arguments, formals() return NULL called primitive function. Finally, primitive functions can either take arguments lazily, like R closures , evaluate eagerly passed C code. former kind primitives called \"special\" R terminology, latter referred \"builtin\". is_primitive_eager() is_primitive_lazy() allow check whether primitive function evaluates arguments eagerly lazily. also encounter distinction primitive internal functions technical documentation. Like primitive functions, internal functions defined low level written C. However, internal functions representation R language. Instead, called via call base::.Internal() within regular closure. ensures appear normal R function objects: obey usual rules argument passing, appear evaluation stack closures. result, fn_fmls() need look .ArgsEnv environment obtain representation arguments, way querying R whether lazy ('special' R terminology) eager ('builtin'). can call primitive functions .Primitive() internal functions .Internal(). However, calling internal functions package forbidden CRAN's policy considered part private API. often assume called correctly formed arguments, may cause R crash call unexpected objects.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is object a function? — is_function","text":"","code":"# Primitive functions are not closures: is_closure(base::c) #> [1] FALSE is_primitive(base::c) #> [1] TRUE  # On the other hand, internal functions are wrapped in a closure # and appear as such from the R side: is_closure(base::eval) #> [1] TRUE  # Both closures and primitives are functions: is_function(base::c) #> [1] TRUE is_function(base::eval) #> [1] TRUE  # Many primitive functions evaluate arguments eagerly: is_primitive_eager(base::c) #> [1] TRUE is_primitive_eager(base::list) #> [1] TRUE is_primitive_eager(base::`+`) #> [1] TRUE  # However, primitives that operate on expressions, like quote() or # substitute(), are lazy: is_primitive_lazy(base::quote) #> [1] TRUE is_primitive_lazy(base::substitute) #> [1] TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/is_installed.html","id":null,"dir":"Reference","previous_headings":"","what":"Are packages installed in any of the libraries? — is_installed","title":"Are packages installed in any of the libraries? — is_installed","text":"functions check packages installed minimal side effects. installed, packages loaded attached. is_installed() interact user. simply returns TRUE FALSE depending whether packages installed. interactive sessions, check_installed() asks user whether install missing packages. user accepts, packages installed pak::pkg_install() available, utils::install.packages() otherwise. session non interactive user chooses install packages, current evaluation aborted. can disable prompt setting rlib_restart_package_not_found global option FALSE. case, missing packages always cause error.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_installed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Are packages installed in any of the libraries? — is_installed","text":"","code":"is_installed(pkg, ..., version = NULL, compare = NULL)  check_installed(   pkg,   reason = NULL,   ...,   version = NULL,   compare = NULL,   action = NULL,   call = caller_env() )"},{"path":"https://rlang.r-lib.org/dev/reference/is_installed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Are packages installed in any of the libraries? — is_installed","text":"pkg package names. Can include version requirements, e.g. \"pkg (>= 1.0.0)\". ... dots must empty. version Minimum versions pkg. supplied, must length pkg. NA elements stand versions. compare character vector comparison operators use version. supplied, must length version. NULL, >= used default elements. NA elements compare also set >= default. reason Optional string indicating pkg needed. Appears error messages (non-interactive) user prompts (interactive). action optional function taking pkg ... arguments. called check_installed() user chooses update outdated packages. function passed missing outdated packages character vector names. call execution environment currently running function, e.g. caller_env(). function mentioned error messages source error. See call argument abort() information.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_installed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Are packages installed in any of the libraries? — is_installed","text":"is_installed() returns TRUE package names provided pkg installed, FALSE otherwise. check_installed() either return returns NULL.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_installed.html","id":"handling-package-not-found-errors","dir":"Reference","previous_headings":"","what":"Handling package not found errors","title":"Are packages installed in any of the libraries? — is_installed","text":"check_installed() signals error conditions class rlib_error_package_not_found. error includes pkg version fields. vectorised may include several packages. error signalled rlib_restart_package_not_found restart stack allow handlers install required packages. , add calling handler rlib_error_package_not_found, install required packages, invoke restart without arguments. restarts check scratch. condition signalled non-interactive sessions, restarting case, rlib_restart_package_not_found user option set FALSE.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_installed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Are packages installed in any of the libraries? — is_installed","text":"","code":"is_installed(\"utils\") #> [1] TRUE is_installed(c(\"base\", \"ggplot5\")) #> [1] FALSE is_installed(c(\"base\", \"ggplot5\"), version = c(NA, \"5.1.0\")) #> [1] FALSE"},{"path":"https://rlang.r-lib.org/dev/reference/is_integerish.html","id":null,"dir":"Reference","previous_headings":"","what":"Is a vector integer-like? — is_integerish","title":"Is a vector integer-like? — is_integerish","text":"predicates check whether R considers number vector integer-like, according tolerance check (fact delegated C library). function adapted data analysis, see help base::.integer() examples check whole numbers. Things consider checking integer-like doubles: check can expensive whole double vector traversed checked. Large double values may integerish may still coercible integer. integers R support values 2^31 - 1 numbers stored double can much larger.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_integerish.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is a vector integer-like? — is_integerish","text":"","code":"is_integerish(x, n = NULL, finite = NULL)  is_bare_integerish(x, n = NULL, finite = NULL)  is_scalar_integerish(x, finite = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/is_integerish.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is a vector integer-like? — is_integerish","text":"x Object tested. n Expected length vector. finite Whether values vector finite. non-finite values NA, Inf, -Inf NaN. Setting something NULL can expensive whole vector needs traversed checked.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/is_integerish.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is a vector integer-like? — is_integerish","text":"","code":"is_integerish(10L) #> [1] TRUE is_integerish(10.0) #> [1] TRUE is_integerish(10.0, n = 2) #> [1] FALSE is_integerish(10.000001) #> [1] FALSE is_integerish(TRUE) #> [1] FALSE"},{"path":"https://rlang.r-lib.org/dev/reference/is_interactive.html","id":null,"dir":"Reference","previous_headings":"","what":"Is R running interactively? — is_interactive","title":"Is R running interactively? — is_interactive","text":"Like base::interactive(), is_interactive() returns TRUE function runs interactively FALSE runs batch mode. also checks, order: rlang_interactive global option. set single TRUE FALSE, is_interactive() returns value immediately. escape hatch useful unit tests manually turn interactive features RMarkdown outputs. Whether knitr testthat progress, case is_interactive() returns FALSE. with_interactive() local_interactive() set global option conveniently.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_interactive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is R running interactively? — is_interactive","text":"","code":"is_interactive()  local_interactive(value = TRUE, frame = caller_env())  with_interactive(expr, value = TRUE)"},{"path":"https://rlang.r-lib.org/dev/reference/is_interactive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is R running interactively? — is_interactive","text":"value single TRUE FALSE. overrides return value is_interactive(). frame environment running function defines scope temporary options. function returns, options reset original values. expr expression evaluate interactivity set value.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_lang.html","id":null,"dir":"Reference","previous_headings":"","what":"Is object a call? — is_lang","title":"Is object a call? — is_lang","text":"functions deprecated, please use is_call() n argument instead.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_lang.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is object a call? — is_lang","text":"","code":"is_lang(x, name = NULL, n = NULL, ns = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/is_lang.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is object a call? — is_lang","text":"x object test. Formulas quosures treated literally. name optional name call match. passed sym() matching. argument vectorised can supply vector names match. case, is_call() returns TRUE least one name matches. n optional number arguments call match. ns namespace call. NULL, namespace participate pattern-matching. empty string \"\" x namespaced call, is_call() returns FALSE. string, is_call() checks x namespaced within ns. Can character vector namespaces, case call match least one , otherwise is_call() returns FALSE.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_named.html","id":null,"dir":"Reference","previous_headings":"","what":"Is object named? — is_named","title":"Is object named? — is_named","text":"is_named() scalar predicate checks x names attribute none names missing empty (NA \"\"). is_named2() like is_named() always returns TRUE empty vectors, even names attribute. words, tests property element vector named. is_named2() composes well names2() whereas is_named() composes names(). have_name() vectorised variant.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_named.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is object named? — is_named","text":"","code":"is_named(x)  is_named2(x)  have_name(x)"},{"path":"https://rlang.r-lib.org/dev/reference/is_named.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is object named? — is_named","text":"x vector test.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_named.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is object named? — is_named","text":"is_named() is_named2() scalar predicates return TRUE FALSE. have_name() vectorised returns logical vector long input.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_named.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Is object named? — is_named","text":"is_named() always returns TRUE empty vectors ","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_named.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is object named? — is_named","text":"","code":"# is_named() is a scalar predicate about the whole vector of names: is_named(c(a = 1, b = 2)) #> [1] TRUE is_named(c(a = 1, 2)) #> [1] FALSE  # Unlike is_named2(), is_named() returns `FALSE` for empty vectors # that don't have a `names` attribute. is_named(list()) #> [1] FALSE is_named2(list()) #> [1] TRUE  # have_name() is a vectorised predicate have_name(c(a = 1, b = 2)) #> [1] TRUE TRUE have_name(c(a = 1, 2)) #> [1]  TRUE FALSE  # Empty and missing names are treated as invalid: invalid <- set_names(letters[1:5]) names(invalid)[1] <- \"\" names(invalid)[3] <- NA  is_named(invalid) #> [1] FALSE have_name(invalid) #> [1] FALSE  TRUE FALSE  TRUE  TRUE  # A data frame normally has valid, unique names is_named(mtcars) #> [1] TRUE have_name(mtcars) #>  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE  # A matrix usually doesn't because the names are stored in a # different attribute mat <- matrix(1:4, 2) colnames(mat) <- c(\"a\", \"b\") is_named(mat) #> [1] FALSE names(mat) #> NULL"},{"path":"https://rlang.r-lib.org/dev/reference/is_namespace.html","id":null,"dir":"Reference","previous_headings":"","what":"Is an object a namespace environment? — is_namespace","title":"Is an object a namespace environment? — is_namespace","text":"object namespace environment?","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_namespace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is an object a namespace environment? — is_namespace","text":"","code":"is_namespace(x)"},{"path":"https://rlang.r-lib.org/dev/reference/is_namespace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is an object a namespace environment? — is_namespace","text":"x object test.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_pairlist.html","id":null,"dir":"Reference","previous_headings":"","what":"Is object a node or pairlist? — is_pairlist","title":"Is object a node or pairlist? — is_pairlist","text":"is_pairlist() checks x type pairlist. is_node() checks x type pairlist language. tests whether x node CAR CDR, including callable nodes (language objects). is_node_list() checks x type pairlist NULL. NULL empty node list.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_pairlist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is object a node or pairlist? — is_pairlist","text":"","code":"is_pairlist(x)  is_node(x)  is_node_list(x)"},{"path":"https://rlang.r-lib.org/dev/reference/is_pairlist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is object a node or pairlist? — is_pairlist","text":"x Object test.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_pairlist.html","id":"life-cycle","dir":"Reference","previous_headings":"","what":"Life cycle","title":"Is object a node or pairlist? — is_pairlist","text":"functions experimental. still figuring good naming convention refer different lisp-like lists R.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/is_reference.html","id":null,"dir":"Reference","previous_headings":"","what":"Is an object referencing another? — is_reference","title":"Is an object referencing another? — is_reference","text":"typically two situations two symbols may refer object. R objects usually copy--write semantics. optimisation ensures objects copied needed. copy vector, memory actually copied modify either original object copy modified. Note copy--write optimisation implementation detail guaranteed specification R language. Assigning uncopyable object (like environment) creates reference. objects never copied even modify one references.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_reference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is an object referencing another? — is_reference","text":"","code":"is_reference(x, y)"},{"path":"https://rlang.r-lib.org/dev/reference/is_reference.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is an object referencing another? — is_reference","text":"x, y R objects.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_reference.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is an object referencing another? — is_reference","text":"","code":"# Reassigning an uncopyable object such as an environment creates a # reference: env <- env() ref <- env is_reference(ref, env) #> [1] TRUE  # Due to copy-on-write optimisation, a copied vector can # temporarily reference the original vector: vec <- 1:10 copy <- vec is_reference(copy, vec) #> [1] TRUE  # Once you modify on of them, the copy is triggered in the # background and the objects cease to reference each other: vec[[1]] <- 100 is_reference(copy, vec) #> [1] FALSE"},{"path":"https://rlang.r-lib.org/dev/reference/is_symbol.html","id":null,"dir":"Reference","previous_headings":"","what":"Is object a symbol? — is_symbol","title":"Is object a symbol? — is_symbol","text":"object symbol?","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_symbol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is object a symbol? — is_symbol","text":"","code":"is_symbol(x, name = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/is_symbol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is object a symbol? — is_symbol","text":"x object test. name optional name vector names symbol match.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_true.html","id":null,"dir":"Reference","previous_headings":"","what":"Is object identical to TRUE or FALSE? — is_true","title":"Is object identical to TRUE or FALSE? — is_true","text":"functions bypass R's automatic conversion rules check x literally TRUE FALSE.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_true.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is object identical to TRUE or FALSE? — is_true","text":"","code":"is_true(x)  is_false(x)"},{"path":"https://rlang.r-lib.org/dev/reference/is_true.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is object identical to TRUE or FALSE? — is_true","text":"x object test","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_true.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is object identical to TRUE or FALSE? — is_true","text":"","code":"is_true(TRUE) #> [1] TRUE is_true(1) #> [1] FALSE  is_false(FALSE) #> [1] TRUE is_false(0) #> [1] FALSE"},{"path":"https://rlang.r-lib.org/dev/reference/is_weakref.html","id":null,"dir":"Reference","previous_headings":"","what":"Is object a weak reference? — is_weakref","title":"Is object a weak reference? — is_weakref","text":"object weak reference?","code":""},{"path":"https://rlang.r-lib.org/dev/reference/is_weakref.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is object a weak reference? — is_weakref","text":"","code":"is_weakref(x)"},{"path":"https://rlang.r-lib.org/dev/reference/is_weakref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is object a weak reference? — is_weakref","text":"x object test.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/lang.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a call — lang","title":"Create a call — lang","text":"functions deprecated, please use call2() new_call() instead.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/lang.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a call — lang","text":"","code":"lang(.fn, ..., .ns = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/lang.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a call — lang","text":".fn Function call. Must callable object: string, symbol, call, function. ... <dynamic> Arguments function call. Empty arguments preserved. .ns Namespace prefix .fn. Must string symbol.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/last_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Last abort() error — last_error","title":"Last abort() error — last_error","text":"last_error() returns last error entraced abort() global_entrace(). error printed backtrace simplified form. last_trace() shortcut return backtrace stored last error. backtrace printed full form.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/last_error.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Last abort() error — last_error","text":"","code":"last_error()  last_trace(drop = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/last_error.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Last abort() error — last_error","text":"drop Whether drop technical calls. hidden users default, set drop FALSE see full backtrace.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/last_warnings.html","id":null,"dir":"Reference","previous_headings":"","what":"Display last messages and warnings — last_warnings","title":"Display last messages and warnings — last_warnings","text":"last_warnings() last_messages() return list warnings messages occurred last R command. global_entrace() must active order log messages warnings. default warnings messages printed simplified backtrace, like last_error(). Use summary() print conditions full backtrace.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/last_warnings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display last messages and warnings — last_warnings","text":"","code":"last_warnings(n = NULL)  last_messages(n = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/last_warnings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display last messages and warnings — last_warnings","text":"n many warnings messages display. Defaults .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/last_warnings.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display last messages and warnings — last_warnings","text":"Enable backtrace capture global_entrace():   Signal warnings nested functions. warnings inform function emitted warning provide information call stack:   Call last_warnings() see backtraces warnings:   works similarly messages:","code":"global_entrace() f <- function() { warning(\"foo\"); g() } g <- function() { warning(\"bar\", immediate. = TRUE); h() } h <- function() warning(\"baz\")  f() #> Warning in g() : bar #> Warning messages: #> 1: In f() : foo #> 2: In h() : baz last_warnings() #> [[1]] #> <warning/rlang_warning> #> Warning in `f()`: #> foo #> Backtrace: #>     x #>  1. \\-global f() #> #> [[2]] #> <warning/rlang_warning> #> Warning in `g()`: #> bar #> Backtrace: #>     x #>  1. \\-global f() #>  2.   \\-global g() #> #> [[3]] #> <warning/rlang_warning> #> Warning in `h()`: #> baz #> Backtrace: #>     x #>  1. \\-global f() #>  2.   \\-global g() #>  3.     \\-global h() f <- function() { inform(\"Hey!\"); g() } g <- function() { inform(\"Hi!\"); h() } h <- function() inform(\"Hello!\")  f() #> Hey! #> Hi! #> Hello!  rlang::last_messages() #> [[1]] #> <message/rlang_message> #> Message: #> Hey! #> --- #> Backtrace: #>     x #>  1. \\-global f() #> #> [[2]] #> <message/rlang_message> #> Message: #> Hi! #> --- #> Backtrace: #>     x #>  1. \\-global f() #>  2.   \\-global g() #> #> [[3]] #> <message/rlang_message> #> Message: #> Hello! #> --- #> Backtrace: #>     x #>  1. \\-global f() #>  2.   \\-global g() #>  3.     \\-global h()"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/list2.html","id":null,"dir":"Reference","previous_headings":"","what":"Collect dynamic dots in a list — list2","title":"Collect dynamic dots in a list — list2","text":"list2(...) equivalent list(...) additional features, collectively called dynamic dots. list2() hard-code features, dots_list() lower-level version offers control.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/list2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collect dynamic dots in a list — list2","text":"","code":"list2(...)  dots_list(   ...,   .named = FALSE,   .ignore_empty = c(\"trailing\", \"none\", \"all\"),   .preserve_empty = FALSE,   .homonyms = c(\"keep\", \"first\", \"last\", \"error\"),   .check_assign = FALSE )"},{"path":"https://rlang.r-lib.org/dev/reference/list2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collect dynamic dots in a list — list2","text":"... Arguments collect list. dots dynamic. .named TRUE, unnamed inputs automatically named as_label(). equivalent applying exprs_auto_name() result. FALSE, unnamed elements left , fully unnamed, list given minimal names (vector \"\"). NULL, fully unnamed results left NULL names. .ignore_empty Whether ignore empty arguments. Can one \"trailing\", \"none\", \"\". \"trailing\", last argument ignored empty. .preserve_empty Whether preserve empty arguments ignored. TRUE, empty arguments stored missing_arg() values. FALSE (default) error thrown empty argument detected. .homonyms treat arguments name. default, \"keep\", preserves arguments. Set .homonyms \"first\" keep first occurrences, \"last\" keep last occurrences, \"error\" raise informative error indicate arguments duplicated names. .check_assign Whether check <- calls. TRUE warning recommends users use = meant match function parameter wrap <- call curly braces otherwise. ensures assignments explicit.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/list2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collect dynamic dots in a list — list2","text":"list containing ... inputs.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/list2.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Collect dynamic dots in a list — list2","text":"historical reasons, dots_list() creates named list default. comparison list2() implements preferred behaviour creating names vector name supplied.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/list2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collect dynamic dots in a list — list2","text":"","code":"# Let's create a function that takes a variable number of arguments: numeric <- function(...) {   dots <- list2(...)   num <- as.numeric(dots)   set_names(num, names(dots)) } numeric(1, 2, 3) #> [1] 1 2 3  # The main difference with list(...) is that list2(...) enables # the `!!!` syntax to splice lists: x <- list(2, 3) numeric(1, !!! x, 4) #> [1] 1 2 3 4  # As well as unquoting of names: nm <- \"yup!\" numeric(!!nm := 1) #> yup!  #>    1    # One useful application of splicing is to work around exact and # partial matching of arguments. Let's create a function taking # named arguments and dots: fn <- function(data, ...) {   list2(...) }  # You normally cannot pass an argument named `data` through the dots # as it will match `fn`'s `data` argument. The splicing syntax # provides a workaround: fn(\"wrong!\", data = letters)  # exact matching of `data` #> [[1]] #> [1] \"wrong!\" #>  fn(\"wrong!\", dat = letters)   # partial matching of `data` #> [[1]] #> [1] \"wrong!\" #>  fn(some_data, !!!list(data = letters))  # no matching #> $data #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" #> [17] \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>   # Empty trailing arguments are allowed: list2(1, ) #> [[1]] #> [1] 1 #>   # But non-trailing empty arguments cause an error: try(list2(1, , )) #> Error in list2(1, , ) : Argument 2 can't be empty.  # Use the more configurable `dots_list()` function to preserve all # empty arguments: list3 <- function(...) dots_list(..., .preserve_empty = TRUE)  # Note how the last empty argument is still ignored because # `.ignore_empty` defaults to \"trailing\": list3(1, , ) #> [[1]] #> [1] 1 #>  #> [[2]] #>  #>   # The list with preserved empty arguments is equivalent to: list(1, missing_arg()) #> [[1]] #> [1] 1 #>  #> [[2]] #>  #>    # Arguments with duplicated names are kept by default: list2(a = 1, a = 2, b = 3, b = 4, 5, 6) #> $a #> [1] 1 #>  #> $a #> [1] 2 #>  #> $b #> [1] 3 #>  #> $b #> [1] 4 #>  #> [[5]] #> [1] 5 #>  #> [[6]] #> [1] 6 #>   # Use the `.homonyms` argument to keep only the first of these: dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"first\") #> $a #> [1] 1 #>  #> $b #> [1] 3 #>  #> [[3]] #> [1] 5 #>  #> [[4]] #> [1] 6 #>   # Or the last: dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"last\") #> $a #> [1] 2 #>  #> $b #> [1] 4 #>  #> [[3]] #> [1] 5 #>  #> [[4]] #> [1] 6 #>   # Or raise an informative error: try(dots_list(a = 1, a = 2, b = 3, b = 4, 5, 6, .homonyms = \"error\")) #> Error in eval(expr, envir) :  #>   Arguments in `...` must have unique names. #> ✖ Multiple arguments named `a` at positions 1 and 2. #> ✖ Multiple arguments named `b` at positions 3 and 4.   # dots_list() can be configured to warn when a `<-` call is # detected: my_list <- function(...) dots_list(..., .check_assign = TRUE) my_list(a <- 1) #> Warning: Using `<-` as argument is often a mistake. #> Do you need to use `=` to match an argument? #>  #> If you really want to use `<-`, please wrap in braces: #>  #>   # Bad: #>   fn(a <- 1) #>  #>   # Good: #>   fn(a = 1)       # Match 1 to parameter `a` #>   fn({ a <- 1 })  # Assign 1 to variable `a` #> [[1]] #> [1] 1 #>   # There is no warning if the assignment is wrapped in braces. # This requires users to be explicit about their intent: my_list({ a <- 1 }) #> [[1]] #> [1] 1 #>"},{"path":"https://rlang.r-lib.org/dev/reference/local_bindings.html","id":null,"dir":"Reference","previous_headings":"","what":"Temporarily change bindings of an environment — local_bindings","title":"Temporarily change bindings of an environment — local_bindings","text":"local_bindings() temporarily changes bindings .env (default caller environment). bindings reset original values current frame (arbitrary one specify .frame) goes scope. with_bindings() evaluates expr temporary bindings. with_bindings() returns, bindings reset original values. simple wrapper around local_bindings().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/local_bindings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Temporarily change bindings of an environment — local_bindings","text":"","code":"local_bindings(..., .env = .frame, .frame = caller_env())  with_bindings(.expr, ..., .env = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/local_bindings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Temporarily change bindings of an environment — local_bindings","text":"... Pairs names values. dots support splicing (value semantics) name unquoting. .env environment. .frame frame environment determines scope temporary bindings. frame popped call stack, bindings switched back original values. .expr expression evaluate temporary bindings.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/local_bindings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Temporarily change bindings of an environment — local_bindings","text":"local_bindings() returns values old bindings invisibly; with_bindings() returns value expr.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/local_bindings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Temporarily change bindings of an environment — local_bindings","text":"","code":"foo <- \"foo\" bar <- \"bar\"  # `foo` will be temporarily rebinded while executing `expr` with_bindings(paste(foo, bar), foo = \"rebinded\") #> [1] \"rebinded bar\" paste(foo, bar) #> [1] \"foo bar\""},{"path":"https://rlang.r-lib.org/dev/reference/local_error_call.html","id":null,"dir":"Reference","previous_headings":"","what":"Set local error call in an execution environment — local_error_call","title":"Set local error call in an execution environment — local_error_call","text":"local_error_call() alternative explicitly passing call argument abort(). sets call (value indicates find call, see ) local binding automatically picked abort().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/local_error_call.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set local error call in an execution environment — local_error_call","text":"","code":"local_error_call(call, frame = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/local_error_call.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set local error call in an execution environment — local_error_call","text":"call can : call used context error thrown execution environment. NULL value show context. execution environment, e.g. returned caller_env(). sys.call() environment taken context. frame execution environment set local error call.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/local_error_call.html","id":"motivation-for-setting-local-error-calls","dir":"Reference","previous_headings":"","what":"Motivation for setting local error calls","title":"Set local error call in an execution environment — local_error_call","text":"default abort() uses function call caller context error messages:   always appropriate. example function checks input behalf another function reference latter, former:   mismatch clear example . arg_check() x argument confusing present arg_check() relevant context failure x argument. One way around take call error_call argument pass abort(). name argument error_call consistency error_arg prefixed existing arg argument. situations, taking arg call arguments might appropriate.   generally recommended pattern argument checking functions. mention argument error message, provide callers way supply different argument name different error call. abort() stores error call call condition field used generate \"\" part error messages. complex cases often burdensome pass relevant call around, instance checking throwing code structured many different functions. case, use local_error_call() set call locally instruct abort() climb call stack one level find relevant call. following example, complexity important sparing argument passing makes big difference. However illustrates pattern:","code":"foo <- function() abort(\"Uh oh.\") foo() #> Error in `foo()`: Uh oh. arg_check <- function(arg,                       error_arg = as_string(substitute(arg))) {   abort(cli::format_error(\"{.arg {error_arg}} is failing.\")) }  foo <- function(x) arg_check(x) foo() #> Error in `arg_check()`: `x` is failing. arg_check <- function(arg,                       error_arg = as_string(substitute(arg)),                       error_call = caller_env()) {   abort(     cli::format_error(\"{.arg {error_arg}} is failing.\"),     call = error_call   ) }  foo <- function(x) arg_check(x) foo() #> Error in `foo()`: `x` is failing. arg_check <- function(arg,                       error_arg = caller_arg(arg),                       error_call = caller_env()) {   # Set the local error call   local_error_call(error_call)    my_classed_stop(     cli::format_error(\"{.arg {error_arg}} is failing.\")   ) }  my_classed_stop <- function(message) {   # Forward the local error call to the caller's   local_error_call(caller_env())    abort(message, class = \"my_class\") }  foo <- function(x) arg_check(x) foo() #> Error in `foo()`: `x` is failing."},{"path":"https://rlang.r-lib.org/dev/reference/local_error_call.html","id":"error-call-flags-in-performance-critical-functions","dir":"Reference","previous_headings":"","what":"Error call flags in performance-critical functions","title":"Set local error call in an execution environment — local_error_call","text":"call argument can also string \"caller\". equivalent caller_env() parent.frame() lower overhead call stack introspection performed error triggered. Note eagerly calling caller_env() fast enough almost cases. function needs really fast, assign error call flag directly instead calling local_error_call():","code":".__error_call__. <- \"caller\""},{"path":"https://rlang.r-lib.org/dev/reference/local_error_call.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set local error call in an execution environment — local_error_call","text":"","code":"# Set a context for error messages function() {   local_error_call(quote(foo()))   local_error_call(sys.call()) } #> function ()  #> { #>     local_error_call(quote(foo())) #>     local_error_call(sys.call()) #> } #> <environment: 0x562ddc81ec98>  # Disable the context function() {   local_error_call(NULL) } #> function ()  #> { #>     local_error_call(NULL) #> } #> <environment: 0x562ddc81ec98>  # Use the caller's context function() {   local_error_call(caller_env()) } #> function ()  #> { #>     local_error_call(caller_env()) #> } #> <environment: 0x562ddc81ec98>"},{"path":"https://rlang.r-lib.org/dev/reference/local_options.html","id":null,"dir":"Reference","previous_headings":"","what":"Change global options — local_options","title":"Change global options — local_options","text":"local_options() changes options duration stack frame (default current one). Options set back old values frame returns. with_options() changes options expression evaluated. Options restored expression returns. push_options() adds changes options permanently. peek_option() peek_options() return option values. former returns option directly latter returns list.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/local_options.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change global options — local_options","text":"","code":"local_options(..., .frame = caller_env())  with_options(.expr, ...)  push_options(...)  peek_options(...)  peek_option(name)"},{"path":"https://rlang.r-lib.org/dev/reference/local_options.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change global options — local_options","text":"... local_options() push_options(), named values defining new option values. peek_options(), strings character vectors option names. .frame environment stack frame defines scope temporary options. frame returns, options set back original values. .expr expression evaluate temporary options. name option name string.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/local_options.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Change global options — local_options","text":"local_options() push_options(), old option values. peek_option() returns current value option plural peek_options() returns list current option values.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/local_options.html","id":"life-cycle","dir":"Reference","previous_headings":"","what":"Life cycle","title":"Change global options — local_options","text":"functions experimental.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/local_options.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Change global options — local_options","text":"","code":"# Store and retrieve a global option: push_options(my_option = 10) peek_option(\"my_option\") #> [1] 10  # Change the option temporarily: with_options(my_option = 100, peek_option(\"my_option\")) #> [1] 100 peek_option(\"my_option\") #> [1] 10  # The scoped variant is useful within functions: fn <- function() {   local_options(my_option = 100)   peek_option(\"my_option\") } fn() #> [1] 100 peek_option(\"my_option\") #> [1] 10  # The plural peek returns a named list: peek_options(\"my_option\") #> $my_option #> [1] 10 #>  peek_options(\"my_option\", \"digits\") #> $my_option #> [1] 10 #>  #> $digits #> [1] 7 #>"},{"path":"https://rlang.r-lib.org/dev/reference/local_use_cli.html","id":null,"dir":"Reference","previous_headings":"","what":"Use cli to format error messages — local_use_cli","title":"Use cli to format error messages — local_use_cli","text":"local_use_cli() marks package namespace environment running function special flag instructs abort() use cli format error messages. formatting happens lazily, print-time, various places: unexpected error displayed user. captured error printed console, instance via last_error(). conditionMessage() called. cli formats messages bullets indentation width-wrapping produce polished display messages.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/local_use_cli.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use cli to format error messages — local_use_cli","text":"","code":"local_use_cli(..., format = TRUE, inline = FALSE, frame = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/local_use_cli.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Use cli to format error messages — local_use_cli","text":"... dots future extensions must empty. format Whether use cli print-time format messages bullets. inline Whether use cli throw-time format inline parts message. makes possible use cli interpolation formatting abort(). frame package namespace environment running function.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/local_use_cli.html","id":"usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Use cli to format error messages — local_use_cli","text":"use cli formatting automatically package: Make sure run_on_load() called .onLoad() hook. Call on_load(local_use_cli()) top level namespace. also possible call local_use_cli() inside running function, case flag applies within function.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/missing.html","id":null,"dir":"Reference","previous_headings":"","what":"Missing values — missing","title":"Missing values — missing","text":"Missing values represented R general symbol NA. can inserted almost data containers: atomic vectors except raw vectors can contain missing values. achieve , R automatically converts general NA symbol typed missing value appropriate target vector. objects provided aliases typed NA objects.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/missing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Missing values — missing","text":"","code":"na_lgl  na_int  na_dbl  na_chr  na_cpl"},{"path":"https://rlang.r-lib.org/dev/reference/missing.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Missing values — missing","text":"object class logical length 1. object class integer length 1. object class numeric length 1. object class character length 1. object class complex length 1.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/missing.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Missing values — missing","text":"Typed missing values necessary R needs sentinel values type (.e. machine representation data) containers inserted. official typed missing values NA_integer_, NA_real_, NA_character_ NA_complex_. missing value logical vectors simply default NA. aliases provided rlang consistently named thus simpler remember. Also, na_lgl provided alias NA makes intent clearer. Since na_lgl default NA, expressions c(NA, NA) yield logical vectors data available give clue target type. way, since lists environments can contain types, expressions like list(NA) store logical NA.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/missing.html","id":"life-cycle","dir":"Reference","previous_headings":"","what":"Life cycle","title":"Missing values — missing","text":"shortcuts might moved vctrs package point. marked questioning.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/missing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Missing values — missing","text":"","code":"typeof(NA) #> [1] \"logical\" typeof(na_lgl) #> [1] \"logical\" typeof(na_int) #> [1] \"integer\"  # Note that while the base R missing symbols cannot be overwritten, # that's not the case for rlang's aliases: na_dbl <- NA typeof(na_dbl) #> [1] \"logical\""},{"path":"https://rlang.r-lib.org/dev/reference/missing_arg.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate or handle a missing argument — missing_arg","title":"Generate or handle a missing argument — missing_arg","text":"functions help using missing argument regular R object. missing_arg() generates missing argument. is_missing() like base::missing() also supports testing missing arguments contained objects like lists. also consistent default arguments never treated missing (see section ). maybe_missing() useful pass input might missing another function, potentially substituting default value. avoids triggering \"argument missing\" error.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/missing_arg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate or handle a missing argument — missing_arg","text":"","code":"missing_arg()  is_missing(x)  maybe_missing(x, default = missing_arg())"},{"path":"https://rlang.r-lib.org/dev/reference/missing_arg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate or handle a missing argument — missing_arg","text":"x object might missing argument. default object return input missing, defaults missing_arg().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/missing_arg.html","id":"other-ways-to-reify-the-missing-argument","dir":"Reference","previous_headings":"","what":"Other ways to reify the missing argument","title":"Generate or handle a missing argument — missing_arg","text":"base::quote(expr = ) canonical way create missing argument object. expr() called without argument creates missing argument. quo() called without argument creates empty quosure, .e. quosure containing missing argument object.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/missing_arg.html","id":"is-missing-and-default-arguments","dir":"Reference","previous_headings":"","what":"is_missing() and default arguments","title":"Generate or handle a missing argument — missing_arg","text":"base function missing() makes distinction default values supplied explicitly default values generated missing argument:   happens within function. default value generated calling function, never treated missing:   rlang::is_missing() simplifies rules never treating default arguments missing, even internal contexts:   little less flexible specialise behaviour based implicitly supplied default values. However, makes behaviour is_missing() functions using simpler understand.","code":"fn <- function(x = 1) base::missing(x)  fn() #> [1] TRUE fn(1) #> [1] FALSE caller <- function(x = 1) fn(x) caller() #> [1] FALSE fn <- function(x = 1) rlang::is_missing(x)  fn() #> [1] FALSE fn(1) #> [1] FALSE"},{"path":"https://rlang.r-lib.org/dev/reference/missing_arg.html","id":"fragility-of-the-missing-argument-object","dir":"Reference","previous_headings":"","what":"Fragility of the missing argument object","title":"Generate or handle a missing argument — missing_arg","text":"missing argument object triggers error result evaluating symbol. error produced function call evaluates missing argument object. instance, possible bind missing argument variable expression like x[[1]] <- missing_arg(). Likewise, x[[1]] safe use argument, e.g. list(x[[1]]) even result missing object. However, soon missing argument passed functions bare variable, likely cause missing argument error:   work around , is_missing() maybe_missing(x) use bit magic determine input missing argument without triggering missing error.   maybe_missing() particularly useful prototyping meta-programming algorithms R. missing argument likely input computing language standard object formals lists. C functions always allowed return missing argument pass C functions, case R side. implementing meta-programming algorithm R, use maybe_missing() input might missing argument object.","code":"x <- missing_arg() list(x) #> Error: #> ! argument \"x\" is missing, with no default x <- missing_arg() list(maybe_missing(x)) #> [[1]] #>"},{"path":"https://rlang.r-lib.org/dev/reference/missing_arg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate or handle a missing argument — missing_arg","text":"","code":"# The missing argument usually arises inside a function when the # user omits an argument that does not have a default: fn <- function(x) is_missing(x) fn() #> [1] TRUE  # Creating a missing argument can also be useful to generate calls args <- list(1, missing_arg(), 3, missing_arg()) quo(fn(!!! args)) #> <quosure> #> expr: ^fn(1, , 3, ) #> env:  0x562ddee7fb58  # Other ways to create that object include: quote(expr = ) #>  expr() #>   # It is perfectly valid to generate and assign the missing # argument in a list. x <- missing_arg() l <- list(missing_arg())  # Just don't evaluate a symbol that contains the empty argument. # Evaluating the object `x` that we created above would trigger an # error. # x  # Not run  # On the other hand accessing a missing argument contained in a # list does not trigger an error because subsetting is a function # call: l[[1]] #>  is.null(l[[1]]) #> [1] FALSE  # In case you really need to access a symbol that might contain the # empty argument object, use maybe_missing(): maybe_missing(x) #>  is.null(maybe_missing(x)) #> [1] FALSE is_missing(maybe_missing(x)) #> [1] TRUE   # Note that base::missing() only works on symbols and does not # support complex expressions. For this reason the following lines # would throw an error:  #> missing(missing_arg()) #> missing(l[[1]])  # while is_missing() will work as expected: is_missing(missing_arg()) #> [1] TRUE is_missing(l[[1]]) #> [1] TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/names2.html","id":null,"dir":"Reference","previous_headings":"","what":"Get names of a vector — names2","title":"Get names of a vector — names2","text":"names2() always returns character vector, even object names attribute. case, returns vector empty names \"\". also standardises missing names \"\". replacement variant names2<- never adds NA names instead fills unnamed vectors \"\".","code":""},{"path":"https://rlang.r-lib.org/dev/reference/names2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get names of a vector — names2","text":"","code":"names2(x)  names2(x) <- value"},{"path":"https://rlang.r-lib.org/dev/reference/names2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get names of a vector — names2","text":"x vector. value New names.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/names2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get names of a vector — names2","text":"","code":"names2(letters) #>  [1] \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" \"\" #> [23] \"\" \"\" \"\" \"\"  # It also takes care of standardising missing names: x <- set_names(1:3, c(\"a\", NA, \"b\")) names2(x) #> [1] \"a\" \"\"  \"b\"  # Replacing names with the base `names<-` function may introduce # `NA` values when the vector is unnamed: x <- 1:3 names(x)[1:2] <- \"foo\" names(x) #> [1] \"foo\" \"foo\" NA     # Use the `names2<-` variant to avoid this x <- 1:3 names2(x)[1:2] <- \"foo\" names(x) #> [1] \"foo\" \"foo\" \"\""},{"path":"https://rlang.r-lib.org/dev/reference/names_inform_repair.html","id":null,"dir":"Reference","previous_headings":"","what":"Inform about name repair — names_inform_repair","title":"Inform about name repair — names_inform_repair","text":"Inform name repair","code":""},{"path":"https://rlang.r-lib.org/dev/reference/names_inform_repair.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inform about name repair — names_inform_repair","text":"","code":"names_inform_repair(old, new)"},{"path":"https://rlang.r-lib.org/dev/reference/names_inform_repair.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inform about name repair — names_inform_repair","text":"old Original names vector. new Repaired names vector.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/names_inform_repair.html","id":"muffling-and-silencing-messages","dir":"Reference","previous_headings":"","what":"Muffling and silencing messages","title":"Inform about name repair — names_inform_repair","text":"Name repair messages signaled inform() given class \"rlib_message_name_repair\". messages can muffled base::suppressMessages(). Name repair messages can also silenced global option rlib_name_repair_verbosity. option takes values: \"verbose\": Always verbose. \"quiet\": Always quiet. set quiet, message displayed condition signaled. particularly useful silencing messages testing combined local_options().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new-vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Create vectors matching a given length — new-vector","title":"Create vectors matching a given length — new-vector","text":"functions construct vectors given length, attributes specified via dots. Except new_list() new_raw(), empty vectors filled typed missing values. contrast base function base::vector() creates zero-filled vectors.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new-vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create vectors matching a given length — new-vector","text":"","code":"new_logical(n, names = NULL)  new_integer(n, names = NULL)  new_double(n, names = NULL)  new_character(n, names = NULL)  new_complex(n, names = NULL)  new_raw(n, names = NULL)  new_list(n, names = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/new-vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create vectors matching a given length — new-vector","text":"n vector length. names Names new vector.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new-vector.html","id":"lifecycle","dir":"Reference","previous_headings":"","what":"Lifecycle","title":"Create vectors matching a given length — new-vector","text":"functions likely replaced vctrs equivalent future. questioning lifecycle stage.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/new-vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create vectors matching a given length — new-vector","text":"","code":"new_list(10) #> [[1]] #> NULL #>  #> [[2]] #> NULL #>  #> [[3]] #> NULL #>  #> [[4]] #> NULL #>  #> [[5]] #> NULL #>  #> [[6]] #> NULL #>  #> [[7]] #> NULL #>  #> [[8]] #> NULL #>  #> [[9]] #> NULL #>  #> [[10]] #> NULL #>  new_logical(10) #>  [1] NA NA NA NA NA NA NA NA NA NA"},{"path":"https://rlang.r-lib.org/dev/reference/new_call.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new call from components — new_call","title":"Create a new call from components — new_call","text":"Create new call components","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new_call.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new call from components — new_call","text":"","code":"new_call(car, cdr = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/new_call.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new call from components — new_call","text":"car head call. callable object: symbol, call, literal function. cdr tail call, .e. pairlist arguments.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new_formula.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a formula — new_formula","title":"Create a formula — new_formula","text":"Create formula","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new_formula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a formula — new_formula","text":"","code":"new_formula(lhs, rhs, env = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/new_formula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a formula — new_formula","text":"lhs, rhs call, name, atomic vector. env environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new_formula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a formula — new_formula","text":"formula object.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/new_formula.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a formula — new_formula","text":"","code":"new_formula(quote(a), quote(b)) #> a ~ b #> <environment: 0x562dddb4d8a0> new_formula(NULL, quote(b)) #> ~b #> <environment: 0x562dddb4d8a0>"},{"path":"https://rlang.r-lib.org/dev/reference/new_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a function — new_function","title":"Create a function — new_function","text":"constructs new function given three components: list arguments, body code parent environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a function — new_function","text":"","code":"new_function(args, body, env = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/new_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a function — new_function","text":"args named list pairlist default arguments. Note want arguments defaults, need use special function pairlist2(). need quoted defaults, use exprs(). body language object representing code inside function. Usually easily generated base::quote() env parent environment function, defaults calling environment new_function()","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a function — new_function","text":"","code":"f <- function() letters g <- new_function(NULL, quote(letters)) identical(f, g) #> [1] TRUE  # Pass a list or pairlist of named arguments to create a function # with parameters. The name becomes the parameter name and the # argument the default value for this parameter: new_function(list(x = 10), quote(x)) #> function (x = 10)  #> x #> <environment: 0x562dde05f5b0> new_function(pairlist2(x = 10), quote(x)) #> function (x = 10)  #> x #> <environment: 0x562dde05f5b0>  # Use `exprs()` to create quoted defaults. Compare: new_function(pairlist2(x = 5 + 5), quote(x)) #> function (x = 10)  #> x #> <environment: 0x562dde05f5b0> new_function(exprs(x = 5 + 5), quote(x)) #> function (x = 5 + 5)  #> x #> <environment: 0x562dde05f5b0>  # Pass empty arguments to omit defaults. `list()` doesn't allow # empty arguments but `pairlist2()` does: new_function(pairlist2(x = , y = 5 + 5), quote(x + y)) #> function (x, y = 10)  #> x + y #> <environment: 0x562dde05f5b0> new_function(exprs(x = , y = 5 + 5), quote(x + y)) #> function (x, y = 5 + 5)  #> x + y #> <environment: 0x562dde05f5b0>"},{"path":"https://rlang.r-lib.org/dev/reference/new_node.html","id":null,"dir":"Reference","previous_headings":"","what":"Helpers for pairlist and language nodes — new_node","title":"Helpers for pairlist and language nodes — new_node","text":"Important: functions expert R programmers . use feel comfortable manipulating low level R data structures C level. export R level order make easy prototype C code. perform type checking can crash R easily (try take CAR integer vector — save important objects beforehand!).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new_node.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helpers for pairlist and language nodes — new_node","text":"","code":"new_node(car, cdr = NULL)  node_car(x)  node_cdr(x)  node_caar(x)  node_cadr(x)  node_cdar(x)  node_cddr(x)  node_poke_car(x, newcar)  node_poke_cdr(x, newcdr)  node_poke_caar(x, newcar)  node_poke_cadr(x, newcar)  node_poke_cdar(x, newcdr)  node_poke_cddr(x, newcdr)  node_tag(x)  node_poke_tag(x, newtag)"},{"path":"https://rlang.r-lib.org/dev/reference/new_node.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helpers for pairlist and language nodes — new_node","text":"car, newcar, cdr, newcdr new CAR CDR node. can R objects. x language pairlist node. Note functions barebones perform type checking. newtag new tag node. symbol.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new_node.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helpers for pairlist and language nodes — new_node","text":"Setters like node_poke_car() invisibly return x modified place. Getters return requested node component.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/new_quosure.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a quosure from components — new_quosure","title":"Create a quosure from components — new_quosure","text":"new_quosure() wraps R object (including expressions, formulas, quosures) quosure. as_quosure() similar rewrap formulas quosures.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new_quosure.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a quosure from components — new_quosure","text":"","code":"new_quosure(expr, env = caller_env())  as_quosure(x, env = NULL)  is_quosure(x)"},{"path":"https://rlang.r-lib.org/dev/reference/new_quosure.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a quosure from components — new_quosure","text":"expr expression wrap quosure. env environment expression evaluated. used symbols calls. normally environment expression created. x object test.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/new_quosure.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a quosure from components — new_quosure","text":"","code":"# `new_quosure()` creates a quosure from its components. These are # equivalent: new_quosure(quote(foo), current_env()) #> <quosure> #> expr: ^foo #> env:  0x562dd7653398  quo(foo) #> <quosure> #> expr: ^foo #> env:  0x562dd7653398  # `new_quosure()` always rewraps its input into a new quosure, even # if the input is itself a quosure: new_quosure(quo(foo)) #> <quosure> #> expr: ^<quosure> #> env:  0x562dd7653398  # This is unlike `as_quosure()` which preserves its input if it's # already a quosure: as_quosure(quo(foo)) #> <quosure> #> expr: ^foo #> env:  0x562dd7653398   # `as_quosure()` uses the supplied environment with naked expressions: env <- env(var = \"thing\") as_quosure(quote(var), env) #> <quosure> #> expr: ^var #> env:  0x562ddd8d2818  # If the expression already carries an environment, this # environment is preserved. This is the case for formulas and # quosures: as_quosure(~foo, env) #> <quosure> #> expr: ^foo #> env:  0x562dd7653398  as_quosure(~foo) #> <quosure> #> expr: ^foo #> env:  0x562dd7653398  # An environment must be supplied when the input is a naked # expression: try(   as_quosure(quote(var)) ) #> Warning: `as_quosure()` requires an explicit environment as of rlang 0.3.0. #> Please supply `env`. #> This warning is displayed once every 8 hours. #> <quosure> #> expr: ^var #> env:  0x562dd7653398"},{"path":"https://rlang.r-lib.org/dev/reference/new_quosures.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a list of quosures — new_quosures","title":"Create a list of quosures — new_quosures","text":"small S3 class provides methods [ c() ensures following invariants: list contains quosures. always named, possibly vector empty strings. new_quosures() takes list quosures adds quosures class vector empty names needed. as_quosures() calls as_quosure() elements creating quosures object.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new_quosures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a list of quosures — new_quosures","text":"","code":"new_quosures(x)  as_quosures(x, env, named = FALSE)  is_quosures(x)"},{"path":"https://rlang.r-lib.org/dev/reference/new_quosures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a list of quosures — new_quosures","text":"x list quosures objects coerce quosures. env default environment new quosures. named Whether name list quos_auto_name().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new_weakref.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a weak reference — new_weakref","title":"Create a weak reference — new_weakref","text":"weak reference special R object makes possible keep reference object without preventing garbage collection object. can also used keep data object without preventing GC object, similar WeakMaps JavaScript. Objects R considered reachable can accessed following chain references, starting root node; root nodes specially-designated R objects, include global environment base environment. long key reachable, value garbage collected. true even weak reference object becomes unreachable. key effectively prevents weak reference value collected, according following chain ownership: weakref <- key -> value. key becomes unreachable, key value weak reference object replaced NULL, finalizer scheduled execute.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/new_weakref.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a weak reference — new_weakref","text":"","code":"new_weakref(key, value = NULL, finalizer = NULL, on_quit = FALSE)"},{"path":"https://rlang.r-lib.org/dev/reference/new_weakref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a weak reference — new_weakref","text":"key key weak reference. Must reference object – , environment external pointer. value value weak reference. can NULL, want use weak reference like weak pointer. finalizer function run key becomes unreachable. on_quit finalizer run R exits?","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/new_weakref.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a weak reference — new_weakref","text":"","code":"e <- env()  # Create a weak reference to e w <- new_weakref(e, finalizer = function(e) message(\"finalized\"))  # Get the key object from the weak reference identical(wref_key(w), e) #> [1] TRUE  # When the regular reference (the `e` binding) is removed and a GC occurs, # the weak reference will not keep the object alive. rm(e) gc() #>           used (Mb) gc trigger  (Mb) max used  (Mb) #> Ncells 1194765 63.9    2175256 116.2  2175256 116.2 #> Vcells 2214208 16.9    8388608  64.0  4425705  33.8 identical(wref_key(w), NULL) #> [1] TRUE   # A weak reference with a key and value. The value contains data about the # key. k <- env() v <- list(1, 2, 3) w <- new_weakref(k, v)  identical(wref_key(w), k) #> [1] TRUE identical(wref_value(w), v) #> [1] TRUE  # When v is removed, the weak ref keeps it alive because k is still reachable. rm(v) gc() #>           used (Mb) gc trigger  (Mb) max used  (Mb) #> Ncells 1194767 63.9    2175256 116.2  2175256 116.2 #> Vcells 2214042 16.9    8388608  64.0  4425705  33.8 identical(wref_value(w), list(1, 2, 3)) #> [1] TRUE  # When k is removed, the weak ref does not keep k or v alive. rm(k) gc() #>           used (Mb) gc trigger  (Mb) max used  (Mb) #> Ncells 1194789 63.9    2175256 116.2  2175256 116.2 #> Vcells 2214080 16.9    8388608  64.0  4425705  33.8 identical(wref_key(w), NULL) #> [1] TRUE identical(wref_value(w), NULL) #> [1] TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/ns_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the namespace of a package — ns_env","title":"Get the namespace of a package — ns_env","text":"Namespaces environment functions package live. parent environments namespaces imports environments, contain functions imported packages.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/ns_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the namespace of a package — ns_env","text":"","code":"ns_env(x = caller_env())  ns_imports_env(x = caller_env())  ns_env_name(x = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/ns_env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the namespace of a package — ns_env","text":"x ns_env(), name package environment string. environment (current environment default). function. latter two cases, environment ancestry searched namespace base::topenv(). environment inherit namespace, error.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/ns_registry_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the namespace registry env — ns_registry_env","title":"Return the namespace registry env — ns_registry_env","text":"Note namespace registry behave like normal environment parent NULL instead empty environment. exported expert usage development tools .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/ns_registry_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the namespace registry env — ns_registry_env","text":"","code":"ns_registry_env()"},{"path":"https://rlang.r-lib.org/dev/reference/obj_address.html","id":null,"dir":"Reference","previous_headings":"","what":"Address of an R object — obj_address","title":"Address of an R object — obj_address","text":"Address R object","code":""},{"path":"https://rlang.r-lib.org/dev/reference/obj_address.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Address of an R object — obj_address","text":"","code":"obj_address(x)"},{"path":"https://rlang.r-lib.org/dev/reference/obj_address.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Address of an R object — obj_address","text":"x R object.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/obj_address.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Address of an R object — obj_address","text":"address memory string.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/on_load.html","id":null,"dir":"Reference","previous_headings":"","what":"Run expressions on load — on_load","title":"Run expressions on load — on_load","text":"on_load() registers expressions run user's machine time package loaded memory. contrast normal R package code run build time packager's machine (e.g. CRAN). on_load() expressions require run_on_load() called inside .onLoad(). on_package_load() registers expressions run time another package loaded. on_load() package runs expressions namespace sealed yet. means can modify existing binding create new ones. case on_package_load() runs expressions foreign package finished loading, point namespace sealed.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/on_load.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run expressions on load — on_load","text":"","code":"on_load(expr, env = parent.frame(), ns = topenv(env))  run_on_load(ns = topenv(parent.frame()))  on_package_load(pkg, expr, env = parent.frame())"},{"path":"https://rlang.r-lib.org/dev/reference/on_load.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run expressions on load — on_load","text":"expr expression run load. env environment evaluate expr. Defaults current environment, package namespace run on_load() top level. ns namespace hook expr. pkg Package hook expression .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/on_load.html","id":"when-should-i-run-expressions-on-load-","dir":"Reference","previous_headings":"","what":"When should I run expressions on load?","title":"Run expressions on load — on_load","text":"two main use cases running expressions load: side effect, registering method s3_register(), must occur user session rather package builder session. avoid hard-coding objects packages namespace. assign foo::bar result foo::baz() package, become constants. upstream changes foo package reflected objects assigned namespace. often breaks assumptions made authors foo causes sorts issues. Recreating foreign objects time package loaded makes sure changes taken account. technical terms, running expression load introduces indirection.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/on_load.html","id":"comparison-with-onload-","dir":"Reference","previous_headings":"","what":"Comparison with .onLoad()","title":"Run expressions on load — on_load","text":"on_load() advantage hooked expressions can appear file, context. unlike .onLoad() gathers disparate expressions single block. on_load() implemented via .onLoad() requires run_on_load() called hook. expressions inside on_load() undergo static analysis R CMD check. Therefore, advisable use simple function calls inside on_load().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/on_load.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run expressions on load — on_load","text":"","code":"quote({  # Not run  # First add `run_on_load()` to your `.onLoad()` hook, # then use `on_load()` anywhere in your package .onLoad <- function(lib, pkg) {   run_on_load() }  # Register a method on load on_load({   s3_register(\"foo::bar\", \"my_class\") })  # Assign an object on load var <- NULL on_load({   var <- foo() })  # To use `on_package_load()` at top level, wrap it in `on_load()` on_load({   on_package_load(\"foo\", message(\"foo is loaded\")) })  # In functions it can be called directly f <- function() on_package_load(\"foo\", message(\"foo is loaded\"))  }) #> { #>     .onLoad <- function(lib, pkg) { #>         run_on_load() #>     } #>     on_load({ #>         s3_register(\"foo::bar\", \"my_class\") #>     }) #>     var <- NULL #>     on_load({ #>         var <- foo() #>     }) #>     on_load({ #>         on_package_load(\"foo\", message(\"foo is loaded\")) #>     }) #>     f <- function() on_package_load(\"foo\", message(\"foo is loaded\")) #> }"},{"path":"https://rlang.r-lib.org/dev/reference/op-get-attr.html","id":null,"dir":"Reference","previous_headings":"","what":"Infix attribute accessor and setter — op-get-attr","title":"Infix attribute accessor and setter — op-get-attr","text":"operator extracts sets attributes regular objects S4 fields S4 objects.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/op-get-attr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infix attribute accessor and setter — op-get-attr","text":"","code":"x %@% name  x %@% name <- value"},{"path":"https://rlang.r-lib.org/dev/reference/op-get-attr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infix attribute accessor and setter — op-get-attr","text":"x Object name Attribute name value New value attribute name.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/op-get-attr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Infix attribute accessor and setter — op-get-attr","text":"","code":"# Unlike `@`, this operator extracts attributes for any kind of # objects: factor(1:3) %@% \"levels\" #> [1] \"1\" \"2\" \"3\" mtcars %@% class #> [1] \"data.frame\"  mtcars %@% class <- NULL mtcars #> $mpg #>  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 #> [14] 15.2 10.4 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 #> [27] 26.0 30.4 15.8 19.7 15.0 21.4 #>  #> $cyl #>  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4 #>  #> $disp #>  [1] 160.0 160.0 108.0 258.0 360.0 225.0 360.0 146.7 140.8 167.6 167.6 #> [12] 275.8 275.8 275.8 472.0 460.0 440.0  78.7  75.7  71.1 120.1 318.0 #> [23] 304.0 350.0 400.0  79.0 120.3  95.1 351.0 145.0 301.0 121.0 #>  #> $hp #>  [1] 110 110  93 110 175 105 245  62  95 123 123 180 180 180 205 215 #> [17] 230  66  52  65  97 150 150 245 175  66  91 113 264 175 335 109 #>  #> $drat #>  [1] 3.90 3.90 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 3.92 3.07 3.07 #> [14] 3.07 2.93 3.00 3.23 4.08 4.93 4.22 3.70 2.76 3.15 3.73 3.08 4.08 #> [27] 4.43 3.77 4.22 3.62 3.54 4.11 #>  #> $wt #>  [1] 2.620 2.875 2.320 3.215 3.440 3.460 3.570 3.190 3.150 3.440 3.440 #> [12] 4.070 3.730 3.780 5.250 5.424 5.345 2.200 1.615 1.835 2.465 3.520 #> [23] 3.435 3.840 3.845 1.935 2.140 1.513 3.170 2.770 3.570 2.780 #>  #> $qsec #>  [1] 16.46 17.02 18.61 19.44 17.02 20.22 15.84 20.00 22.90 18.30 18.90 #> [12] 17.40 17.60 18.00 17.98 17.82 17.42 19.47 18.52 19.90 20.01 16.87 #> [23] 17.30 15.41 17.05 18.90 16.70 16.90 14.50 15.50 14.60 18.60 #>  #> $vs #>  [1] 0 0 1 1 0 1 0 1 1 1 1 0 0 0 0 0 0 1 1 1 1 0 0 0 0 1 0 1 0 0 0 1 #>  #> $am #>  [1] 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 1 1 1 1 1 1 1 #>  #> $gear #>  [1] 4 4 4 3 3 3 3 4 4 4 4 3 3 3 3 3 3 4 4 4 3 3 3 3 3 4 5 5 5 5 5 4 #>  #> $carb #>  [1] 4 4 1 1 2 1 4 2 2 4 4 3 3 3 4 4 4 1 2 1 1 2 2 4 2 1 2 2 4 6 8 2 #>  #> attr(,\"row.names\") #>  [1] \"Mazda RX4\"           \"Mazda RX4 Wag\"       \"Datsun 710\"          #>  [4] \"Hornet 4 Drive\"      \"Hornet Sportabout\"   \"Valiant\"             #>  [7] \"Duster 360\"          \"Merc 240D\"           \"Merc 230\"            #> [10] \"Merc 280\"            \"Merc 280C\"           \"Merc 450SE\"          #> [13] \"Merc 450SL\"          \"Merc 450SLC\"         \"Cadillac Fleetwood\"  #> [16] \"Lincoln Continental\" \"Chrysler Imperial\"   \"Fiat 128\"            #> [19] \"Honda Civic\"         \"Toyota Corolla\"      \"Toyota Corona\"       #> [22] \"Dodge Challenger\"    \"AMC Javelin\"         \"Camaro Z28\"          #> [25] \"Pontiac Firebird\"    \"Fiat X1-9\"           \"Porsche 914-2\"       #> [28] \"Lotus Europa\"        \"Ford Pantera L\"      \"Ferrari Dino\"        #> [31] \"Maserati Bora\"       \"Volvo 142E\"           # It also works on S4 objects: .Person <- setClass(\"Person\", slots = c(name = \"character\", species = \"character\")) fievel <- .Person(name = \"Fievel\", species = \"mouse\") fievel %@% name #> [1] \"Fievel\""},{"path":"https://rlang.r-lib.org/dev/reference/op-na-default.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace missing values — op-na-default","title":"Replace missing values — op-na-default","text":"Note: operator now scope rlang. replaced vctrs-powered operator (probably funs package) point rlang version %|% deprecated. infix function similar %||% vectorised provides default value missing elements. faster using base::ifelse() perform type conversions.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/op-na-default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace missing values — op-na-default","text":"","code":"x %|% y"},{"path":"https://rlang.r-lib.org/dev/reference/op-na-default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace missing values — op-na-default","text":"x original values. y replacement values. Must length 1 length x.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/op-na-default.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace missing values — op-na-default","text":"","code":"c(\"a\", \"b\", NA, \"c\") %|% \"default\" #> [1] \"a\"       \"b\"       \"default\" \"c\"       c(1L, NA, 3L, NA, NA) %|% (6L:10L) #> [1]  1  7  3  9 10"},{"path":"https://rlang.r-lib.org/dev/reference/op-null-default.html","id":null,"dir":"Reference","previous_headings":"","what":"Default value for NULL — op-null-default","title":"Default value for NULL — op-null-default","text":"infix function makes easy replace NULLs default value. inspired way Ruby's operation (||) works.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/op-null-default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default value for NULL — op-null-default","text":"","code":"x %||% y"},{"path":"https://rlang.r-lib.org/dev/reference/op-null-default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default value for NULL — op-null-default","text":"x, y x NULL, return y; otherwise returns x.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/op-null-default.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Default value for NULL — op-null-default","text":"","code":"1 %||% 2 #> [1] 1 NULL %||% 2 #> [1] 2"},{"path":"https://rlang.r-lib.org/dev/reference/pairlist2.html","id":null,"dir":"Reference","previous_headings":"","what":"Collect dynamic dots in a pairlist — pairlist2","title":"Collect dynamic dots in a pairlist — pairlist2","text":"pairlist constructor uses dynamic dots. Use manually create argument lists calls parameter lists functions.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/pairlist2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collect dynamic dots in a pairlist — pairlist2","text":"","code":"pairlist2(...)"},{"path":"https://rlang.r-lib.org/dev/reference/pairlist2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collect dynamic dots in a pairlist — pairlist2","text":"... <dynamic> Arguments stored pairlist. Empty arguments preserved.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/pairlist2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collect dynamic dots in a pairlist — pairlist2","text":"","code":"# Unlike `exprs()`, `pairlist2()` evaluates its arguments. new_function(pairlist2(x = 1, y = 3 * 6), quote(x * y)) #> function (x = 1, y = 18)  #> x * y #> <environment: 0x562dde584770> new_function(exprs(x = 1, y = 3 * 6), quote(x * y)) #> function (x = 1, y = 3 * 6)  #> x * y #> <environment: 0x562dde584770>  # It preserves missing arguments, which is useful for creating # parameters without defaults: new_function(pairlist2(x = , y = 3 * 6), quote(x * y)) #> function (x, y = 18)  #> x * y #> <environment: 0x562dde584770>"},{"path":"https://rlang.r-lib.org/dev/reference/parse_expr.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse R code — parse_expr","title":"Parse R code — parse_expr","text":"functions parse transform text R expressions. first step interpret evaluate piece R code written programmer. parse_expr() returns one expression. text contains one expression (separated semicolons new lines), error issued. hand parse_exprs() can handle multiple expressions. always returns list expressions (compare base::parse() returns base::expression vector). functions also support R connections. parse_expr() concatenates x \\\\n separators prior parsing order support roundtrip parse_expr(expr_deparse(x)) (deparsed expressions might multiline). hand, parse_exprs() concatenation designed support named inputs. names matched expressions output, useful single named string creates multiple expressions. words, parse_expr() supports vector lines whereas parse_exprs() expects vectors complete deparsed expressions. parse_quo() parse_quos() variants create quosure. Supply env = current_env() parsing code evaluated current context. Supply env = global_env() parsing external user input evaluated user context. Unlike quosures created enquo(), enquos(), {{, parsed quosure never contains injected quosures. thus safe evaluate eval() instead eval_tidy(), though latter convenient need extract expr env.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/parse_expr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse R code — parse_expr","text":"","code":"parse_expr(x)  parse_exprs(x)  parse_quo(x, env)  parse_quos(x, env)"},{"path":"https://rlang.r-lib.org/dev/reference/parse_expr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse R code — parse_expr","text":"x Text containing expressions parse_expr parse_expr() parse_exprs(). Can also R connection, instance file. supplied connection open, automatically closed destroyed. env environment quosures. global environment (default) may right choice parsing external user inputs. might also want evaluate R code isolated context (perhaps child global environment base environment).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/parse_expr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse R code — parse_expr","text":"parse_expr() returns expression, parse_exprs() returns list expressions. Note plural variants length output may greater length input. happen one strings contain several expressions (\"foo; bar\"). names x preserved (recycled case multiple expressions). _quo suffixed variants return quosures.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/parse_expr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse R code — parse_expr","text":"Unlike base::parse(), functions never retain source reference information, slow rarely necessary.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/parse_expr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse R code — parse_expr","text":"","code":"# parse_expr() can parse any R expression: parse_expr(\"mtcars %>% dplyr::mutate(cyl_prime = cyl / sd(cyl))\") #> mtcars %>% dplyr::mutate(cyl_prime = cyl/sd(cyl))  # A string can contain several expressions separated by ; or \\n parse_exprs(\"NULL; list()\\n foo(bar)\") #> [[1]] #> NULL #>  #> [[2]] #> list() #>  #> [[3]] #> foo(bar) #>   # Use names to figure out which input produced an expression: parse_exprs(c(foo = \"1; 2\", bar = \"3\")) #> $foo #> [1] 1 #>  #> $foo #> [1] 2 #>  #> $bar #> [1] 3 #>   # You can also parse source files by passing a R connection. Let's # create a file containing R code: path <- tempfile(\"my-file.R\") cat(\"1; 2; mtcars\", file = path)  # We can now parse it by supplying a connection: parse_exprs(file(path)) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> mtcars #>"},{"path":"https://rlang.r-lib.org/dev/reference/prim_name.html","id":null,"dir":"Reference","previous_headings":"","what":"Name of a primitive function — prim_name","title":"Name of a primitive function — prim_name","text":"Name primitive function","code":""},{"path":"https://rlang.r-lib.org/dev/reference/prim_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Name of a primitive function — prim_name","text":"","code":"prim_name(prim)"},{"path":"https://rlang.r-lib.org/dev/reference/prim_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Name of a primitive function — prim_name","text":"prim primitive function base::c().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/qq_show.html","id":null,"dir":"Reference","previous_headings":"","what":"Show injected expression — qq_show","title":"Show injected expression — qq_show","text":"qq_show() helps examining injected expressions inside function. useful learning injection debugging injection code.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/qq_show.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show injected expression — qq_show","text":"expr expression involving injection operators.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/qq_show.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Show injected expression — qq_show","text":"qq_show() shows intermediary expression evaluated R:   especially useful inside functions reveal injected expression looks like:","code":"list2(!!!1:3) #> [[1]] #> [1] 1 #> #> [[2]] #> [1] 2 #> #> [[3]] #> [1] 3  qq_show(list2(!!!1:3)) #> list2(1L, 2L, 3L) my_mean <- function(data, var) {   qq_show(data %>% dplyr::summarise(mean({{ var }}))) }  mtcars %>% my_mean(cyl) #> data %>% dplyr::summarise(mean(^cyl))"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/quo_expr.html","id":null,"dir":"Reference","previous_headings":"","what":"Squash a quosure — quo_expr","title":"Squash a quosure — quo_expr","text":"function deprecated, please use quo_squash() instead.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/quo_expr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Squash a quosure — quo_expr","text":"","code":"quo_expr(quo, warn = FALSE)"},{"path":"https://rlang.r-lib.org/dev/reference/quo_expr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Squash a quosure — quo_expr","text":"quo quosure expression. warn Whether warn quosure contains quosures (collapsed). useful use quo_squash() order make non-tidyeval API compatible quosures. case, getting rid nested quosures likely cause subtle bugs good practice warn user .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/quo_label.html","id":null,"dir":"Reference","previous_headings":"","what":"Format quosures for printing or labelling — quo_label","title":"Format quosures for printing or labelling — quo_label","text":"Note: now use as_label() as_name() instead quo_name(). See life cycle section . functions take arbitrary R object, typically expression, represent string. quo_name() returns abbreviated representation object single line string. suitable default names. quo_text() returns multiline string. instance block expressions like { foo; bar } represented 4 lines (one symbol, curly braces lines). deparsers suitable creating default names printing output console. behaviour functions depend deparsed objects. looking way transforming symbols strings, use as_string() instead quo_name(). Unlike deparsing, transformation symbols strings non-lossy well defined.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/quo_label.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format quosures for printing or labelling — quo_label","text":"","code":"quo_label(quo)  quo_text(quo, width = 60L, nlines = Inf)  quo_name(quo)"},{"path":"https://rlang.r-lib.org/dev/reference/quo_label.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format quosures for printing or labelling — quo_label","text":"quo quosure expression. width Width line. nlines Maximum number lines extract.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/quo_label.html","id":"life-cycle","dir":"Reference","previous_headings":"","what":"Life cycle","title":"Format quosures for printing or labelling — quo_label","text":"functions superseded. as_label() as_name() used instead quo_name(). as_label() transforms R object string used create default name. Labelisation well defined operation assumption made label. hand, as_name() works (possibly quosured) symbols, well defined deterministic operation. good replacement quo_text() yet. See https://github.com/r-lib/rlang/issues/636 follow discussions new deparsing API.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/quo_label.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format quosures for printing or labelling — quo_label","text":"","code":"# Quosures can contain nested quosures: quo <- quo(foo(!! quo(bar))) quo #> <quosure> #> expr: ^foo(^bar) #> env:  0x562dda7b0400  # quo_squash() unwraps all quosures and returns a raw expression: quo_squash(quo) #> foo(bar)  # This is used by quo_text() and quo_label(): quo_text(quo) #> [1] \"foo(bar)\"  # Compare to the unwrapped expression: expr_text(quo) #> [1] \"~foo(~bar)\"  # quo_name() is helpful when you need really short labels: quo_name(quo(sym)) #> [1] \"sym\" quo_name(quo(!! sym)) #> [1] \"function (x) ...\""},{"path":"https://rlang.r-lib.org/dev/reference/quo_squash.html","id":null,"dir":"Reference","previous_headings":"","what":"Squash a quosure — quo_squash","title":"Squash a quosure — quo_squash","text":"quo_squash() flattens nested quosures within expression. example transforms ^foo(^bar(), ^baz) bare expression foo(bar(), baz). operation safe squashed quosure used labelling printing (see as_label(), note as_label() squashes quosures automatically). However squashed quosure evaluated, expressions flattened quosures resolved single environment. source bugs good practice set warn TRUE let user know lossy squashing.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/quo_squash.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Squash a quosure — quo_squash","text":"","code":"quo_squash(quo, warn = FALSE)"},{"path":"https://rlang.r-lib.org/dev/reference/quo_squash.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Squash a quosure — quo_squash","text":"quo quosure expression. warn Whether warn quosure contains quosures (collapsed). useful use quo_squash() order make non-tidyeval API compatible quosures. case, getting rid nested quosures likely cause subtle bugs good practice warn user .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/quo_squash.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Squash a quosure — quo_squash","text":"","code":"# Quosures can contain nested quosures: quo <- quo(wrapper(!!quo(wrappee))) quo #> <quosure> #> expr: ^wrapper(^wrappee) #> env:  0x562ddec2cd40  # quo_squash() flattens all the quosures and returns a simple expression: quo_squash(quo) #> wrapper(wrappee)"},{"path":"https://rlang.r-lib.org/dev/reference/quosure-tools.html","id":null,"dir":"Reference","previous_headings":"","what":"Quosure getters, setters and predicates — quosure-tools","title":"Quosure getters, setters and predicates — quosure-tools","text":"tools inspect modify quosures, type defused expression includes reference context created. quosure guaranteed evaluate original environment can refer local objects safely. can access quosure components quo_get_expr() quo_get_env(). quo_ prefixed predicates test expression quosure, quo_is_missing(), quo_is_symbol(), etc. quo_ prefixed functions expect quosure fail supplied another type object. Make sure input quosure is_quosure().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/quosure-tools.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quosure getters, setters and predicates — quosure-tools","text":"","code":"quo_is_missing(quo)  quo_is_symbol(quo, name = NULL)  quo_is_call(quo, name = NULL, n = NULL, ns = NULL)  quo_is_symbolic(quo)  quo_is_null(quo)  quo_get_expr(quo)  quo_get_env(quo)  quo_set_expr(quo, expr)  quo_set_env(quo, env)"},{"path":"https://rlang.r-lib.org/dev/reference/quosure-tools.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quosure getters, setters and predicates — quosure-tools","text":"quo quosure test. name name symbol function call. NULL name tested. n optional number arguments call match. ns namespace call. NULL, namespace participate pattern-matching. empty string \"\" x namespaced call, is_call() returns FALSE. string, is_call() checks x namespaced within ns. Can character vector namespaces, case call match least one , otherwise is_call() returns FALSE. expr new expression quosure. env new environment quosure.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/quosure-tools.html","id":"empty-quosures-and-missing-arguments","dir":"Reference","previous_headings":"","what":"Empty quosures and missing arguments","title":"Quosure getters, setters and predicates — quosure-tools","text":"missing arguments captured quosures, either enquo() quos(), returned empty quosure. quosures contain missing argument typically empty environment enclosure. Use quo_is_missing() test missing argument defused enquo().","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/quosure-tools.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quosure getters, setters and predicates — quosure-tools","text":"","code":"quo <- quo(my_quosure) quo #> <quosure> #> expr: ^my_quosure #> env:  0x562ddf0fc3f0   # Access and set the components of a quosure: quo_get_expr(quo) #> my_quosure quo_get_env(quo) #> <environment: 0x562ddf0fc3f0>  quo <- quo_set_expr(quo, quote(baz)) quo <- quo_set_env(quo, empty_env()) quo #> <quosure> #> expr: ^baz #> env:  empty  # Test wether an object is a quosure: is_quosure(quo) #> [1] TRUE  # If it is a quosure, you can use the specialised type predicates # to check what is inside it: quo_is_symbol(quo) #> [1] TRUE quo_is_call(quo) #> [1] FALSE quo_is_null(quo) #> [1] FALSE  # quo_is_missing() checks for a special kind of quosure, the one # that contains the missing argument: quo() #> <quosure> #> expr: ^ #> env:  empty quo_is_missing(quo()) #> [1] TRUE  fn <- function(arg) enquo(arg) fn() #> <quosure> #> expr: ^ #> env:  empty quo_is_missing(fn()) #> [1] TRUE"},{"path":"https://rlang.r-lib.org/dev/reference/raw_deparse_str.html","id":null,"dir":"Reference","previous_headings":"","what":"Serialize a raw vector to a string — raw_deparse_str","title":"Serialize a raw vector to a string — raw_deparse_str","text":"function converts raw vector hexadecimal string, optionally adding prefix suffix. roughly equivalent paste0(prefix, paste(format(x), collapse = \"\"), suffix) much faster.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/raw_deparse_str.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Serialize a raw vector to a string — raw_deparse_str","text":"","code":"raw_deparse_str(x, prefix = NULL, suffix = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/raw_deparse_str.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Serialize a raw vector to a string — raw_deparse_str","text":"x raw vector. prefix, suffix Prefix suffix strings, `NULL.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/raw_deparse_str.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Serialize a raw vector to a string — raw_deparse_str","text":"string.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/raw_deparse_str.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Serialize a raw vector to a string — raw_deparse_str","text":"","code":"raw_deparse_str(raw()) #> [1] \"\" raw_deparse_str(charToRaw(\"string\")) #> [1] \"737472696e67\" raw_deparse_str(raw(10), prefix = \"'0x\", suffix = \"'\") #> [1] \"'0x00000000000000000000'\""},{"path":"https://rlang.r-lib.org/dev/reference/rep_along.html","id":null,"dir":"Reference","previous_headings":"","what":"Create vectors matching the length of a given vector — rep_along","title":"Create vectors matching the length of a given vector — rep_along","text":"functions take idea seq_along() apply repeating values.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/rep_along.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create vectors matching the length of a given vector — rep_along","text":"","code":"rep_along(along, x)  rep_named(names, x)"},{"path":"https://rlang.r-lib.org/dev/reference/rep_along.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create vectors matching the length of a given vector — rep_along","text":"along Vector whose length determine many times x repeated. x Values repeat. names Names new vector. length names determines many times x repeated.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/rep_along.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create vectors matching the length of a given vector — rep_along","text":"","code":"x <- 0:5 rep_along(x, 1:2) #> [1] 1 2 1 2 1 2 rep_along(x, 1) #> [1] 1 1 1 1 1 1  # Create fresh vectors by repeating missing values: rep_along(x, na_int) #> [1] NA NA NA NA NA NA rep_along(x, na_chr) #> [1] NA NA NA NA NA NA  # rep_named() repeats a value along a names vectors rep_named(c(\"foo\", \"bar\"), list(letters)) #> $foo #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" #> [17] \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>  #> $bar #>  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" #> [17] \"q\" \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\" #>"},{"path":"https://rlang.r-lib.org/dev/reference/return_from.html","id":null,"dir":"Reference","previous_headings":"","what":"Jump to or from a frame — return_from","title":"Jump to or from a frame — return_from","text":"base::return() can return current local frame, return_from() return frame current evaluation stack, global currently active context.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/return_from.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Jump to or from a frame — return_from","text":"","code":"return_from(frame, value = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/return_from.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Jump to or from a frame — return_from","text":"frame execution environment currently running function. value return value.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/return_from.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Jump to or from a frame — return_from","text":"","code":"fn <- function() {   g(current_env())   \"ignored\" } g <- function(env) {   h(env)   \"ignored\" } h <- function(env) {   return_from(env, \"early return\")   \"ignored\" }  fn() #> [1] \"early return\""},{"path":"https://rlang.r-lib.org/dev/reference/rlang-package.html","id":null,"dir":"Reference","previous_headings":"","what":"rlang: Functions for Base Types and Core R and 'Tidyverse' Features — rlang-package","title":"rlang: Functions for Base Types and Core R and 'Tidyverse' Features — rlang-package","text":"toolbox working base types, core R features like condition system, core 'Tidyverse' features like tidy evaluation.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/rlang-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"rlang: Functions for Base Types and Core R and 'Tidyverse' Features — rlang-package","text":"Maintainer: Lionel Henry lionel@posit.co Authors: Hadley Wickham hadley@posit.co contributors: mikefc mikefc@coolbutuseless.com (Hash implementation based Mike's xxhashlite) [copyright holder] Yann Collet (Author embedded xxHash library) [copyright holder] Posit, PBC [copyright holder, funder]","code":""},{"path":"https://rlang.r-lib.org/dev/reference/rlang_backtrace_on_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Display backtrace on error — rlang_backtrace_on_error","title":"Display backtrace on error — rlang_backtrace_on_error","text":"rlang errors carry backtrace can inspected calling last_error(). can also control default display backtrace setting option rlang_backtrace_on_error one following values: \"none\" show nothing. \"reminder\", default interactive sessions, displays reminder can see backtrace last_error(). \"branch\" displays simplified backtrace. \"full\", default non-interactive sessions, displays full tree. rlang errors normally thrown abort(). promote base errors rlang errors global_entrace(), rlang_backtrace_on_error applies errors.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/rlang_backtrace_on_error.html","id":"promote-base-errors-to-rlang-errors","dir":"Reference","previous_headings":"","what":"Promote base errors to rlang errors","title":"Display backtrace on error — rlang_backtrace_on_error","text":"can use options(error = rlang::entrace) promote base errors rlang errors. two things: saves base error rlang object can call last_error() print backtrace inspect data. prints backtrace current error according rlang_backtrace_on_error option.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/rlang_backtrace_on_error.html","id":"warnings-and-errors-in-rmarkdown","dir":"Reference","previous_headings":"","what":"Warnings and errors in RMarkdown","title":"Display backtrace on error — rlang_backtrace_on_error","text":"display errors depends whether expected (.e. chunk option error = TRUE) unexpected: Expected errors controlled global option \"rlang_backtrace_on_error_report\" (note _report suffix). default \"none\" expected errors include reminder run rlang::last_error(). Customise option want demonstrate error backtrace look like. can also use last_error() display trace like session, currently works next chunk. Unexpected errors controlled global option \"rlang_backtrace_on_error\". default \"branch\" see simplified backtrace knitr output help figure went wrong. knitr running (determined knitr..progress global option), default top environment backtraces set chunk environment knitr::knit_global(). ensures part call stack belonging knitr end backtraces. needed, can override setting rlang_trace_top_env global option. Similarly rlang_backtrace_on_error_report, can set rlang_backtrace_on_warning_report inside RMarkdown documents tweak display warnings. useful conjunction global_entrace(). technical limitations, currently corresponding rlang_backtrace_on_warning option normal R sessions. get full entracing Rmd document, include setup chunk first error warning signalled.","code":"```{r setup} rlang::global_entrace() options(rlang_backtrace_on_warning_report = \"full\") options(rlang_backtrace_on_error_report = \"full\") ```"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/rlang_backtrace_on_error.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display backtrace on error — rlang_backtrace_on_error","text":"","code":"# Display a simplified backtrace on error for both base and rlang # errors:  # options( #   rlang_backtrace_on_error = \"branch\", #   error = rlang::entrace # ) # stop(\"foo\")"},{"path":"https://rlang.r-lib.org/dev/reference/rlang_error.html","id":null,"dir":"Reference","previous_headings":"","what":"Errors of class rlang_error — rlang_error","title":"Errors of class rlang_error — rlang_error","text":"abort() error_cnd() create errors class \"rlang_error\". differences base errors : Implementing conditionMessage() methods subclasses \"rlang_error\" undefined behaviour. Instead, implement cnd_header() method (possibly cnd_body() cnd_footer()). methods return character vectors assembled rlang needed: conditionMessage.rlang_error() called (e.g. via try()), error displayed print() format(), course error displayed user abort(). cnd_header(), cnd_body(), cnd_footer() methods can overridden storing closures header, body, footer fields condition. useful lazily generate messages based state captured closure environment. use_cli_format condition field instructs whether use cli (rlang's fallback method cli installed) format error message print time. case, message field may character vector header bullets. formatted last moment take context account (starting position screen indentation). See local_use_cli() automatically setting field errors thrown abort() within package.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/rlib_trace_spec.html","id":"structure","dir":"Reference","previous_headings":"","what":"Structure","title":"Backtrace specification — rlib_trace_spec","text":"r-lib backtrace data frame contains following columns: call: List calls. may carry srcref objects. visible: Logical vector. FALSE, corresponding call hidden simplified backtraces. parent: Integer vector parent references (see sys.parents()) row numbers. 0 global. namespace: Character vector namespaces. NA global namespace scope: Character vector strings taking values \"::\", \":::\", \"global\", \"local\". backtrace data frame may contain extra columns. add additional columns, make sure prefix names name package organisation avoid potential conflicts future extensions spec, e.g. \"mypkg_column\".","code":""},{"path":"https://rlang.r-lib.org/dev/reference/rlib_trace_spec.html","id":"operations","dir":"Reference","previous_headings":"","what":"Operations","title":"Backtrace specification — rlib_trace_spec","text":"Length. length backtrace number rows underlying data. Concatenation. Performed row-binding two backtraces.  parent column RHS shifted nrow(LHS) last call LHS takes place global frame RHS. Subsetting. Performed slicing backtrace. data frame sliced, parent column adjusted new row indices. parent value longer exists sliced backtrace set 0 (global frame).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/scalar-type-predicates.html","id":null,"dir":"Reference","previous_headings":"","what":"Scalar type predicates — scalar-type-predicates","title":"Scalar type predicates — scalar-type-predicates","text":"predicates check given type whether vector \"scalar\", , length 1. addition length check, is_string() is_bool() return FALSE input missing. useful type-checking arguments, function expects single string single TRUE FALSE.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/scalar-type-predicates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scalar type predicates — scalar-type-predicates","text":"","code":"is_scalar_list(x)  is_scalar_atomic(x)  is_scalar_vector(x)  is_scalar_integer(x)  is_scalar_double(x)  is_scalar_complex(x)  is_scalar_character(x)  is_scalar_logical(x)  is_scalar_raw(x)  is_string(x, string = NULL)  is_scalar_bytes(x)  is_bool(x)"},{"path":"https://rlang.r-lib.org/dev/reference/scalar-type-predicates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scalar type predicates — scalar-type-predicates","text":"x object tested. string string compare x. character vector, returns TRUE least one element equal x.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/scoped_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated scoped functions — scoped_env","title":"Deprecated scoped functions — scoped_env","text":"functions deprecated rlang 0.3.0. Please use is_attached() instead.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/scoped_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated scoped functions — scoped_env","text":"","code":"scoped_env(nm)  is_scoped(nm)"},{"path":"https://rlang.r-lib.org/dev/reference/scoped_env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deprecated scoped functions — scoped_env","text":"nm name environment attached search path. Call base::search() see currently path.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/scoped_interactive.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated scoped_ functions — scoped_interactive","title":"Deprecated scoped_ functions — scoped_interactive","text":"Deprecated rlang 0.4.2. Use local_interactive(), local_options(), local_bindings() instead.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/scoped_interactive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated scoped_ functions — scoped_interactive","text":"","code":"scoped_interactive(value = TRUE, frame = caller_env())  scoped_options(..., .frame = caller_env())  scoped_bindings(..., .env = .frame, .frame = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/scoped_interactive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deprecated scoped_ functions — scoped_interactive","text":"value single TRUE FALSE. overrides return value is_interactive(). frame, .frame environment running function defines scope temporary options. function returns, options reset original values. ... local_options() push_options(), named values defining new option values. peek_options(), strings character vectors option names. .env environment.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/search_envs.html","id":null,"dir":"Reference","previous_headings":"","what":"Search path environments — search_envs","title":"Search path environments — search_envs","text":"search path chain environments containing exported functions attached packages. API includes: base::search() get names environments attached search path. search_envs() returns environments search path list. pkg_env_name() takes bare package name prefixes \"package:\". Attached package environments search names form package:name. pkg_env() takes bare package name returns scoped environment packages attached search path, throws error otherwise. shortcut search_env(pkg_env_name(\"pkgname\")). global_env() base_env() (simple aliases globalenv() baseenv()). respectively first last environments search path. is_attached() returns TRUE argument (search name package environment) attached search path.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/search_envs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Search path environments — search_envs","text":"","code":"search_envs()  search_env(name)  pkg_env(pkg)  pkg_env_name(pkg)  is_attached(x)  base_env()  global_env()"},{"path":"https://rlang.r-lib.org/dev/reference/search_envs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Search path environments — search_envs","text":"name name environment attached search path. Call base::search() get names environments currently attached search path. Note search name package environment prefixed \"package:\". pkg name package. x environment search name.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/search_envs.html","id":"the-search-path","dir":"Reference","previous_headings":"","what":"The search path","title":"Search path environments — search_envs","text":"chain environments determines objects visible global workspace. contains following elements: chain always starts global_env() finishes base_env() inherits terminal environment empty_env(). base::library() call attaches new package environment search path. Attached packages associated search name. addition, list, data frame, environment can attached search path base::attach().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/search_envs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Search path environments — search_envs","text":"","code":"# List the search names of environments attached to the search path: search() #>  [1] \".GlobalEnv\"        \"package:rlang\"     \"package:stats\"     #>  [4] \"package:graphics\"  \"package:grDevices\" \"package:utils\"     #>  [7] \"package:datasets\"  \"package:methods\"   \"Autoloads\"         #> [10] \"package:base\"       # Get the corresponding environments: search_envs() #>  [[1]] $ <env: global> #>  [[2]] $ <env: package:rlang> #>  [[3]] $ <env: package:stats> #>  [[4]] $ <env: package:graphics> #>  [[5]] $ <env: package:grDevices> #>  [[6]] $ <env: package:utils> #>  [[7]] $ <env: package:datasets> #>  [[8]] $ <env: package:methods> #>  [[9]] $ <env: Autoloads> #> [[10]] $ <env: package:base>  # The global environment and the base package are always first and # last in the chain, respectively: envs <- search_envs() envs[[1]] #> <environment: R_GlobalEnv> envs[[length(envs)]] #> <environment: base>  # These two environments have their own shortcuts: global_env() #> <environment: R_GlobalEnv> base_env() #> <environment: base>  # Packages appear in the search path with a special name. Use # pkg_env_name() to create that name: pkg_env_name(\"rlang\") #> [1] \"package:rlang\" search_env(pkg_env_name(\"rlang\")) #> <environment: package:rlang> #> attr(,\"name\") #> [1] \"package:rlang\" #> attr(,\"path\") #> [1] \"/home/runner/work/_temp/Library/rlang\"  # Alternatively, get the scoped environment of a package with # pkg_env(): pkg_env(\"utils\") #> <environment: package:utils> #> attr(,\"name\") #> [1] \"package:utils\" #> attr(,\"path\") #> [1] \"/opt/R/4.5.0/lib/R/library/utils\""},{"path":"https://rlang.r-lib.org/dev/reference/seq2.html","id":null,"dir":"Reference","previous_headings":"","what":"Increasing sequence of integers in an interval — seq2","title":"Increasing sequence of integers in an interval — seq2","text":"helpers take two endpoints return sequence integers within interval. seq2_along(), upper endpoint taken length vector. Unlike base::seq(), return empty vector starting point larger integer end point.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/seq2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Increasing sequence of integers in an interval — seq2","text":"","code":"seq2(from, to)  seq2_along(from, x)"},{"path":"https://rlang.r-lib.org/dev/reference/seq2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Increasing sequence of integers in an interval — seq2","text":"starting point sequence. end point. x vector whose length end point.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/seq2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Increasing sequence of integers in an interval — seq2","text":"integer vector containing strictly increasing sequence.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/seq2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Increasing sequence of integers in an interval — seq2","text":"","code":"seq2(2, 10) #> [1]  2  3  4  5  6  7  8  9 10 seq2(10, 2) #> integer(0) seq(10, 2) #> [1] 10  9  8  7  6  5  4  3  2  seq2_along(10, letters) #>  [1] 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/set_attrs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add attributes to an object — set_attrs","text":"","code":"set_attrs(.x, ...)"},{"path":"https://rlang.r-lib.org/dev/reference/set_attrs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add attributes to an object — set_attrs","text":".x, ...","code":""},{"path":"https://rlang.r-lib.org/dev/reference/set_expr.html","id":null,"dir":"Reference","previous_headings":"","what":"Set and get an expression — set_expr","title":"Set and get an expression — set_expr","text":"helpers useful make function work generically quosures raw expressions. First call get_expr() extract expression. done processing expression, call set_expr() original object update expression. can return result set_expr(), either formula expression depending input type. Note set_expr() change input, creates new object.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/set_expr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set and get an expression — set_expr","text":"","code":"set_expr(x, value)  get_expr(x, default = x)"},{"path":"https://rlang.r-lib.org/dev/reference/set_expr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set and get an expression — set_expr","text":"x expression, closure, one-sided formula. addition, set_expr() accept frames. value updated expression. default default expression return x expression wrapper. Defaults x .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/set_expr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set and get an expression — set_expr","text":"updated original input set_expr(). raw expression get_expr().","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/set_expr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set and get an expression — set_expr","text":"","code":"f <- ~foo(bar) e <- quote(foo(bar)) frame <- identity(identity(ctxt_frame())) #> Warning: `ctxt_frame()` is deprecated as of rlang 0.3.0. #> This warning is displayed once every 8 hours.  get_expr(f) #> foo(bar) get_expr(e) #> foo(bar) get_expr(frame) #> identity(ctxt_frame())  set_expr(f, quote(baz)) #> ~baz #> <environment: 0x562ddc313908> set_expr(e, quote(baz)) #> baz"},{"path":"https://rlang.r-lib.org/dev/reference/set_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Set names of a vector — set_names","title":"Set names of a vector — set_names","text":"equivalent stats::setNames(), features stricter argument checking.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/set_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set names of a vector — set_names","text":"","code":"set_names(x, nm = x, ...)"},{"path":"https://rlang.r-lib.org/dev/reference/set_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set names of a vector — set_names","text":"x Vector name. nm, ... Vector names, length x. length 1, nm recycled length x following recycling rules tidyverse.. can specify names following ways: supplied, x named .character(x). x already names, can provide function formula transform existing names. case, ... passed function. Otherwise ... supplied, x named c(nm, ...). nm NULL, names removed (present).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/set_names.html","id":"life-cycle","dir":"Reference","previous_headings":"","what":"Life cycle","title":"Set names of a vector — set_names","text":"set_names() stable exported purrr.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/set_names.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set names of a vector — set_names","text":"","code":"set_names(1:4, c(\"a\", \"b\", \"c\", \"d\")) #> a b c d  #> 1 2 3 4  set_names(1:4, letters[1:4]) #> a b c d  #> 1 2 3 4  set_names(1:4, \"a\", \"b\", \"c\", \"d\") #> a b c d  #> 1 2 3 4   # If the second argument is ommitted a vector is named with itself set_names(letters[1:5]) #>   a   b   c   d   e  #> \"a\" \"b\" \"c\" \"d\" \"e\"   # Alternatively you can supply a function set_names(1:10, ~ letters[seq_along(.)]) #>  a  b  c  d  e  f  g  h  i  j  #>  1  2  3  4  5  6  7  8  9 10  set_names(head(mtcars), toupper) #>                    MPG CYL DISP  HP DRAT    WT  QSEC VS AM GEAR CARB #> Mazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 #> Mazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 #> Datsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 #> Hornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 #> Hornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 #> Valiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1  # If the input vector is unnamed, it is first named after itself # before the function is applied: set_names(letters, toupper) #>   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q  #> \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\"  #>   R   S   T   U   V   W   X   Y   Z  #> \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"   # `...` is passed to the function: set_names(head(mtcars), paste0, \"_foo\") #>                   mpg_foo cyl_foo disp_foo hp_foo drat_foo wt_foo #> Mazda RX4            21.0       6      160    110     3.90  2.620 #> Mazda RX4 Wag        21.0       6      160    110     3.90  2.875 #> Datsun 710           22.8       4      108     93     3.85  2.320 #> Hornet 4 Drive       21.4       6      258    110     3.08  3.215 #> Hornet Sportabout    18.7       8      360    175     3.15  3.440 #> Valiant              18.1       6      225    105     2.76  3.460 #>                   qsec_foo vs_foo am_foo gear_foo carb_foo #> Mazda RX4            16.46      0      1        4        4 #> Mazda RX4 Wag        17.02      0      1        4        4 #> Datsun 710           18.61      1      1        4        1 #> Hornet 4 Drive       19.44      1      0        3        1 #> Hornet Sportabout    17.02      0      0        3        2 #> Valiant              20.22      1      0        3        1  # If length 1, the second argument is recycled to the length of the first: set_names(1:3, \"foo\") #> foo foo foo  #>   1   2   3  set_names(list(), \"\") #> named list()"},{"path":"https://rlang.r-lib.org/dev/reference/splice-operator.html","id":null,"dir":"Reference","previous_headings":"","what":"Splice operator !!! — splice-operator","title":"Splice operator !!! — splice-operator","text":"splice operator !!! implemented dynamic dots injects list arguments function call. belongs family injection operators provides functionality .call(). two main cases splice injection : Turning list inputs distinct arguments. especially useful functions take data ..., base::rbind().   Injecting defused expressions like symbolised column names. tidyverse APIs, second case longer useful since dplyr 1.0 across() operator.","code":"dfs <- list(mtcars, mtcars) inject(rbind(!!!dfs))"},{"path":"https://rlang.r-lib.org/dev/reference/splice-operator.html","id":"where-does-work-","dir":"Reference","previous_headings":"","what":"Where does !!! work?","title":"Splice operator !!! — splice-operator","text":"!!! work everywhere, can use within certain special functions: Functions taking dynamic dots like list2(). Functions taking defused data-masked arguments, dynamic default. Inside inject(). tidyverse functions support !!! box. base functions need use inject() enable !!!. Using operator context may lead incorrect results, see happens use injection operators context?.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/splice-operator.html","id":"splicing-a-list-of-arguments","dir":"Reference","previous_headings":"","what":"Splicing a list of arguments","title":"Splice operator !!! — splice-operator","text":"Take function like base::rbind() takes data .... sort functions takes variable number arguments.   Passing individual arguments possible fixed amount arguments. arguments list whose length variable (potentially large), need programmatic approach like splicing syntax !!!:   rbind() base function used inject() explicitly enable !!!. However, many functions implement dynamic dots !!! implicitly enabled box.   Note expanded grid right column names. spliced named list. Splicing causes name list become argument name.","code":"df1 <- data.frame(x = 1) df2 <- data.frame(x = 2)  rbind(df1, df2) #>   x #> 1 1 #> 2 2 dfs <- list(df1, df2)  inject(rbind(!!!dfs)) #>   x #> 1 1 #> 2 2 tidyr::expand_grid(x = 1:2, y = c(\"a\", \"b\")) #> # A tibble: 4 x 2 #>       x y #>   <int> <chr> #> 1     1 a #> 2     1 b #> 3     2 a #> 4     2 b  xs <- list(x = 1:2, y = c(\"a\", \"b\")) tidyr::expand_grid(!!!xs) #> # A tibble: 4 x 2 #>       x y #>   <int> <chr> #> 1     1 a #> 2     1 b #> 3     2 a #> 4     2 b tidyr::expand_grid(!!!set_names(xs, toupper)) #> # A tibble: 4 x 2 #>       X Y #>   <int> <chr> #> 1     1 a #> 2     1 b #> 3     2 a #> 4     2 b"},{"path":"https://rlang.r-lib.org/dev/reference/splice-operator.html","id":"splicing-a-list-of-expressions","dir":"Reference","previous_headings":"","what":"Splicing a list of expressions","title":"Splice operator !!! — splice-operator","text":"Another usage !!! inject defused expressions data-masked dots. However usage longer common pattern programming tidyverse functions recommend using patterns possible. First, instead using defuse--inject pattern ..., can simply pass normally . two expressions completely equivalent:   Second, complex applications transformation patterns can solved across() operation introduced dplyr 1.0. Say want take mean() expressions .... across(), defuse ... expressions, wrap call mean(), inject summarise().   much easier use across() instead:","code":"my_group_by <- function(.data, ...) {   .data %>% dplyr::group_by(!!!enquos(...)) }  # This equivalent syntax is preferred my_group_by <- function(.data, ...) {   .data %>% dplyr::group_by(...) } my_mean <- function(.data, ...) {   # Defuse dots and auto-name them   exprs <- enquos(..., .named = TRUE)    # Wrap the expressions in a call to `mean()`   exprs <- purrr::map(exprs, ~ call(\"mean\", .x, na.rm = TRUE))    # Inject them   .data %>% dplyr::summarise(!!!exprs) } my_mean <- function(.data, ...) {   .data %>% dplyr::summarise(across(c(...), ~ mean(.x, na.rm = TRUE))) }"},{"path":"https://rlang.r-lib.org/dev/reference/splice-operator.html","id":"performance-of-injected-dots-and-dynamic-dots","dir":"Reference","previous_headings":"","what":"Performance of injected dots and dynamic dots","title":"Splice operator !!! — splice-operator","text":"Take dynamic dots function:   takes dynamic dots can splice !!! box.   Equivalently enable !!! explicitly inject().   result , going hood completely different. list2() dots collector special-cases !!! arguments. hand, inject() operates language creates function call containing many arguments elements spliced list. supply list size 1e6, inject() creating one million arguments evaluation. can much slower.   issue occurs functions taking dynamic dots called inside data-masking function like dplyr::mutate(). mechanism enables !!! injection arguments inject().","code":"n_args <- function(...) {   length(list2(...)) } n_args(1, 2) #> [1] 2  n_args(!!!mtcars) #> [1] 11 inject(n_args(!!!mtcars)) #> [1] 11 xs <- rep(list(1), 1e6)  system.time(   n_args(!!!xs) ) #>    user  system elapsed #>   0.009   0.000   0.009  system.time(   inject(n_args(!!!xs)) ) #>    user  system elapsed #>   0.445   0.012   0.457"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/splice.html","id":null,"dir":"Reference","previous_headings":"","what":"Splice values at dots collection time — splice","title":"Splice values at dots collection time — splice","text":"splice() advanced feature dynamic dots. rarely needed can solve performance issues edge cases. splicing operator !!! operates values contexts like list2() dots_list(), metaprogramming contexts like expr(), enquos(), inject(). end result looks , implementation different much efficient value cases. difference implementation may cause performance issues instance going :   :   former case, performant value-splicing used. latter case, slow metaprogramming splicing used. common practical case may occur code wrapped inside tidyeval context like dplyr::mutate(). case, metaprogramming operator !!! take value-splicing operator, causing unexpected slowdown. avoid performance-critical code, use splice() instead !!!:   Note splice() behaves differently !!!. splicing happens later processed list2() dots_list(). work tidyeval context list collectors.","code":"xs <- list(2, 3) list2(1, !!!xs, 4) inject(list2(1, !!!xs, 4)) # These both use the fast splicing: list2(1, splice(xs), 4) inject(list2(1, splice(xs), 4))"},{"path":"https://rlang.r-lib.org/dev/reference/splice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Splice values at dots collection time — splice","text":"","code":"splice(x)  is_spliced(x)  is_spliced_bare(x)"},{"path":"https://rlang.r-lib.org/dev/reference/splice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Splice values at dots collection time — splice","text":"x list vector splice non-eagerly.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/stack-deprecated.html","id":null,"dir":"Reference","previous_headings":"","what":"Call stack information — stack-deprecated","title":"Call stack information — stack-deprecated","text":"Deprecated rlang 0.3.0.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/stack-deprecated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Call stack information — stack-deprecated","text":"","code":"ctxt_frame(n = 1)  global_frame()"},{"path":"https://rlang.r-lib.org/dev/reference/stack-deprecated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Call stack information — stack-deprecated","text":"n number frames go back stack.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/stack.html","id":null,"dir":"Reference","previous_headings":"","what":"Get properties of the current or caller frame — stack","title":"Get properties of the current or caller frame — stack","text":"accessors retrieve properties frames call stack. prefix indicates frame property accessed: current frame current_ accessors. calling frame caller_ accessors. matching frame frame_ accessors. suffix indicates property retrieve: _fn accessors return function running frame. _call accessors return defused call function running frame invoked. _env accessors return execution environment function running frame.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/stack.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get properties of the current or caller frame — stack","text":"","code":"current_call()  current_fn()  current_env()  caller_call(n = 1)  caller_fn(n = 1)  caller_env(n = 1)  frame_call(frame = caller_env())  frame_fn(frame = caller_env())"},{"path":"https://rlang.r-lib.org/dev/reference/stack.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get properties of the current or caller frame — stack","text":"n number callers go back. frame frame environment currently running function, returned caller_env(). NULL returned environment exist stack.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/string.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a string — string","title":"Create a string — string","text":"base-type constructors allow control creation strings R. take character vectors string-like objects (integerish raw vectors), optionally set encoding. string version checks input contains scalar string.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/string.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a string — string","text":"","code":"string(x, encoding = NULL)"},{"path":"https://rlang.r-lib.org/dev/reference/string.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a string — string","text":"x character vector vector list string-like objects. encoding non-null, set encoding mark. declarative, encoding conversion performed.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/string.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a string — string","text":"","code":"# As everywhere in R, you can specify a string with Unicode # escapes. The characters corresponding to Unicode codepoints will # be encoded in UTF-8, and the string will be marked as UTF-8 # automatically: cafe <- string(\"caf\\uE9\") Encoding(cafe) #> [1] \"UTF-8\" charToRaw(cafe) #> [1] 63 61 66 c3 a9  # In addition, string() provides useful conversions to let # programmers control how the string is represented in memory. For # encodings other than UTF-8, you'll need to supply the bytes in # hexadecimal form. If it is a latin1 encoding, you can mark the # string explicitly: cafe_latin1 <- string(c(0x63, 0x61, 0x66, 0xE9), \"latin1\") Encoding(cafe_latin1) #> [1] \"latin1\" charToRaw(cafe_latin1) #> [1] 63 61 66 e9"},{"path":"https://rlang.r-lib.org/dev/reference/switch_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Dispatch on base types — switch_type","title":"Dispatch on base types — switch_type","text":"switch_type() equivalent switch(type_of(x, ...)), switch_class() switchpatches based class(x). coerce_ versions intended type conversion provide standard error message conversion fails.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/switch_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dispatch on base types — switch_type","text":"","code":"switch_type(.x, ...)  coerce_type(.x, .to, ...)  switch_class(.x, ...)  coerce_class(.x, .to, ...)"},{"path":"https://rlang.r-lib.org/dev/reference/switch_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dispatch on base types — switch_type","text":".x object dispatch. ... Named clauses. names types returned type_of(). .useful switchpatch within coercing function. supplied, string indicating target type. catch-clause added signal error stating conversion failure. type prettified unless .inherits S3 class \"AsIs\" (see base::()).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/switch_type.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dispatch on base types — switch_type","text":"","code":"switch_type(3L,   double = \"foo\",   integer = \"bar\",   \"default\" ) #> Warning: `switch_type()` is soft-deprecated as of rlang 0.4.0. #> Please use `switch(typeof())` or `switch(my_typeof())` instead. #> This warning is displayed once every 8 hours. #> [1] \"bar\"  # Use the coerce_ version to get standardised error handling when no # type matches: to_chr <- function(x) {   coerce_type(x, \"a chr\",     integer = as.character(x),     double = as.character(x)   ) } to_chr(3L) #> Warning: `coerce_type()` is soft-deprecated as of rlang 0.4.0. #> This warning is displayed once every 8 hours. #> [1] \"3\"  # Strings have their own type: switch_type(\"str\",   character = \"foo\",   string = \"bar\",   \"default\" ) #> [1] \"bar\"  # Use a fallthrough clause if you need to dispatch on all character # vectors, including strings: switch_type(\"str\",   string = ,   character = \"foo\",   \"default\" ) #> [1] \"foo\"  # special and builtin functions are treated as primitive, since # there is usually no reason to treat them differently: switch_type(base::list,   primitive = \"foo\",   \"default\" ) #> [1] \"foo\" switch_type(base::`$`,   primitive = \"foo\",   \"default\" ) #> [1] \"foo\"  # closures are not primitives: switch_type(rlang::switch_type,   primitive = \"foo\",   \"default\" ) #> [1] \"default\""},{"path":"https://rlang.r-lib.org/dev/reference/sym.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a symbol or list of symbols — sym","title":"Create a symbol or list of symbols — sym","text":"Symbols kind defused expression represent objects environments. sym() syms() take strings input turn symbols. data_sym() data_syms() create calls form .data$foo instead symbols. Subsetting .data pronoun robust expect data-variable. See data mask ambiguity. tidy eval APIs support .data pronoun. base R functions, use simple symbols created sym() syms().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/sym.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a symbol or list of symbols — sym","text":"","code":"sym(x)  syms(x)  data_sym(x)  data_syms(x)"},{"path":"https://rlang.r-lib.org/dev/reference/sym.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a symbol or list of symbols — sym","text":"x sym() data_sym(), string. syms() data_syms(), list strings.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/sym.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a symbol or list of symbols — sym","text":"sym() syms(), symbol list symbols. data_sym() data_syms(), calls form .data$foo.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/sym.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a symbol or list of symbols — sym","text":"","code":"# Create a symbol sym(\"cyl\") #> cyl  # Create a list of symbols syms(c(\"cyl\", \"am\")) #> [[1]] #> cyl #>  #> [[2]] #> am #>   # Symbolised names refer to variables eval(sym(\"cyl\"), mtcars) #>  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4  # Beware of scoping issues Cyl <- \"wrong\" eval(sym(\"Cyl\"), mtcars) #> [1] \"wrong\"  # Data symbols are explicitly scoped in the data mask try(eval_tidy(data_sym(\"Cyl\"), mtcars)) #> Error in .data$Cyl : Column `Cyl` not found in `.data`.  # These can only be used with tidy eval functions try(eval(data_sym(\"Cyl\"), mtcars)) #> Error in eval(data_sym(\"Cyl\"), mtcars) :  #>   Can't subset `.data` outside of a data mask context.  # The empty string returns the missing argument: sym(\"\") #>   # This way sym() and as_string() are inverse of each other: as_string(missing_arg()) #> [1] \"\" sym(as_string(missing_arg())) #>"},{"path":"https://rlang.r-lib.org/dev/reference/topic-condition-customisation.html","id":null,"dir":"Reference","previous_headings":"","what":"Customising condition messages — topic-condition-customisation","title":"Customising condition messages — topic-condition-customisation","text":"Various aspects condition messages displayed abort(), warn(), inform() can customised using options cli package.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-condition-customisation.html","id":"turning-off-unicode-bullets","dir":"Reference","previous_headings":"","what":"Turning off unicode bullets","title":"Customising condition messages — topic-condition-customisation","text":"default, bulleted lists prefixed unicode symbols:  Set option use simple letters instead:","code":"rlang::abort(c(   \"The error message.\",   \"*\" = \"Regular bullet.\",   \"i\" = \"Informative bullet.\",   \"x\" = \"Cross bullet.\",   \"v\" = \"Victory bullet.\",   \">\" = \"Arrow bullet.\" )) #> Error: #> ! The error message. #> • Regular bullet. #> ℹ Informative bullet. #> ✖ Cross bullet. #> ✔ Victory bullet. #> → Arrow bullet. options(cli.condition_unicode_bullets = FALSE)  rlang::abort(c(   \"The error message.\",   \"*\" = \"Regular bullet.\",   \"i\" = \"Informative bullet.\",   \"x\" = \"Cross bullet.\",   \"v\" = \"Victory bullet.\",   \">\" = \"Arrow bullet.\" )) #> Error: #> ! The error message. #> * Regular bullet. #> i Informative bullet. #> x Cross bullet. #> v Victory bullet. #> > Arrow bullet."},{"path":"https://rlang.r-lib.org/dev/reference/topic-condition-customisation.html","id":"changing-the-bullet-symbols","dir":"Reference","previous_headings":"","what":"Changing the bullet symbols","title":"Customising condition messages — topic-condition-customisation","text":"can specify symbol use type bullet cli user theme. instance, uniformly use * bullet kinds:   want bullets , including leading bullet, can achieve using bullet class:","code":"options(cli.user_theme = list(   \".cli_rlang .bullet-*\" = list(before = \"* \"),   \".cli_rlang .bullet-i\" = list(before = \"* \"),   \".cli_rlang .bullet-x\" = list(before = \"* \"),   \".cli_rlang .bullet-v\" = list(before = \"* \"),   \".cli_rlang .bullet->\" = list(before = \"* \") ))  rlang::abort(c(   \"The error message.\",   \"*\" = \"Regular bullet.\",   \"i\" = \"Informative bullet.\",   \"x\" = \"Cross bullet.\",   \"v\" = \"Victory bullet.\",   \">\" = \"Arrow bullet.\" )) #> Error: #> ! The error message. #> * Regular bullet. #> * Informative bullet. #> * Cross bullet. #> * Victory bullet. #> * Arrow bullet. options(cli.user_theme = list(   \".cli_rlang .bullet\" = list(before = \"* \") ))  rlang::abort(c(   \"The error message.\",   \"*\" = \"Regular bullet.\",   \"i\" = \"Informative bullet.\",   \"x\" = \"Cross bullet.\",   \"v\" = \"Victory bullet.\",   \">\" = \"Arrow bullet.\" )) #> Error: #> * The error message. #> * Regular bullet. #> * Informative bullet. #> * Cross bullet. #> * Victory bullet. #> * Arrow bullet."},{"path":"https://rlang.r-lib.org/dev/reference/topic-condition-customisation.html","id":"changing-the-foreground-and-background-colour-of-error-calls","dir":"Reference","previous_headings":"","what":"Changing the foreground and background colour of error calls","title":"Customising condition messages — topic-condition-customisation","text":"called inside function, abort() displays function call help contextualise error:   call formatted cli code element. visible manual, code text formatted highlighted background colour default. can reliably detected, background colour different depending whether using light dark theme. can override colour code elements cli theme. personal configuration fits well colour theme currently use IDE:","code":"splash <- function() {   abort(\"Can't splash without water.\") }  splash() #> Error in `splash()`: #> ! Can't splash without water. options(cli.user_theme = list(   span.code = list(     \"background-color\" = \"#3B4252\",     color = \"#E5E9F0\"   ) ))"},{"path":"https://rlang.r-lib.org/dev/reference/topic-condition-formatting.html","id":null,"dir":"Reference","previous_headings":"","what":"Formatting messages with cli — topic-condition-formatting","title":"Formatting messages with cli — topic-condition-formatting","text":"Condition formatting set operations applied raw inputs error messages includes: Transforming character vector lines width-wrapped list error bullets. makes easy write messages list format bullet conveys single important point.   See tidyverse error style guide style error messaging. Applying style (emphasis, boldness, ...) colours message elements. rlang package embeds rudimentary formatting routines, main formatting engine implemented cli package.","code":"abort(c(   \"The error header\",   \"*\" = \"An error bullet\",   \"i\" = \"An info bullet\",   \"x\" = \"A cross bullet\" )) #> Error: #> ! The error header #> * An error bullet #> i An info bullet #> x A cross bullet"},{"path":"https://rlang.r-lib.org/dev/reference/topic-condition-formatting.html","id":"formatting-messages-with-cli","dir":"Reference","previous_headings":"","what":"Formatting messages with cli","title":"Formatting messages with cli — topic-condition-formatting","text":"default, rlang uses internal mechanism format bullets. preferable delegate formatting cli package using cli::cli_abort(), cli::cli_warn(), cli::cli_inform() instead rlang versions. wrappers enable cli formatting sophisticated paragraph wrapping bullet indenting make long lines easier read. following example, long ! bullet broken indented newline:   cli wrappers also add many features interpolation, semantic formatting text elements, pluralisation:","code":"rlang::global_entrace(class = \"errorr\") #> Error in `rlang::global_entrace()`: #> ! `class` must be one of \"error\", \"warning\", or \"message\", #>   not \"errorr\". #> i Did you mean \"error\"? inform_marbles <- function(n_marbles) {   cli::cli_inform(c(     \"i\" = \"I have {n_marbles} shiny marble{?s} in my bag.\",     \"v\" = \"Way to go {.code cli::cli_inform()}!\"   )) }  inform_marbles(1) #> i I have 1 shiny marble in my bag. #> v Way to go `cli::cli_inform()`!  inform_marbles(2) #> i I have 2 shiny marbles in my bag. #> v Way to go `cli::cli_inform()`!"},{"path":"https://rlang.r-lib.org/dev/reference/topic-condition-formatting.html","id":"transitioning-from-abort-to-cli-abort-","dir":"Reference","previous_headings":"","what":"Transitioning from abort() to cli_abort()","title":"Formatting messages with cli — topic-condition-formatting","text":"plan mass-rename calls abort() cli::cli_abort(), careful assemble error messages user inputs. individual pieces contain cli glue syntax, result hard--debug errors possibly unexpected behaviour.   avoid , protect error messages using cli assemble pieces:","code":"user_input <- \"{base::stop('Wrong message.', call. = FALSE)}\" cli::cli_abort(sprintf(\"Can't handle input `%s`.\", user_input)) #> Error: #> ! ! Could not evaluate cli `{}` expression: `base::stop('Wrong...`. #> Caused by error: #> ! Wrong message. user_input <- \"{base::stop('Wrong message.', call. = FALSE)}\" cli::cli_abort(\"Can't handle input {.code {user_input}}.\") #> Error: #> ! Can't handle input `{base::stop('Wrong message.', call. = FALSE)}`."},{"path":"https://rlang.r-lib.org/dev/reference/topic-condition-formatting.html","id":"enabling-cli-formatting-globally","dir":"Reference","previous_headings":"","what":"Enabling cli formatting globally","title":"Formatting messages with cli — topic-condition-formatting","text":"enable cli formatting abort() calls namespace, call local_use_cli() onLoad hook package. Using on_load() (make sure call run_on_load() hook):   Enabling cli formatting abort() useful : Transitioning abort() cli::cli_abort() progressively. Using abort() like disable interpolation syntax. Creating error conditions error_cnd(). condition messages automatically formatted cli well.","code":"on_load(local_use_cli())"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-ambiguity.html","id":null,"dir":"Reference","previous_headings":"","what":"The data mask ambiguity — topic-data-mask-ambiguity","title":"The data mask ambiguity — topic-data-mask-ambiguity","text":"Data masking R feature blends programming variables live inside environments (env-variables) statistical variables stored data frames (data-variables). mixture makes easy refer data frame columns well objects defined current environment.   However convenience introduces ambiguity data-variables env-variables might cause collisions.","code":"x <- 100 mtcars %>% dplyr::summarise(mean(disp / x)) #> # A tibble: 1 x 1 #>   `mean(disp/x)` #>            <dbl> #> 1           2.31"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-ambiguity.html","id":"column-collisions","dir":"Reference","previous_headings":"","what":"Column collisions","title":"The data mask ambiguity — topic-data-mask-ambiguity","text":"following snippet, referring env-variable x data-variable name?   column collision occurs want use object defined outside data frame, column name happens exist.","code":"df <- data.frame(x = NA, y = 2) x <- 100  df %>% dplyr::mutate(y = y / x) #>    x  y #> 1 NA NA"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-ambiguity.html","id":"object-collisions","dir":"Reference","previous_headings":"","what":"Object collisions","title":"The data mask ambiguity — topic-data-mask-ambiguity","text":"opposite problem occurs typo data-variable name env-variable name exists:   Instead typo, might also expecting column data frame unexpectedly missing. cases, variable found data mask, R looks variables surrounding environment. intended better fail early \"Column found\" error.","code":"df <- data.frame(foo = \"right\") ffo <- \"wrong\"  df %>% dplyr::mutate(foo = toupper(ffo)) #>     foo #> 1 WRONG"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-ambiguity.html","id":"preventing-collisions","dir":"Reference","previous_headings":"","what":"Preventing collisions","title":"The data mask ambiguity — topic-data-mask-ambiguity","text":"casual scripts interactive programming, data mask ambiguity huge deal compared payoff iterating quickly developing analysis. However production code package functions, ambiguity might cause collision bugs long run. Fortunately easy explicit scoping variables little verbose code. topic lists solutions workarounds created solve ambiguity issues data masks.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-ambiguity.html","id":"the-data-and-env-pronouns","dir":"Reference","previous_headings":"","what":"The .data and .env pronouns","title":"The data mask ambiguity — topic-data-mask-ambiguity","text":"simplest solution use .data .env pronouns disambiguate data-variables env-variables.   especially useful functions data frame known advance potentially contain masking columns env-variables scope function:   Subsetting function arguments .env ensures never hit masking column:","code":"df <- data.frame(x = 1, y = 2) x <- 100  df %>% dplyr::mutate(y = .data$y / .env$x) #>   x    y #> 1 1 0.02 my_rescale <- function(data, var, factor = 10) {   data %>% dplyr::mutate(\"{{ var }}\" := {{ var }} / factor) }  # This works data.frame(value = 1) %>% my_rescale(value) #>   value #> 1   0.1  # Oh no! data.frame(factor = 0, value = 1) %>% my_rescale(value) #>   factor value #> 1      0   Inf my_rescale <- function(data, var, factor = 10) {   data %>% dplyr::mutate(\"{{ var }}\" := {{ var }} / .env$factor) }  # Yay! data.frame(factor = 0, value = 1) %>% my_rescale(value) #>   factor value #> 1      0   0.1"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-ambiguity.html","id":"subsetting-data-with-env-variables","dir":"Reference","previous_headings":"","what":"Subsetting .data with env-variables","title":"The data mask ambiguity — topic-data-mask-ambiguity","text":".data pronoun may used name--data-mask pattern (see Data mask programming patterns):   example, env-variable var used inside data mask subset .data pronoun. mean var risk column collision input data frame contains column name? Fortunately :   evaluation .data[[var]] set way ambiguity. .data pronoun can subsetted env-variables, data-variables. Technically, [[ behaves like injection operator applied .data. evaluated early data mask even created. See !! section .","code":"var <- \"cyl\" mtcars %>% dplyr::summarise(mean = mean(.data[[var]])) #> # A tibble: 1 x 1 #>    mean #>   <dbl> #> 1  6.19 var <- \"cyl\"  mtcars2 <- mtcars mtcars2$var <- \"wrong\"  mtcars2 %>% dplyr::summarise(mean = mean(.data[[var]])) #> # A tibble: 1 x 1 #>    mean #>   <dbl> #> 1  6.19"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-ambiguity.html","id":"injecting-env-variables-with-","dir":"Reference","previous_headings":"","what":"Injecting env-variables with !!","title":"The data mask ambiguity — topic-data-mask-ambiguity","text":"Injection operators !! interesting properties regarding ambiguity problem. modify piece code early injecting objects expressions data-masking logic comes play. inject value variable, becomes inlined expression. R longer needs look variable find value. Taking earlier division example, use !! inject value env-variable x inside division expression:   injection solves issues ambiguity, bit heavy handed compared using .env pronoun. Big objects inlined expressions might cause issues unexpected places, instance might make calls traceback() less readable.","code":"df <- data.frame(x = NA, y = 2) x <- 100  df %>% dplyr::mutate(y = y / !!x) #>    x    y #> 1 NA 0.02"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-ambiguity.html","id":"no-ambiguity-in-tidy-selections","dir":"Reference","previous_headings":"","what":"No ambiguity in tidy selections","title":"The data mask ambiguity — topic-data-mask-ambiguity","text":"Tidy selection dialect R optimises column selection tidyverse packages. Examples functions use tidy selections dplyr::select() tidyr::pivot_longer(). Unlike data masking, tidy selections suffer ambiguity. selection language designed way evaluation expressions either scoped data mask , environment . Take example:   gear symbol supplied selection operator : thus scoped data mask . kind expression, ncol(mtcars), evaluated normal R code outside data context. column collision :   useful introduce two new terms. Tidy selections distinguish data-expressions env-expressions: data data-expression refers data-variable. ncol(data) env-expression refers env-variable. learn difference two kinds expressions, see technical description tidy selection syntax.","code":"mtcars %>% dplyr::select(gear:ncol(mtcars)) data <- data.frame(x = 1, data = 1:3)  data %>% dplyr::select(data:ncol(data)) #>   data #> 1    1 #> 2    2 #> 3    3"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-ambiguity.html","id":"names-pattern-with-all-of-","dir":"Reference","previous_headings":"","what":"Names pattern with all_of()","title":"The data mask ambiguity — topic-data-mask-ambiguity","text":"all_of() often used functions programming pattern connects column names data mask, similarly .data pronoun. simple example :   tidy selections affected data mask ambiguity, function risk column collision. break soon user supplies data frame containing vars column. However, all_of() env-expression evaluated outside data mask, possibility collisions.","code":"my_group_by <- function(data, vars) {   data %>% dplyr::group_by(across(all_of(vars))) }"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":null,"dir":"Reference","previous_headings":"","what":"Data mask programming patterns — topic-data-mask-programming","title":"Data mask programming patterns — topic-data-mask-programming","text":"Data-masking functions require special programming patterns used inside functions. topic review compare different patterns can used solve specific problems. beginner, might want start one tutorials: Programming dplyr Using ggplot2 packages like go learn defusing injecting expressions, read metaprogramming patterns topic.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"choosing-a-pattern","dir":"Reference","previous_headings":"","what":"Choosing a pattern","title":"Data mask programming patterns — topic-data-mask-programming","text":"Two main considerations determine programming pattern need wrap data-masking function: behaviour wrapped function implement? behaviour function implement? Depending answers questions, can choose approaches: forwarding patterns function inherits behaviour function interfaces . name patterns function takes strings character vectors column names. bridge patterns change behaviour argument instead inheriting . also need use different solutions single named arguments multiple arguments ....","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"argument-behaviours","dir":"Reference","previous_headings":"","what":"Argument behaviours","title":"Data mask programming patterns — topic-data-mask-programming","text":"regular function, arguments can defined terms type objects accept. argument might accept character vector, data frame, single logical value, etc. Data-masked arguments complex. generally accept specific type objects (instance dplyr::mutate() accepts vectors), exhibit special computational behaviours. Data-masked expressions (base): E.g. transform(), ().  Expressions may refer columns supplied data frame. Data-masked expressions (tidy eval): E.g. dplyr::mutate(), ggplot2::aes(). base data-masking tidy eval features enabled. includes injection operators {{ !! .data .env pronouns. Data-masked symbols: data-masked arguments supplied expressions must simple column names. often simplifies things, instance easy way avoiding issues double evaluation. Tidy selections: E.g. dplyr::select(), tidyr::pivot_longer(). alternative data masking supports selection helpers like starts_with() all_of(), implements special behaviour operators like c(), | &. Unlike data masking, tidy selection interpreted dialect. fact masking . Expressions either interpreted context data frame (e.g. c(cyl, ) stands union columns cyl ), evaluated user environment (e.g. all_of(), starts_with(), expressions). implications inheritance argument behaviour see . Dynamic dots: may data-masked arguments, tidy selections, just regular arguments. Dynamic dots support injection multiple arguments !!! operator well name injection glue operators. let users know capabilities function arguments, document following tags, depending set semantics inherit :","code":"@param foo <[`data-masked`][dplyr::dplyr_data_masking]> What `foo` does.  @param bar <[`tidy-select`][dplyr::dplyr_tidy_select]> What `bar` does.  @param ... <[`dynamic-dots`][rlang::dyn-dots]> What these dots do."},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"forwarding-patterns","dir":"Reference","previous_headings":"","what":"Forwarding patterns","title":"Data mask programming patterns — topic-data-mask-programming","text":"forwarding patterns, arguments inherit behaviour data-masked arguments passed .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"embrace-with-","dir":"Reference","previous_headings":"","what":"Embrace with {{","title":"Data mask programming patterns — topic-data-mask-programming","text":"embrace operator {{ forwarding syntax single arguments. can forward argument data-masked context:   tidyselections:   function automatically inherits behaviour surrounding context. instance arguments forwarded data-masked context may refer columns use .data pronoun:   arguments forwarded tidy selection may use tidyselect features:","code":"my_summarise <- function(data, var) {   data %>% dplyr::summarise({{ var }}) } my_pivot_longer <- function(data, var) {   data %>% tidyr::pivot_longer(cols = {{ var }}) } mtcars %>% my_summarise(mean(cyl))  x <- \"cyl\" mtcars %>% my_summarise(mean(.data[[x]])) mtcars %>% my_pivot_longer(cyl) mtcars %>% my_pivot_longer(vs:gear) mtcars %>% my_pivot_longer(starts_with(\"c\"))  x <- c(\"cyl\", \"am\") mtcars %>% my_pivot_longer(all_of(x))"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"forward-","dir":"Reference","previous_headings":"","what":"Forward ...","title":"Data mask programming patterns — topic-data-mask-programming","text":"Simple forwarding ... arguments require special syntax since dots already forwarding syntax. Just pass another function like normally . works data-masked arguments:   well tidy selections:   functions take tidy selection single named argument. case, pass ... inside c():   Inside tidy selection, c() vector concatenator selection combinator. makes handy interface functions take ... functions take single argument.","code":"my_group_by <- function(.data, ...) {   .data %>% dplyr::group_by(...) }  mtcars %>% my_group_by(cyl = cyl * 100, am) my_select <- function(.data, ...) {   .data %>% dplyr::select(...) }  mtcars %>% my_select(starts_with(\"c\"), vs:carb) my_pivot_longer <- function(.data, ...) {   .data %>% tidyr::pivot_longer(c(...)) }  mtcars %>% my_pivot_longer(starts_with(\"c\"), vs:carb)"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"names-patterns","dir":"Reference","previous_headings":"","what":"Names patterns","title":"Data mask programming patterns — topic-data-mask-programming","text":"names patterns refer columns name strings character vectors stored env-variables. Whereas forwarding patterns exclusively used within function pass arguments, names patterns can used anywhere. script, can loop character vector lapply() use .data pattern connect name data-variable. vector can also supplied tidy select helper all_of(). function, using names patterns function arguments lets users supply regular data-variable names without complications come data-masking.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"subsetting-the-data-pronoun","dir":"Reference","previous_headings":"","what":"Subsetting the .data pronoun","title":"Data mask programming patterns — topic-data-mask-programming","text":".data pronoun tidy eval feature enabled data-masked arguments, just like {{. pronoun represents data mask can subsetted [[ $. three statements equivalent:   .data pronoun can subsetted loops:   can used connect function arguments data-variable:   implementation, my_mean() completely insulated data-masking behaviour called like ordinary function.","code":"mtcars %>% dplyr::summarise(mean = mean(cyl))  mtcars %>% dplyr::summarise(mean = mean(.data$cyl))  var <- \"cyl\" mtcars %>% dplyr::summarise(mean = mean(.data[[var]])) vars <- c(\"cyl\", \"am\")  for (var in vars) print(dplyr::summarise(mtcars, mean = mean(.data[[var]]))) #> # A tibble: 1 x 1 #>    mean #>   <dbl> #> 1  6.19 #> # A tibble: 1 x 1 #>    mean #>   <dbl> #> 1 0.406  purrr::map(vars, ~ dplyr::summarise(mtcars, mean =  mean(.data[[.x]]))) #> [[1]] #> # A tibble: 1 x 1 #>    mean #>   <dbl> #> 1  6.19 #> #> [[2]] #> # A tibble: 1 x 1 #>    mean #>   <dbl> #> 1 0.406 my_mean <- function(data, var) {   data %>% dplyr::summarise(mean = mean(.data[[var]])) }  my_mean(mtcars, \"cyl\") #> # A tibble: 1 x 1 #>    mean #>   <dbl> #> 1  6.19 # No masking am <- \"cyl\" my_mean(mtcars, am) #> # A tibble: 1 x 1 #>    mean #>   <dbl> #> 1  6.19  # Programmable my_mean(mtcars, tolower(\"CYL\")) #> # A tibble: 1 x 1 #>    mean #>   <dbl> #> 1  6.19"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"character-vector-of-names","dir":"Reference","previous_headings":"","what":"Character vector of names","title":"Data mask programming patterns — topic-data-mask-programming","text":".data pronoun can subsetted single column names. support single-bracket indexing:   plural variant .data built tidy eval. Instead, used all_of() operator available tidy selections supply character vectors. straightforward functions take tidy selections, like tidyr::pivot_longer():   function take tidy selection, might possible use bridge pattern. option presented bridge section . bridge impossible inconvenient, little metaprogramming symbolise--inject pattern can help.","code":"mtcars %>% dplyr::summarise(.data[c(\"cyl\", \"am\")]) #> Error in `dplyr::summarise()`: #> i In argument: `.data[c(\"cyl\", \"am\")]`. #> Caused by error in `.data[c(\"cyl\", \"am\")]`: #> ! `[` is not supported by the `.data` pronoun, use `[[` or $ instead. vars <- c(\"cyl\", \"am\") mtcars %>% tidyr::pivot_longer(all_of(vars)) #> # A tibble: 64 x 11 #>     mpg  disp    hp  drat    wt  qsec    vs  gear  carb name  value #>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <chr> <dbl> #> 1    21   160   110   3.9  2.62  16.5     0     4     4 cyl       6 #> 2    21   160   110   3.9  2.62  16.5     0     4     4 am        1 #> 3    21   160   110   3.9  2.88  17.0     0     4     4 cyl       6 #> 4    21   160   110   3.9  2.88  17.0     0     4     4 am        1 #> # i 60 more rows"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"bridge-patterns","dir":"Reference","previous_headings":"","what":"Bridge patterns","title":"Data mask programming patterns — topic-data-mask-programming","text":"Sometimes function calling implement behaviour like give arguments function. work around may require little thought since systematic way turning one behaviour another. general technique consists forwarding arguments inside context implements behaviour want. , find way bridge result target verb function.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"across-as-a-selection-to-data-mask-bridge","dir":"Reference","previous_headings":"","what":"across() as a selection to data-mask bridge","title":"Data mask programming patterns — topic-data-mask-programming","text":"dplyr 1.0 added support tidy selections verbs via across(). function normally used mapping columns can also used perform simple selection. instance, like pass argument group_by() tidy-selection interface instead data-masked one, use across() bridge:   Since across() takes selections single argument (unlike select() takes multiple arguments), directly pass .... Instead, take within c(), tidyselect way supplying multiple selections within single argument:","code":"my_group_by <- function(data, var) {   data %>% dplyr::group_by(across({{ var }})) }  mtcars %>% my_group_by(starts_with(\"c\")) my_group_by <- function(.data, ...) {   .data %>% dplyr::group_by(across(c(...))) }  mtcars %>% my_group_by(starts_with(\"c\"), vs:gear)"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"across-all-of-as-a-names-to-data-mask-bridge","dir":"Reference","previous_headings":"","what":"across(all_of()) as a names to data mask bridge","title":"Data mask programming patterns — topic-data-mask-programming","text":"instead forwarding variables across() pass all_of(), create names data mask bridge.   Use bridge technique connect vectors names data-masked context.","code":"my_group_by <- function(data, vars) {   data %>% dplyr::group_by(across(all_of(vars))) }  mtcars %>% my_group_by(c(\"cyl\", \"am\"))"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"transmute-as-a-data-mask-to-selection-bridge","dir":"Reference","previous_headings":"","what":"transmute() as a data-mask to selection bridge","title":"Data mask programming patterns — topic-data-mask-programming","text":"Passing data-masked arguments tidy selection little tricky requires three step process.   first step pass ... expressions transmute(). Unlike mutate(), creates new data frame user inputs. goal step inspect names ..., including default names created unnamed arguments. names, inject arguments mutate() update data frame. Finally, pass names tidy selection via all_of().","code":"my_pivot_longer <- function(data, ...) {   # Forward `...` in data-mask context with `transmute()`   # and save the inputs names   inputs <- dplyr::transmute(data, ...)   names <- names(inputs)    # Update the data with the inputs   data <- dplyr::mutate(data, !!!inputs)    # Select the inputs by name with `all_of()`   tidyr::pivot_longer(data, cols = all_of(names)) }  mtcars %>% my_pivot_longer(cyl, am = am * 100)"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"named-inputs-versus-","dir":"Reference","previous_headings":"","what":"Named inputs versus ...","title":"Data mask programming patterns — topic-data-mask-programming","text":"case named argument, transformation easy. simply surround embraced input R code. instance, my_summarise() function exactly useful compared just calling summarise():   can make useful adding code around variable:   inputs ... however, technique work. need kind templating syntax dots lets us specify R code placeholder dots elements. built tidy eval can use operators like dplyr::across(), dplyr::if_all(), dplyr::if_any(). possible, can template expression manually.","code":"my_summarise <- function(data, var) {   data %>% dplyr::summarise({{ var }}) } my_mean <- function(data, var) {   data %>% dplyr::summarise(mean = mean({{ var }}, na.rm = TRUE)) }"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"transforming-inputs-with-across-","dir":"Reference","previous_headings":"","what":"Transforming inputs with across()","title":"Data mask programming patterns — topic-data-mask-programming","text":"across() operation dplyr convenient way mapping expression across set inputs. create variant my_mean() computes mean() arguments supplied .... easiest way forward dots across() (causes ... inherit tidy selection behaviour):","code":"my_mean <- function(data, ...) {   data %>% dplyr::summarise(across(c(...), ~ mean(.x, na.rm = TRUE))) }  mtcars %>% my_mean(cyl, carb) #> # A tibble: 1 x 2 #>     cyl  carb #>   <dbl> <dbl> #> 1  6.19  2.81  mtcars %>% my_mean(foo = cyl, bar = carb) #> # A tibble: 1 x 2 #>     foo   bar #>   <dbl> <dbl> #> 1  6.19  2.81  mtcars %>% my_mean(starts_with(\"c\"), mpg:disp) #> # A tibble: 1 x 4 #>     cyl  carb   mpg  disp #>   <dbl> <dbl> <dbl> <dbl> #> 1  6.19  2.81  20.1  231."},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask-programming.html","id":"transforming-inputs-with-if-all-and-if-any-","dir":"Reference","previous_headings":"","what":"Transforming inputs with if_all() and if_any()","title":"Data mask programming patterns — topic-data-mask-programming","text":"dplyr::filter() requires different operation across() needs combine logical expressions & |. solve problem dplyr introduced if_all() if_any() variants across(). following example, filter rows set variables equal minimum value:","code":"filter_non_baseline <- function(.data, ...) {   .data %>% dplyr::filter(if_all(c(...), ~ .x != min(.x, na.rm = TRUE))) }  mtcars %>% filter_non_baseline(vs, am, gear)"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask.html","id":null,"dir":"Reference","previous_headings":"","what":"What is data-masking and why do I need {{? — topic-data-mask","title":"What is data-masking and why do I need {{? — topic-data-mask","text":"Data-masking distinctive feature R whereby programming performed directly data set, columns defined normal objects.   data-masking makes easy program interactively data frames, makes harder create functions. Passing data-masked arguments functions requires injection embracing operator {{ , complex cases, injection operator !!.","code":"# Unmasked programming mean(mtcars$cyl + mtcars$am) #> [1] 6.59375  # Referring to columns is an error - Where is the data? mean(cyl + am) #> Error: #> ! object 'cyl' not found  # Data-masking with(mtcars, mean(cyl + am)) #> [1] 6.59375"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask.html","id":"why-does-data-masking-require-embracing-and-injection-","dir":"Reference","previous_headings":"","what":"Why does data-masking require embracing and injection?","title":"What is data-masking and why do I need {{? — topic-data-mask","text":"Injection (also known quasiquotation) metaprogramming feature allows modify parts program. needed hood data-masking works defusing R code prevent immediate evaluation. defused code resumed later context data frame columns defined. see happens pass arguments data-masking function like summarise() normal way:   problem summarise() defuses R code supplied, .e. mean(var1 + var2).  Instead want see mean(cyl + ). need injection, need modify piece code injecting code supplied function place var1 var2. inject function argument data-masked context, just embrace {{:   See Data mask programming patterns learn creating functions around data-masking functions.","code":"my_mean <- function(data, var1, var2) {   dplyr::summarise(data, mean(var1 + var2)) }  my_mean(mtcars, cyl, am) #> Error in `dplyr::summarise()`: #> i In argument: `mean(var1 + var2)`. #> Caused by error: #> ! object 'cyl' not found my_mean <- function(data, var1, var2) {   dplyr::summarise(data, mean({{ var1 }} + {{ var2 }})) }  my_mean(mtcars, cyl, am) #> # A tibble: 1 x 1 #>   `mean(cyl + am)` #>              <dbl> #> 1             6.59"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask.html","id":"what-does-masking-mean-","dir":"Reference","previous_headings":"","what":"What does \"masking\" mean?","title":"What is data-masking and why do I need {{? — topic-data-mask","text":"normal R programming objects defined current environment, instance global environment environment function.   environment also contains functions currently scope. script includes functions attached library() calls; package, functions imported packages. evaluation performed data frame, lose track objects functions necessary perform computations. keep objects functions scope, data frame inserted bottom current chain environments. comes first precedence user environment. words, masks user environment. Since masking blends data user environment giving priority former, R can sometimes use data frame column really intended use local object.   tidy eval framework provides pronouns help disambiguate mask user contexts. often good idea use pronouns production code.   Read data mask ambiguity.","code":"factor <- 1000  # Can now use `factor` in computations mean(mtcars$cyl * factor) #> [1] 6187.5 # Defining an env-variable cyl <- 1000  # Referring to a data-variable dplyr::summarise(mtcars, mean(cyl)) #> # A tibble: 1 x 1 #>   `mean(cyl)` #>         <dbl> #> 1        6.19 cyl <- 1000  mtcars %>%   dplyr::summarise(     mean_data = mean(.data$cyl),     mean_env = mean(.env$cyl)   ) #> # A tibble: 1 x 2 #>   mean_data mean_env #>       <dbl>    <dbl> #> 1      6.19     1000"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask.html","id":"how-does-data-masking-work-","dir":"Reference","previous_headings":"","what":"How does data-masking work?","title":"What is data-masking and why do I need {{? — topic-data-mask","text":"Data-masking relies three language features: Argument defusal substitute() (base R) enquo(), enquos(), {{ (rlang). R code defused can evaluated later special environment enriched data. First class environments. Environments special type list-like object defused R code can evaluated.  named elements environment define objects. Lists data frames can transformed environments:   Explicit evaluation eval() (base) eval_tidy() (rlang). R code defused, evaluation interrupted. can resumed later eval():   default eval() eval_tidy() evaluate current environment.   can supply optional list data frame converted environment.   Evaluation defused code occurs context data mask.","code":"as.environment(mtcars) #> <environment: 0x7febb17e3468> expr(1 + 1) #> 1 + 1  eval(expr(1 + 1)) #> [1] 2 code <- expr(mean(cyl + am)) eval(code) #> Error: #> ! object 'am' not found eval(code, mtcars) #> [1] 6.59375"},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask.html","id":"history","dir":"Reference","previous_headings":"","what":"History","title":"What is data-masking and why do I need {{? — topic-data-mask","text":"tidyverse embraced data-masking approach packages like ggplot2 dplyr eventually developed programming framework rlang package. None possible without following landmark developments S R authors. S language introduced data scopes attach() (Becker, Chambers Wilks, New S Language, 1988). S language introduced data-masked formulas modelling functions (Chambers Hastie, 1993). Peter Dalgaard (R team) wrote frametools package 1997. later included R base::transform() base::subset(). API important source inspiration dplyr package. also first apparition selections, variant data-masking extended codified later tidyselect package. 2000 Luke Tierney (R team) changed formulas keep track original environments. change published R 1.1.0 crucial step towards hygienic data masking, .e. proper resolution symbols original environments. Quosures inspired environment-tracking mechanism formulas. Luke introduced base::() 2001. 2006 data.table package included data-masking selections j arguments [ method data frame. dplyr package published 2014. rlang package developed tidy eval 2017 data-masking framework tidyverse. introduced notions quosure, implicit injection !!  !!!, data pronouns. 2019, injection {{ introduced rlang 0.4.0 simplify defuse--inject pattern. operator allows R programmers transport data-masked arguments across functions intuitively minimal boilerplate.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-data-mask.html","id":"see-also","dir":"Reference","previous_headings":"","what":"See also","title":"What is data-masking and why do I need {{? — topic-data-mask","text":"Data mask programming patterns Defusing R expressions","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-defuse.html","id":null,"dir":"Reference","previous_headings":"","what":"Defusing R expressions — topic-defuse","title":"Defusing R expressions — topic-defuse","text":"piece R code defused, R return value like normally . Instead returns expression special tree-like object describes compute value. defused expressions can thought blueprints recipes computing values. Using expr() can observe difference computing expression defusing :   Evaluation defused expression can resumed time eval() (see also eval_tidy()).   common use case defusing expressions resume evaluation data mask. makes possible expression refer columns data frame regular objects.","code":"# Return the result of `1 + 1` 1 + 1 #> [1] 2  # Return the expression `1 + 1` expr(1 + 1) #> 1 + 1 # Return the expression `1 + 1` e <- expr(1 + 1)  # Return the result of `1 + 1` eval(e) #> [1] 2 e <- expr(mean(cyl)) eval(e, mtcars) #> [1] 6.1875"},{"path":"https://rlang.r-lib.org/dev/reference/topic-defuse.html","id":"do-i-need-to-know-about-defused-expressions-","dir":"Reference","previous_headings":"","what":"Do I need to know about defused expressions?","title":"Defusing R expressions — topic-defuse","text":"tidyverse user rarely need defuse expressions manually expr(), even rarely need resume evaluation eval() eval_tidy(). Instead, call data-masking functions take care defusing arguments resuming context data mask.   important know function defuses arguments requires slightly different methods called function. main thing arguments must transported embrace operator {{. allows data-masking function defuse correct expression.   Read : data-masking need {{? Data mask programming patterns","code":"mtcars %>% dplyr::summarise(   mean(cyl)  # This is defused and data-masked ) #> # A tibble: 1 x 1 #>   `mean(cyl)` #>         <dbl> #> 1        6.19 my_mean <- function(data, var) {   dplyr::summarise(data, mean = mean({{ var }})) }"},{"path":"https://rlang.r-lib.org/dev/reference/topic-defuse.html","id":"the-booby-trap-analogy","dir":"Reference","previous_headings":"","what":"The booby trap analogy","title":"Defusing R expressions — topic-defuse","text":"term \"defusing\" comes analogy evaluation model R. may know, R uses lazy evaluation, means arguments evaluated needed computation. take two functions, ignore() anything argument, force() returns :   warning emitted function actually triggers evaluation argument. Evaluation arguments can chained passing functions. one functions ignores argument, breaks chain evaluation.   way, arguments like booby traps explode (evaluate) touched. Defusing argument can seen defusing booby trap.","code":"ignore <- function(arg) NULL force <- function(arg) arg  ignore(warning(\"boom\")) #> NULL  force(warning(\"boom\")) #> Warning in force(warning(\"boom\")): boom f <- function(x) g(x) g <- function(y) h(y) h <- function(z) ignore(z)  f(warning(\"boom\")) #> NULL expr(force(warning(\"boom\"))) #> force(warning(\"boom\"))"},{"path":"https://rlang.r-lib.org/dev/reference/topic-defuse.html","id":"types-of-defused-expressions","dir":"Reference","previous_headings":"","what":"Types of defused expressions","title":"Defusing R expressions — topic-defuse","text":"Calls, like f(1, 2, 3) 1 + 1 represent action calling function compute new value, vector. Symbols, like x df, represent named objects. object pointed symbol defined function global environment, call environment-variable. object column data frame, call data-variable. Constants, like 1 NULL. can create new call symbol objects using defusing function expr():   Defusing way create defused expressions. can also assemble data:","code":"# Create a symbol representing objects called `foo` expr(foo) #> foo  # Create a call representing the computation of the mean of `foo` expr(mean(foo, na.rm = TRUE)) #> mean(foo, na.rm = TRUE)  # Return a constant expr(1) #> [1] 1  expr(NULL) #> NULL # Assemble a symbol from a string var <- \"foo\" sym(var)  # Assemble a call from strings, symbols, and constants call(\"mean\", sym(var), na.rm = TRUE)"},{"path":"https://rlang.r-lib.org/dev/reference/topic-defuse.html","id":"local-expressions-versus-function-arguments","dir":"Reference","previous_headings":"","what":"Local expressions versus function arguments","title":"Defusing R expressions — topic-defuse","text":"two main ways defuse expressions, correspond two functions rlang, expr() enquo(): can defuse R expressions expr(). can defuse expressions supplied user function en-prefixed operators, enquo() enquos(). operators defuse function arguments.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-defuse.html","id":"defuse-and-inject","dir":"Reference","previous_headings":"","what":"Defuse and inject","title":"Defusing R expressions — topic-defuse","text":"One purpose defusing evaluation expression interface data-masking functions injecting expression back another function !!. defuse--inject pattern.   Defuse--inject usually performed single step embrace operator {{.   Using enquo() !! separately useful complex cases need access defused expression instead just passing .","code":"my_summarise <- function(data, arg) {   # Defuse the user expression in `arg`   arg <- enquo(arg)    # Inject the expression contained in `arg`   # inside a `summarise()` argument   data |> dplyr::summarise(mean = mean(!!arg, na.rm = TRUE)) } my_summarise <- function(data, arg) {   # Defuse and inject in a single step with the embracing operator   data |> dplyr::summarise(mean = mean({{ arg }}, na.rm = TRUE)) }"},{"path":"https://rlang.r-lib.org/dev/reference/topic-defuse.html","id":"defused-arguments-and-quosures","dir":"Reference","previous_headings":"","what":"Defused arguments and quosures","title":"Defusing R expressions — topic-defuse","text":"inspect return values expr() enquo(), notice latter return raw expression like former. Instead returns quosure, wrapper containing expression environment.   R needs information environment properly evaluate argument expressions come different context current function. instance function package calls dplyr::mutate(), quosure environment indicates private functions package defined. Read role quosures quosures needed?.","code":"expr(1 + 1) #> 1 + 1  my_function <- function(arg) enquo(arg) my_function(1 + 1) #> <quosure> #> expr: ^1 + 1 #> env:  global"},{"path":"https://rlang.r-lib.org/dev/reference/topic-defuse.html","id":"comparison-with-base-r","dir":"Reference","previous_headings":"","what":"Comparison with base R","title":"Defusing R expressions — topic-defuse","text":"Defusing known quoting frameworks. equivalent expr() base::bquote(). equivalent enquo() base::substitute(). latter returns naked expression instead quosure. equivalent enquos(...) can defuse dots list naked expressions eval(substitute(alist(...))).","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-double-evaluation.html","id":null,"dir":"Reference","previous_headings":"","what":"The double evaluation problem — topic-double-evaluation","title":"The double evaluation problem — topic-double-evaluation","text":"One inherent risk metaprogramming evaluate multiple times piece code appears evaluated . Take data-masking function takes single input produces two summaries:   function perfectly fine user supplies simple column names. However, data-masked arguments may also include computations.   Computations may slow may produce side effects. reasons, performed many times appear code (unless explicitly documented, e.g. per group grouped data frames). try complex computation:   side effects long running time, clear summarise_stats() evaluates input twice. injected defused expression two different places. data-masked expression created line looks like (caret signs representing quosure boundaries):   times100(cyl) expression evaluated twice, even though appears code. double evaluation bug. One simple way fix assign defused input constant. can refer constant remaining code.   defused input now evaluated injected :","code":"summarise_stats <- function(data, var) {   data %>%     dplyr::summarise(       mean = mean({{ var }}),       sd = sd({{ var }})     ) }  summarise_stats(mtcars, cyl) #> # A tibble: 1 x 2 #>    mean    sd #>   <dbl> <dbl> #> 1  6.19  1.79 summarise_stats(mtcars, cyl * 100) #> # A tibble: 1 x 2 #>    mean    sd #>   <dbl> <dbl> #> 1  619.  179. times100 <- function(x) {   message(\"Takes a long time...\")   Sys.sleep(0.1)    message(\"And causes side effects such as messages!\")   x * 100 }  summarise_stats(mtcars, times100(cyl)) #> Takes a long time... #> And causes side effects such as messages! #> Takes a long time... #> And causes side effects such as messages! #> # A tibble: 1 x 2 #>    mean    sd #>   <dbl> <dbl> #> 1  619.  179. dplyr::summarise(   mean = ^mean(^times100(cyl)),   sd = ^sd(^times100(cyl)) ) summarise_stats <- function(data, var) {   data %>%     dplyr::transmute(       var = {{ var }},     ) %>%     dplyr::summarise(       mean = mean(var),       sd = sd(var)     ) } summarise_stats(mtcars, times100(cyl)) #> Takes a long time... #> And causes side effects such as messages! #> # A tibble: 1 x 2 #>    mean    sd #>   <dbl> <dbl> #> 1  619.  179."},{"path":"https://rlang.r-lib.org/dev/reference/topic-double-evaluation.html","id":"what-about-glue-strings-","dir":"Reference","previous_headings":"","what":"What about glue strings?","title":"The double evaluation problem — topic-double-evaluation","text":"{{ embracing glue strings suffer double evaluation problem:   Since glue string need result expression, original code converted (deparsed) string, evaluate injected expressions.","code":"summarise_stats <- function(data, var) {   data %>%     dplyr::transmute(       var = {{ var }},     ) %>%     dplyr::summarise(       \"mean_{{ var }}\" := mean(var),       \"sd_{{ var }}\" := sd(var)     ) }  summarise_stats(mtcars, times100(cyl)) #> Takes a long time... #> And causes side effects such as messages! #> # A tibble: 1 x 2 #>   `mean_times100(cyl)` `sd_times100(cyl)` #>                  <dbl>              <dbl> #> 1                 619.               179."},{"path":"https://rlang.r-lib.org/dev/reference/topic-embrace-constants.html","id":null,"dir":"Reference","previous_headings":"","what":"Why are strings and other constants enquosed in the empty environment? — topic-embrace-constants","title":"Why are strings and other constants enquosed in the empty environment? — topic-embrace-constants","text":"Function arguments defused quosures keep track environment defused expression.   might noticed constants supplied, quosure tracks empty environment instead current environmnent.   reason compilation R code makes impossible consistently capture environments constants function arguments. Argument defusing relies promise mechanism R lazy evaluation arguments. functions compiled R notices argument constant, avoids creating promise since slow function evaluation. Instead, function directly supplied naked constant instead constant wrapped promise.","code":"quo(1 + 1) #> <quosure> #> expr: ^1 + 1 #> env:  global quos(\"foo\", 1, NULL) #> <list_of<quosure>> #> #> [[1]] #> <quosure> #> expr: ^\"foo\" #> env:  empty #> #> [[2]] #> <quosure> #> expr: ^1 #> env:  empty #> #> [[3]] #> <quosure> #> expr: ^NULL #> env:  empty"},{"path":"https://rlang.r-lib.org/dev/reference/topic-embrace-constants.html","id":"concrete-case-of-promise-unwrapping-by-compilation","dir":"Reference","previous_headings":"","what":"Concrete case of promise unwrapping by compilation","title":"Why are strings and other constants enquosed in the empty environment? — topic-embrace-constants","text":"can observe optimisation calling C-level findVar() function capture promises.   f() called symbolic argument, get promise object created R.   However, supplying constant \"f\" returns constant directly.   Without promise, way figure original environment argument.","code":"# Return the object bound to `arg` without triggering evaluation of # promises f <- function(arg) {   rlang:::find_var(current_env(), sym(\"arg\")) }  # Call `f()` with a symbol or with a constant g <- function(symbolic) {   if (symbolic) {     f(letters)   } else {     f(\"foo\")   } }  # Make sure these small functions are compiled f <- compiler::cmpfun(f) g <- compiler::cmpfun(g) g(symbolic = TRUE) #> <promise: 0x7ffd79bac130> g(symbolic = FALSE) #> [1] \"foo\""},{"path":"https://rlang.r-lib.org/dev/reference/topic-embrace-constants.html","id":"do-we-need-environments-for-constants-","dir":"Reference","previous_headings":"","what":"Do we need environments for constants?","title":"Why are strings and other constants enquosed in the empty environment? — topic-embrace-constants","text":"Data-masking APIs tidyverse intentionally designed need environment constants. Data-masking APIs able interpret constants. can arise normal argument passing seen, injection !!. difference dplyr::mutate(mtcars, var = cyl) dplyr::mutate(mtcars, var = !!mtcars$cyl). Data-masking evaluation idiom, introspective one. behaviour data-masking function depend calling environment constant (symbol evaluating given value) supplied.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-embrace-non-args.html","id":null,"dir":"Reference","previous_headings":"","what":"Does {{ work on regular objects? — topic-embrace-non-args","title":"Does {{ work on regular objects? — topic-embrace-non-args","text":"embrace operator {{ used exclusively function arguments:   However may noticed also works regular objects:   case, {{ captures value expression instead defused expression. function arguments can defused. Note issue also applies enquo() ({{ based).","code":"fn <- function(arg) {   quo(foo({{ arg }})) }  fn(1 + 1) #> <quosure> #> expr: ^foo(^1 + 1) #> env:  0x7ffd89aac518 fn <- function(arg) {   arg <- force(arg)   quo(foo({{ arg }})) }  fn(1 + 1) #> <quosure> #> expr: ^foo(^2) #> env:  0x7ffd8a633398"},{"path":"https://rlang.r-lib.org/dev/reference/topic-embrace-non-args.html","id":"why-is-this-not-an-error-","dir":"Reference","previous_headings":"","what":"Why is this not an error?","title":"Does {{ work on regular objects? — topic-embrace-non-args","text":"Ideally made {{ regular objects error.  However possible compiled R code always possible distinguish regular variable function argument. See strings constants enquosed empty environment? .","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-error-call.html","id":null,"dir":"Reference","previous_headings":"","what":"Including function calls in error messages — topic-error-call","title":"Including function calls in error messages — topic-error-call","text":"Starting rlang 1.0, abort() includes erroring function message default:   works well abort() called directly within failing function. However, abort() call exported another function (call \"error helper\"), need explicit function abort() throwing error .","code":"my_function <- function() {   abort(\"Can't do that.\") }  my_function() #> Error in `my_function()`: #> ! Can't do that."},{"path":"https://rlang.r-lib.org/dev/reference/topic-error-call.html","id":"passing-the-user-context","dir":"Reference","previous_headings":"","what":"Passing the user context","title":"Including function calls in error messages — topic-error-call","text":"two main kinds error helpers: Simple abort() wrappers. often aim adding classes attributes error condition structured way:   Input checking functions. input checker typically passed input argument name. throws error input conform expectations:   cases, default error call helpful end user reflects internal function rather user function:       fix , let abort() know function throwing error passing corresponding function environment call argument:","code":"stop_my_class <- function(message) {   abort(message, class = \"my_class\") } check_string <- function(x, arg = \"x\") {   if (!is_string(x)) {     cli::cli_abort(\"{.arg {arg}} must be a string.\")   } } my_function <- function(x) {   check_string(x)   stop_my_class(\"Unimplemented\") } my_function(NA) #> Error in `check_string()`: #> ! `x` must be a string. my_function(\"foo\") #> Error in `stop_my_class()`: #> ! Unimplemented stop_my_class <- function(message, call = caller_env()) {   abort(message, class = \"my_class\", call = call) }  check_string <- function(x, arg = \"x\", call = caller_env()) {   if (!is_string(x)) {     cli::cli_abort(\"{.arg {arg}} must be a string.\", call = call)   } } my_function(NA) #> Error in `my_function()`: #> ! `x` must be a string. my_function(\"foo\") #> Error in `my_function()`: #> ! Unimplemented"},{"path":"https://rlang.r-lib.org/dev/reference/topic-error-call.html","id":"input-checkers-and-caller-arg-","dir":"Reference","previous_headings":"","what":"Input checkers and caller_arg()","title":"Including function calls in error messages — topic-error-call","text":"caller_arg() helper useful input checkers check input behalf another function. Instead hard-coding arg = \"x\", forcing callers supply \"x\" name argument checked, use caller_arg().   combination substitute() rlang::as_label() provides generally applicable default:","code":"check_string <- function(x,                          arg = caller_arg(x),                          call = caller_env()) {   if (!is_string(x)) {     cli::cli_abort(\"{.arg {arg}} must be a string.\", call = call)   } } my_function <- function(my_arg) {   check_string(my_arg) }  my_function(NA) #> Error in `my_function()`: #> ! `my_arg` must be a string."},{"path":"https://rlang.r-lib.org/dev/reference/topic-error-call.html","id":"testthat-workflow","dir":"Reference","previous_headings":"","what":"testthat workflow","title":"Including function calls in error messages — topic-error-call","text":"Error snapshots main way checking correct error call included error message. However need opt new testthat display warning error snapshots. new display, printed rlang, including call field. makes easy monitor full appearance warning error messages displayed users. display applied packages yet. testthat 3.1.2, depend explicitly rlang >= 1.0.0 opt . Starting testthat 3.1.3, depending rlang, matter version, sufficient opt . future, new display enabled packages. enabled, create error snapshots :   make sure snapshot coverage error messages sufficient package.","code":"expect_snapshot(error = TRUE, {   my_function() })"},{"path":"https://rlang.r-lib.org/dev/reference/topic-error-chaining.html","id":null,"dir":"Reference","previous_headings":"","what":"Including contextual information with error chains — topic-error-chaining","title":"Including contextual information with error chains — topic-error-chaining","text":"Error chaining mechanism providing contextual information error occurs. multiple situations might able provide context helpful quickly understand cause origin error: Mentioning high level context low level error arised. E.g. chaining low-level HTTP error high-level download error. Mentioning pipeline step user error occured. major use-case NSE interfaces tidyverse, e.g. dplyr, tidymodels ggplot2. Mentioning iteration context user error occurred. instance, input file processing documents, iteration number key running user code loop. example chained error dplyr shows pipeline step (mutate()) iteration context (group ID) function called user failed:   cases, two errors play, chained together: causal error, interrupted current course action. contextual error, expresses higher-level information something goes wrong. may one contextual error error chain, always one causal error.","code":"add <- function(x, y) x + y  mtcars |>   dplyr::group_by(cyl) |>   dplyr::mutate(new = add(disp, \"foo\")) #> Error in `dplyr::mutate()`: #> i In argument: `new = add(disp, \"foo\")`. #> i In group 1: `cyl = 4`. #> Caused by error in `x + y`: #> ! non-numeric argument to binary operator"},{"path":"https://rlang.r-lib.org/dev/reference/topic-error-chaining.html","id":"rethrowing-errors","dir":"Reference","previous_headings":"","what":"Rethrowing errors","title":"Including contextual information with error chains — topic-error-chaining","text":"create error chain, must first capture causal errors occur. recommend using try_fetch() instead tryCatch() withCallingHandlers(). Compared tryCatch(), try_fetch() fully preserves context error. important debugging ensures complete backtraces reported users (e.g. via last_error()) allows options(error = recover) reach deepest error context. Compared withCallingHandlers(), also preserves error context, try_fetch() able catch stack overflow errors R versions >= 4.2.0. practice, try_fetch() works just like tryCatch(). takes pairs error class names handling functions. chain error, simply rethrow error handler passing parent argument. example, create with_ function. , function sets configuration (case, chained errors) executing code supplied input:   Typically, use error helper another user-facing function.   Altough created chained error, error call contextual error quite right. mentions name error helper instead name user-facing function. read Including function calls error messages, may suspect need pass call argument abort(). exactly needs happen fix call backtrace issues:   Now passed caller environment call argument, abort() automatically picks correspondin function call execution frame:","code":"with_chained_errors <- function(expr) {   try_fetch(     expr,     error = function(cnd) {       abort(\"Problem during step.\", parent = cnd)     }   ) }  with_chained_errors(1 + \"\") #> Error in `with_chained_errors()`: #> ! Problem during step. #> Caused by error in `1 + \"\"`: #> ! non-numeric argument to binary operator my_verb <- function(expr) {   with_chained_errors(expr) }  my_verb(add(1, \"\")) #> Error in `with_chained_errors()`: #> ! Problem during step. #> Caused by error in `x + y`: #> ! non-numeric argument to binary operator with_chained_errors <- function(expr, call = caller_env()) {   try_fetch(     expr,     error = function(cnd) {       abort(\"Problem during step.\", parent = cnd, call = call)     }   ) } my_verb(add(1, \"\")) #> Error in `my_verb()`: #> ! Problem during step. #> Caused by error in `x + y`: #> ! non-numeric argument to binary operator"},{"path":"https://rlang.r-lib.org/dev/reference/topic-error-chaining.html","id":"side-note-about-missing-arguments","dir":"Reference","previous_headings":"","what":"Side note about missing arguments","title":"Including contextual information with error chains — topic-error-chaining","text":"my_verb() implemented lazy evaluation pattern. user input kept unevaluated error chain context set . downside arrangement missing argument errors reported wrong context:   fix , simply require arguments setting chained error context, instance check_required() input checker exported rlang:","code":"my_verb() #> Error in `my_verb()`: #> ! Problem during step. #> Caused by error in `my_verb()`: #> ! argument \"expr\" is missing, with no default my_verb <- function(expr) {   check_required(expr)   with_chained_errors(expr) }  my_verb() #> Error in `my_verb()`: #> ! `expr` is absent but must be supplied."},{"path":"https://rlang.r-lib.org/dev/reference/topic-error-chaining.html","id":"taking-full-ownership-of-a-causal-error","dir":"Reference","previous_headings":"","what":"Taking full ownership of a causal error","title":"Including contextual information with error chains — topic-error-chaining","text":"also possible completely take ownership causal error rethrow user-friendly error message. case, original error completely hidden end user. Opting approach instead chaining carefully considered hiding causal error may deprive users precious debugging information. general, hiding user errors (e.g. dplyr inputs) way likely bad idea. may appropriate hide low-level errors, e.g. replacing HTTP errors high-level download error. Similarly, tidyverse packages like dplyr replacing low-level vctrs errors higher level errors crafting. Hiding causal errors indiscriminately likely avoided may suppress information unexpected errors. general, rethrowing unchained errors done specific error classes. rethow error without chaining , completely take causal error user point view, fetch try_fetch() throw new error. difference throwing chained error parent argument set NA. also omit parent argument entirely, passing NA lets abort() know rethrowing error handler hide corresponding error helpers backtrace.   low-level error overtaken, good practice store high-level error object, can inspected debugging purposes. snippet , stored error field. one way accessing original error subsetting object returned last_error():","code":"with_own_scalar_errors <- function(expr, call = caller_env()) {   try_fetch(     expr,     vctrs_error_scalar_type = function(cnd) {       abort(         \"Must supply a vector.\",         parent = NA,         error = cnd,         call = call       )     }   ) }  my_verb <- function(expr) {   check_required(expr)   with_own_scalar_errors(     vctrs::vec_assert(expr)   ) }  my_verb(env()) #> Error in `my_verb()`: #> ! Must supply a vector. rlang::last_error()$error"},{"path":"https://rlang.r-lib.org/dev/reference/topic-error-chaining.html","id":"case-study-mapping-with-chained-errors","dir":"Reference","previous_headings":"","what":"Case study: Mapping with chained errors","title":"Including contextual information with error chains — topic-error-chaining","text":"One good use case chained errors adding information iteration state looping set inputs. illustrate , implement version map() / lapply() chains iteration error captured user error. minimal implementation map():   implementation, user idea iteration failed error occurs:","code":"my_map <- function(.xs, .fn, ...) {   out <- new_list(length(.xs))    for (i in seq_along(.xs)) {     out[[i]] <- .fn(.xs[[i]], ...)   }    out }  list(1, 2) |> my_map(add, 100) #> [[1]] #> [1] 101 #> #> [[2]] #> [1] 102 list(1, \"foo\") |> my_map(add, 100) #> Error in `x + y`: #> ! non-numeric argument to binary operator"},{"path":"https://rlang.r-lib.org/dev/reference/topic-error-chaining.html","id":"rethrowing-with-iteration-information","dir":"Reference","previous_headings":"","what":"Rethrowing with iteration information","title":"Including contextual information with error chains — topic-error-chaining","text":"improve wrap loop try_fetch() call rethrow errors iteration information. Make sure call try_fetch() outside loop avoid massive performance hit:   , error chain created rethrowing handler now provides users number failing iteration:","code":"my_map <- function(.xs, .fn, ...) {   out <- new_list(length(.xs))   i <- 0L    try_fetch(     for (i in seq_along(.xs)) {       out[[i]] <- .fn(.xs[[i]], ...)     },     error = function(cnd) {       abort(         sprintf(\"Problem while mapping element %d.\", i),         parent = cnd       )     }   )    out } list(1, \"foo\") |> my_map(add, 100) #> Error in `my_map()`: #> ! Problem while mapping element 2. #> Caused by error in `x + y`: #> ! non-numeric argument to binary operator"},{"path":"https://rlang.r-lib.org/dev/reference/topic-error-chaining.html","id":"dealing-with-errors-thrown-from-the-mapped-function","dir":"Reference","previous_headings":"","what":"Dealing with errors thrown from the mapped function","title":"Including contextual information with error chains — topic-error-chaining","text":"One problem though, user error call informative error occurs immediately function supplied my_map():   Functions names . variable refers function name. case, mapped function passed argument variable .fn. , error happens, name reported users. One approach fix inspect call field error. detect .fn call, replace defused code supplied .fn argument:   voilà!","code":"my_function <- function(x) {   if (!is_string(x)) {     abort(\"`x` must be a string.\")   } }  list(1, \"foo\") |> my_map(my_function) #> Error in `my_map()`: #> ! Problem while mapping element 1. #> Caused by error in `.fn()`: #> ! `x` must be a string. my_map <- function(.xs, .fn, ...) {   # Capture the defused code supplied as `.fn`   fn_code <- substitute(.fn)    out <- new_list(length(.xs))    for (i in seq_along(.xs)) {     try_fetch(       out[[i]] <- .fn(.xs[[i]], ...),       error = function(cnd) {         # Inspect the `call` field to detect `.fn` calls         if (is_call(cnd$call, \".fn\")) {           # Replace `.fn` by the defused code.           # Keep existing arguments.           cnd$call[[1]] <- fn_code         }         abort(           sprintf(\"Problem while mapping element %s.\", i),           parent = cnd         )       }     )   }    out } list(1, \"foo\") |> my_map(my_function) #> Error in `my_map()`: #> ! Problem while mapping element 1. #> Caused by error in `my_function()`: #> ! `x` must be a string."},{"path":"https://rlang.r-lib.org/dev/reference/topic-inject-out-of-context.html","id":null,"dir":"Reference","previous_headings":"","what":"What happens if I use injection operators out of context? — topic-inject-out-of-context","title":"What happens if I use injection operators out of context? — topic-inject-out-of-context","text":"injection operators {{, !!, !!! extension R syntax developed tidyverse packages. part base R, suffer limitations. particular specific error thrown used unexpected places.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-inject-out-of-context.html","id":"using-out-of-context","dir":"Reference","previous_headings":"","what":"Using {{ out of context","title":"What happens if I use injection operators out of context? — topic-inject-out-of-context","text":"embrace operator {{ feature available data-masked arguments powered tidy eval. use elsewhere, interpreted double { wrapping. R language, { like ( takes multiple expressions instead one:   Just like can wrap expression many parentheses like, can wrap multiple times braces:   nothing prevents embracing function argument context operation implemented. R just treat braces like set parentheses silently return result:   sort -effect embracing avoided real code falsely suggests function supports tidy eval operator something special happening. However many cases embracing done implement data masking. likely function called data-variables references R able resolve properly:   Since () base data-masking function support tidy eval operators, embrace operator work get object found error.","code":"{   1 # Discarded   2 } #> [1] 2  list(   { message(\"foo\"); 2 } ) #> foo #> [[1]] #> [1] 2 ((1)) #> [1] 1  {{ 2 }} #> [1] 2 f <- function(arg) list({{ arg }}) f(1) #> [[1]] #> [1] 1 my_mean <- function(data, var) {   with(data, mean({{ var }})) }  my_mean(mtcars, cyl) #> Error: #> ! object 'cyl' not found"},{"path":"https://rlang.r-lib.org/dev/reference/topic-inject-out-of-context.html","id":"using-and-out-of-context","dir":"Reference","previous_headings":"","what":"Using !! and !!! out of context","title":"What happens if I use injection operators out of context? — topic-inject-out-of-context","text":"injection operators !! !!! implemented data-masked arguments, dynamic dots, within inject(). used contexts, interpreted R double triple negations. Double negation can used ordinary code convert input logical:   Triple negation essentially simple negation:   means injection operators used wrong place, interpreted negation. best case scenario get type error:   worst case, R silently convert input logical. Unfortunately systematic way checking errors.","code":"!!10 #> [1] TRUE  !!0 #> [1] FALSE !10 #> [1] FALSE  !!!10 #> [1] FALSE !\"foo\" #> Error in `!\"foo\"`: #> ! invalid argument type  !quote(foo) #> Error in `!quote(foo)`: #> ! invalid argument type  !quote(foo()) #> Error in `!quote(foo())`: #> ! invalid argument type"},{"path":"https://rlang.r-lib.org/dev/reference/topic-inject.html","id":null,"dir":"Reference","previous_headings":"","what":"Injecting with !!, !!!, and glue syntax — topic-inject","title":"Injecting with !!, !!!, and glue syntax — topic-inject","text":"injection operators extensions R implemented rlang modify piece code R processes . two main families: dynamic dots operators, !!! \"{\". metaprogramming operators !!, {{, \"{{\". Splicing !!! can also done metaprogramming context.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-inject.html","id":"dots-injection","dir":"Reference","previous_headings":"","what":"Dots injection","title":"Injecting with !!, !!!, and glue syntax — topic-inject","text":"Unlike regular ..., dynamic dots programmable injection operators.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-inject.html","id":"splicing-with-","dir":"Reference","previous_headings":"","what":"Splicing with !!!","title":"Injecting with !!, !!!, and glue syntax — topic-inject","text":"instance, take function like rbind() takes data .... bind rows, supply separate arguments:   bind variable number rows stored list? base R solution invoke rbind() .call():   Functions implement dynamic dots include built-way folding list arguments .... illustrate , create variant rbind() takes dynamic dots collecting ... list2():   can used just like rbind():   list arguments can supplied splicing list !!!:","code":"rbind(a = 1:2, b = 3:4) #>   [,1] [,2] #> a    1    2 #> b    3    4 rows <- list(a = 1:2, b = 3:4)  do.call(\"rbind\", rows) #>   [,1] [,2] #> a    1    2 #> b    3    4 rbind2 <- function(...) {   do.call(\"rbind\", list2(...)) } rbind2(a = 1:2, b = 3:4) #>   [,1] [,2] #> a    1    2 #> b    3    4 rbind2(!!!rows, c = 5:6) #>   [,1] [,2] #> a    1    2 #> b    3    4 #> c    5    6"},{"path":"https://rlang.r-lib.org/dev/reference/topic-inject.html","id":"injecting-names-with-","dir":"Reference","previous_headings":"","what":"Injecting names with \"{\"","title":"Injecting with !!, !!!, and glue syntax — topic-inject","text":"related problem comes argument name stored variable. dynamic dots, can inject name using glue syntax \"{\":","code":"name <- \"foo\"  rbind2(\"{name}\" := 1:2, bar = 3:4) #>     [,1] [,2] #> foo    1    2 #> bar    3    4  rbind2(\"prefix_{name}\" := 1:2, bar = 3:4) #>            [,1] [,2] #> prefix_foo    1    2 #> bar           3    4"},{"path":"https://rlang.r-lib.org/dev/reference/topic-inject.html","id":"metaprogramming-injection","dir":"Reference","previous_headings":"","what":"Metaprogramming injection","title":"Injecting with !!, !!!, and glue syntax — topic-inject","text":"Data-masked arguments support following injection operators. can also explicitly enabled inject().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-inject.html","id":"embracing-with-","dir":"Reference","previous_headings":"","what":"Embracing with {{","title":"Injecting with !!, !!!, and glue syntax — topic-inject","text":"embracing operator {{ made specially function arguments. defuses expression supplied argument immediately injects place. injected argument evaluated another context data mask.   Learn pattern Data mask programming patterns.","code":"# Inject function arguments that might contain # data-variables by embracing them with {{ }} mean_by <- function(data, by, var) {   data %>%     dplyr::group_by({{ by }}) %>%     dplyr::summarise(avg = mean({{ var }}, na.rm = TRUE)) }  # The data-variables `cyl` and `disp` inside the # env-variables `by` and `var` are injected inside `group_by()` # and `summarise()` mtcars %>% mean_by(by = cyl, var = disp) #> # A tibble: 3 x 2 #>     cyl   avg #>   <dbl> <dbl> #> 1     4  105. #> 2     6  183. #> 3     8  353."},{"path":"https://rlang.r-lib.org/dev/reference/topic-inject.html","id":"injecting-with-","dir":"Reference","previous_headings":"","what":"Injecting with !!","title":"Injecting with !!, !!!, and glue syntax — topic-inject","text":"Unlike !!! injects list arguments, injection operator !! (pronounced \"bang-bang\") injects single object. One use case !!  substitute environment-variable (created <-) data-variable (inside data frame).   Another use case inject variable value avoid name collisions.   Note cases need injection !!. instance, .data .env pronouns provide intuitive alternatives injecting column name injecting value.","code":"# The env-variable `var` contains a data-symbol object, in this # case a reference to the data-variable `height` var <- data_sym(\"disp\")  # We inject the data-variable contained in `var` inside `summarise()` mtcars %>%   dplyr::summarise(avg = mean(!!var, na.rm = TRUE)) #> # A tibble: 1 x 1 #>     avg #>   <dbl> #> 1  231. df <- data.frame(x = 1)  # This name conflicts with a column in `df` x <- 100  # Inject the env-variable df %>%   dplyr::mutate(x = x / !!x) #>      x #> 1 0.01"},{"path":"https://rlang.r-lib.org/dev/reference/topic-inject.html","id":"splicing-with--1","dir":"Reference","previous_headings":"","what":"Splicing with !!!","title":"Injecting with !!, !!!, and glue syntax — topic-inject","text":"splice operator !!! dynamic dots can also used metaprogramming context (inside data-masked arguments inside inject()). instance, reimplement rbind2() function presented using inject() instead .call():   two things going . collect ... list2() callers rbind2() may use !!!. use inject() rbind2() may use !!! splice list arguments passed rbind2().","code":"rbind2 <- function(...) {   inject(rbind(!!!list2(...))) }"},{"path":"https://rlang.r-lib.org/dev/reference/topic-inject.html","id":"injection-in-other-languages","dir":"Reference","previous_headings":"","what":"Injection in other languages","title":"Injecting with !!, !!!, and glue syntax — topic-inject","text":"Injection known quasiquotation programming languages computer science. expr() similar quasiquotation operator !! unquote operator. terms rich history Lisp languages, live modern languages like Julia Racket. base R, quasiquotation performed bquote(). main difference rlang languages quasiquotation often implicit instead explicit. can use injection operators defusing / quoting function (unless function defuses argument special operator like enquo0()). case lisp languages example injection / unquoting explicit enabled within backquote.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-inject.html","id":"see-also","dir":"Reference","previous_headings":"","what":"See also","title":"Injecting with !!, !!!, and glue syntax — topic-inject","text":"happens use injection operators context?","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-metaprogramming.html","id":null,"dir":"Reference","previous_headings":"","what":"Metaprogramming patterns — topic-metaprogramming","title":"Metaprogramming patterns — topic-metaprogramming","text":"patterns covered article rely metaprogramming, ability defuse, create, expand, inject R expressions. good place start new programming language Metaprogramming chapter Advanced R book. already, read Data mask programming patterns covers simpler patterns require much theory get speed. covers concepts like argument behaviours various patterns can add toolbox (forwarding, names, bridge, transformative patterns).","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/topic-metaprogramming.html","id":"defuse-and-inject","dir":"Reference","previous_headings":"","what":"Defuse and inject","title":"Metaprogramming patterns — topic-metaprogramming","text":"{{ ... sufficient purposes. Sometimes however, necessary decompose forwarding action two constitutive steps, defusing injecting. {{ combination enquo() !!. functions completely equivalent:   Passing ... equivalent combination enquos() !!!:   advantage decomposing steps gain access defused expressions. defused, can inspect modify expressions injecting target context.","code":"my_summarise <- function(data, var) {   data %>% dplyr::summarise({{ var }}) } my_summarise <- function(data, var) {   data %>% dplyr::summarise(!!enquo(var)) } my_group_by <- function(.data, ...) {   .data %>% dplyr::group_by(...) } my_group_by <- function(.data, ...) {   .data %>% dplyr::group_by(!!!enquos(...)) }"},{"path":"https://rlang.r-lib.org/dev/reference/topic-metaprogramming.html","id":"inspecting-input-labels","dir":"Reference","previous_headings":"","what":"Inspecting input labels","title":"Metaprogramming patterns — topic-metaprogramming","text":"instance, create automatic name defused argument using as_label():   essentially equivalent formatting argument using englue():   multiple arguments, use plural variant enquos(). Set .named TRUE automatically call as_label() inputs user provided name (behaviour dplyr verbs):   Just like dplyr::mutate(), user can override automatic names supplying explicit names:   Defuse--inject patterns useful transforming inputs. applications explored Transformation patterns section.","code":"f <- function(var) {   var <- enquo(var)   as_label(var) }  f(cyl) #> [1] \"cyl\"  f(1 + 1) #> [1] \"1 + 1\" f2 <- function(var) {   englue(\"{{ var }}\") }  f2(1 + 1) #> [1] \"1 + 1\" g <- function(...) {   vars <- enquos(..., .named = TRUE)   names(vars) }  g(cyl, 1 + 1) #> [1] \"cyl\"   \"1 + 1\" g(foo = cyl, bar = 1 + 1) #> [1] \"foo\" \"bar\""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/topic-metaprogramming.html","id":"symbolise-and-inject","dir":"Reference","previous_headings":"","what":"Symbolise and inject","title":"Metaprogramming patterns — topic-metaprogramming","text":"symbolise--inject pattern names pattern can use across(all_of()) supported. consists creating defused expressions refer data-variables represented names vector. injected data mask context. Symbolise single string sym() data_sym():   Symbolise character vector syms() data_syms().   Simple symbols returned sym() syms() work wider variety cases (base functions particular) use mostly use data_sym() data_syms() robust (see data mask ambiguity). Note return symbols per se, instead create calls $ subset .data pronoun. Since .data pronoun tidy eval feature, use base functions. rule, prefer data_-prefixed variants injecting tidy eval functions unprefixed functions base functions. list symbols can injected data-masked dots splice operator !!!, injects element list separate argument. instance, implement group_by() variant takes character vector column names, might write:   complex case, might want add R code around symbols. requires transformation patterns, see section .","code":"var <- \"cyl\"  sym(var) #> cyl  data_sym(var) #> .data$cyl vars <- c(\"cyl\", \"am\")  syms(vars) #> [[1]] #> cyl #> #> [[2]] #> am  data_syms(vars) #> [[1]] #> .data$cyl #> #> [[2]] #> .data$am my_group_by <- function(data, vars) {   data %>% dplyr::group_by(!!!data_syms(vars)) }  my_group_by(vars)"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/topic-metaprogramming.html","id":"mutate-as-a-data-mask-to-selection-bridge","dir":"Reference","previous_headings":"","what":"mutate() as a data-mask to selection bridge","title":"Metaprogramming patterns — topic-metaprogramming","text":"variant transmute() bridge pattern described Data mask programming patterns materialise ... intermediate step. Instead, ... expressions defused inspected. expressions, rather columns, spliced mutate().   Defuse ... expressions. .named argument ensures unnamed inputs get default name, just like passed mutate(). Take names list inputs. names, inject argument expressions mutate() update data frame. Finally, pass names tidy selection via all_of().","code":"my_pivot_longer <- function(data, ...) {   # Defuse the dots and inspect the names   dots <- enquos(..., .named = TRUE)   names <- names(dots)    # Pass the inputs to `mutate()`   data <- data %>% dplyr::mutate(!!!dots)    # Select `...` inputs by name with `all_of()`   data %>%     tidyr::pivot_longer(cols = all_of(names)) }  mtcars %>% my_pivot_longer(cyl, am = am * 100)"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/topic-metaprogramming.html","id":"transforming-inputs-manually","dir":"Reference","previous_headings":"","what":"Transforming inputs manually","title":"Metaprogramming patterns — topic-metaprogramming","text":"across() variants available, need transform inputs using metaprogramming techniques. illustrate technique reimplement my_mean() without using across(). pattern consists defusing input expression, building larger calls around , finally inject modified expressions inside data-masking functions. start single named argument simplicity:   ... technique similar, though little involved. use plural variants enquos() !!!. also loop variable number inputs using purrr::map(). pattern otherwise basically :   Note inheriting data-masking behaviour summarise() effectively forwarded ... inside verb. different transformation patterns based across() inherit tidy selection behaviour. practice, means function support selection helpers syntax. Instead, gains ability create new vectors fly:","code":"my_mean <- function(data, var) {   # Defuse the expression   var <- enquo(var)    # Wrap it in a call to `mean()`   var <- expr(mean(!!var, na.rm = TRUE))    # Inject the expanded expression   data %>% dplyr::summarise(mean = !!var) }  mtcars %>% my_mean(cyl) #> # A tibble: 1 x 1 #>    mean #>   <dbl> #> 1  6.19 my_mean <- function(.data, ...) {   # Defuse the dots. Make sure they are automatically named.   vars <- enquos(..., .named = TRUE)    # Map over each defused expression and wrap it in a call to `mean()`   vars <- purrr::map(vars, ~ expr(mean(!!.x, na.rm = TRUE)))    # Inject the expressions   .data %>% dplyr::summarise(!!!vars) }  mtcars %>% my_mean(cyl) #> # A tibble: 1 x 1 #>     cyl #>   <dbl> #> 1  6.19 mtcars %>% my_mean(cyl = cyl * 100) #> # A tibble: 1 x 1 #>     cyl #>   <dbl> #> 1  619."},{"path":"https://rlang.r-lib.org/dev/reference/topic-metaprogramming.html","id":"base-patterns","dir":"Reference","previous_headings":"","what":"Base patterns","title":"Metaprogramming patterns — topic-metaprogramming","text":"section, review patterns programming base data-masking functions. essentially consist building evaluating expressions data mask. review patterns compare rlang idioms.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-metaprogramming.html","id":"data-masked-get-","dir":"Reference","previous_headings":"","what":"Data-masked get()","title":"Metaprogramming patterns — topic-metaprogramming","text":"simplest version pattern, get() called variable name retrieve objects data mask:   sort pattern susceptible names collisions. instance, input data frame might contain variable called var:   general, prefer symbol injection get() prevent sort collisions. base functions need enable injection operators explicitly using inject():   See data mask ambiguity information names collisions.","code":"var <- \"cyl\"  with(mtcars, mean(get(var))) #> [1] 6.1875 df <- data.frame(var = \"wrong\")  with(df, mean(get(var))) #> Error in `get()`: #> ! object 'wrong' not found inject(   with(mtcars, mean(!!sym(var))) ) #> [1] 6.1875"},{"path":"https://rlang.r-lib.org/dev/reference/topic-metaprogramming.html","id":"data-masked-parse-and-eval-","dir":"Reference","previous_headings":"","what":"Data-masked parse() and eval()","title":"Metaprogramming patterns — topic-metaprogramming","text":"involved pattern consists building R code string evaluating mask:   , code variable vulnerable names collisions. importantly, var1 var2 user inputs, contain adversarial code. Evaluating code assembled strings always risky business:   big deal code used internally. However, code part public Shiny app Internet users exploit. even internally, parsing source bugs variable names contain syntactic symbols like - :.   reasons, always prefer build code instead parsing code. Building variable names sym() way sanitising inputs.   adversarial input now produces error:   Finally, recommended inject code instead evaluating avoid names collisions:","code":"var1 <- \"am\" var2 <- \"vs\"  code <- paste(var1, \"==\", var2) with(mtcars, mean(eval(parse(text = code)))) #> [1] 0.59375 var1 <- \"(function() {   Sys.sleep(Inf)  # Could be a coin mining routine })()\" var2 <- \"vs\"  code <- paste(var1, \"==\", var2) with(mtcars, mean(eval(parse(text = code)))) var1 <- \":var:\" var2 <- \"vs\"  code <- paste(var1, \"==\", var2) with(mtcars, mean(eval(parse(text = code)))) #> Error in `parse()`: #> ! <text>:1:1: unexpected ':' #> 1: : #>     ^ var1 <- \"(function() {   Sys.sleep(Inf)  # Could be a coin mining routine })()\" var2 <- \"vs\"  code <- call(\"==\", sym(var1), sym(var2))  code #> `(function() {\\n  Sys.sleep(Inf)  # Could be a coin mining routine\\n})()` == #>     vs with(mtcars, mean(eval(code))) #> Error: #> ! object '(function() {\\n  Sys.sleep(Inf)  # Could be a coin mining routine\\n})()' not found var1 <- \"am\" var2 <- \"vs\"  code <- call(\"==\", sym(var1), sym(var2)) inject(   with(mtcars, mean(!!code)) ) #> [1] 0.59375"},{"path":"https://rlang.r-lib.org/dev/reference/topic-multiple-columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Taking multiple columns without ... — topic-multiple-columns","title":"Taking multiple columns without ... — topic-multiple-columns","text":"guide compare ways taking multiple columns single function argument. refresher (see programming patterns article), two common ways passing arguments data-masking functions. single arguments, embrace {{:   multiple arguments ..., pass functions also take ... like group_by(), pass within c() functions taking tidy selection single argument like pivot_longer():   want take multiple columns single named argument rather ...?","code":"my_group_by <- function(data, var) {   data %>% dplyr::group_by({{ var }}) }  my_pivot_longer <- function(data, var) {   data %>% tidyr::pivot_longer({{ var }}) } # Pass dots through my_group_by <- function(.data, ...) {   .data %>% dplyr::group_by(...) }  my_pivot_longer <- function(.data, ...) {   .data %>% tidyr::pivot_longer(c(...)) }"},{"path":"https://rlang.r-lib.org/dev/reference/topic-multiple-columns.html","id":"using-tidy-selections","dir":"Reference","previous_headings":"","what":"Using tidy selections","title":"Taking multiple columns without ... — topic-multiple-columns","text":"idiomatic tidyverse way taking multiple columns single argument take tidy selection (see Argument behaviours section). tidy selections, syntax passing multiple columns single argument c():   Since {{ inherits behaviour, implementation my_pivot_longer() automatically allows multiple columns passing:   group_by(), takes data-masked arguments, use across() bridge (see Bridge patterns).   embracing tidyselect context using across() possible, might implement tidyselect behaviour manually tidyselect::eval_select().","code":"mtcars %>% tidyr::pivot_longer(c(am, cyl, vs)) my_pivot_longer <- function(data, var) {   data %>% tidyr::pivot_longer({{ var }}) }  mtcars %>% my_pivot_longer(c(am, cyl, vs)) my_group_by <- function(data, var) {   data %>% dplyr::group_by(across({{ var }})) }  mtcars %>% my_group_by(c(am, cyl, vs))"},{"path":"https://rlang.r-lib.org/dev/reference/topic-multiple-columns.html","id":"using-external-defusal","dir":"Reference","previous_headings":"","what":"Using external defusal","title":"Taking multiple columns without ... — topic-multiple-columns","text":"implement argument tidyselect behaviour, necessary defuse argument. However defusing argument historically behaved like regular argument rather disruptive breaking change. implement tidy selections ggplot2 facetting functions like facet_grid() facet_wrap(). alternative use external defusal arguments. formula interfaces instance. modelling function takes formula regular argument formula defuses user code:   created, defused expressions contained formula passed around like normal argument. similar approach taken update facet_ functions tidy eval. vars() function (simple alias quos()) provided users can defuse arguments externally.   can implement approach simply taking list defused expressions argument. list can passed usual way functions taking lists:   can spliced !!!:","code":"my_lm <- function(data, f, ...) {   lm(f, data, ...) }  mtcars %>% my_lm(disp ~ drat) ggplot2::facet_grid(   ggplot2::vars(cyl),   ggplot2::vars(am, vs) ) my_facet_grid <- function(rows, cols, ...) {   ggplot2::facet_grid(rows, cols, ...) } my_group_by <- function(data, vars) {   stopifnot(is_quosures(vars))   data %>% dplyr::group_by(!!!vars) }  mtcars %>% my_group_by(dplyr::vars(cyl, am))"},{"path":"https://rlang.r-lib.org/dev/reference/topic-multiple-columns.html","id":"a-non-approach-parsing-lists","dir":"Reference","previous_headings":"","what":"A non-approach: Parsing lists","title":"Taking multiple columns without ... — topic-multiple-columns","text":"Intuitively, many programmers want take list expressions single argument try defuse argument parse . user expected supply multiple arguments within list() expression. call detected, arguments retrieved spliced !!!. Otherwise, user assumed supplied single argument injected !!. implementation along lines might look like :   work simple cases:   However parsing approach quickly shows limits:   Also, better overall consistency interfaces use tidyselect syntax c() passing multiple columns. general, recommend use either tidyselect external defusal approaches.","code":"my_group_by <- function(data, vars) {   vars <- enquo(vars)    if (quo_is_call(vars, \"list\")) {     expr <- quo_get_expr(vars)     env <- quo_get_env(vars)     args <- as_quosures(call_args(expr), env = env)     data %>% dplyr::group_by(!!!args)   } else {     data %>% dplyr::group_by(!!vars)   } } mtcars %>% my_group_by(cyl) %>% dplyr::group_vars() #> [1] \"cyl\"  mtcars %>% my_group_by(list(cyl, am)) %>% dplyr::group_vars() #> [1] \"cyl\" \"am\" mtcars %>% my_group_by(list2(cyl, am)) #> Error in `group_by()`: Can't add columns. #> i `..1 = list2(cyl, am)`. #> i `..1` must be size 32 or 1, not 2."},{"path":"https://rlang.r-lib.org/dev/reference/topic-quosure.html","id":null,"dir":"Reference","previous_headings":"","what":"What are quosures and when are they needed? — topic-quosure","title":"What are quosures and when are they needed? — topic-quosure","text":"quosure special type defused expression keeps track original context expression written . tracking capabilities quosures important interfacing data-masking functions together functions might come two unrelated environments, like two different packages.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-quosure.html","id":"blending-environments","dir":"Reference","previous_headings":"","what":"Blending environments","title":"What are quosures and when are they needed? — topic-quosure","text":"take example R user calls function summarise_bmi() foo package summarise data frame statistics BMI value. height variable data frame metres, use custom function div100() rescale column.   summarise_bmi() function data-masking function defined namespace foo package looks like :   foo package uses custom function bmi() perform computation two vectors. interfaces summarise_stats() defined bar, another package whose namespace looks like :   package bar uses custom function, check_numeric(), validate input. also interfaces data-masking functions dplyr (using define--constant trick avoid issues double evaluation). three data-masking functions simultaneously interfacing snippet: bottom, dplyr::transmute() takes data-masked input, creates data frame single column named var. , bar::summarise_stats() takes data-masked input inside dplyr::transmute() checks numeric. first , foo::summarise_bmi() takes two data-masked inputs inside bar::summarise_stats() transforms single BMI value. fourth context, global environment summarise_bmi() called two columns defined data frame, one transformed fly user function div100(). contexts (except extent global environment) contain functions private invisible foreign functions. Yet, final expanded data-masked expression evaluated line looks like (caret characters indicating quosure boundaries):   role quosures let R know check_numeric() found bar package, bmi() foo package, div100() global environment.","code":"# Global environment of user  div100 <- function(x) {   x / 100 }  dplyr::starwars %>%   foo::summarise_bmi(mass, div100(height)) # Namespace of package foo  bmi <- function(mass, height) {   mass / height^2 }  summarise_bmi <- function(data, mass, height) {   data %>%     bar::summarise_stats(bmi({{ mass }}, {{ height }})) } # Namespace of package bar  check_numeric <- function(x) {   stopifnot(is.numeric(x))   x }  summarise_stats <- function(data, var) {   data %>%     dplyr::transmute(       var = check_numeric({{ var }})     ) %>%     dplyr::summarise(       mean = mean(var, na.rm = TRUE),       sd = sd(var, na.rm = TRUE)     ) } dplyr::transmute(   var = ^check_numeric(^bmi(^mass, ^div100(height))) )"},{"path":"https://rlang.r-lib.org/dev/reference/topic-quosure.html","id":"when-should-i-create-quosures-","dir":"Reference","previous_headings":"","what":"When should I create quosures?","title":"What are quosures and when are they needed? — topic-quosure","text":"tidyverse user generally need worry quosures {{ ... create . Introductory texts like Programming dplyr standard data-mask programming patterns even mention term. complex cases might need create quosures enquo() enquos() (even though generally need know care functions return quosures). section, explore quosures necessary advanced applications.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-quosure.html","id":"foreign-and-local-expressions","dir":"Reference","previous_headings":"","what":"Foreign and local expressions","title":"What are quosures and when are they needed? — topic-quosure","text":"rule thumb, quosures needed arguments defused enquo() enquos() ({{ calls enquo() implicitly):   Wrapping defused arguments quosures needed expressions supplied argument comes different environment, environment user. local expressions created function, generally need create quosures:   Using quo() instead expr() worked superfluous dplyr::summarise(), uses enquos(), already charge wrapping expression within quosure scoped environment. applies evaluate manually. default, eval() eval_tidy() capture environment:","code":"my_function <- function(var) {   var <- enquo(var)   their_function(!!var) }  # Equivalently my_function <- function(var) {   their_function({{ var }}) } my_mean <- function(data, var) {   # `expr()` is sufficient, no need for `quo()`   expr <- expr(mean({{ var }}))   dplyr::summarise(data, !!expr) }  my_mean(mtcars, cyl) #> # A tibble: 1 x 1 #>   `mean(cyl)` #>         <dbl> #> 1        6.19 my_mean <- function(data, var) {   expr <- expr(mean({{ var }}))   eval_tidy(expr, data) }  my_mean(mtcars, cyl) #> [1] 6.1875"},{"path":"https://rlang.r-lib.org/dev/reference/topic-quosure.html","id":"external-defusing","dir":"Reference","previous_headings":"","what":"External defusing","title":"What are quosures and when are they needed? — topic-quosure","text":"exception rule thumb (wrap foreign expressions quosures, expressions) arises function takes multiple expressions list instead .... preferred approach case take tidy selection users can combine multiple columns using c(). possible, can take list externally defused expressions:   pattern, dplyr::vars() defuses expressions externally. creates list quosures expressions passed around function function like regular arguments. fact, dplyr::vars() ggplot2::vars() simple aliases quos().   information external defusing, see Taking multiple columns without ....","code":"my_group_by <- function(data, vars) {   stopifnot(is_quosures(vars))   data %>% dplyr::group_by(!!!vars) }  mtcars %>% my_group_by(dplyr::vars(cyl, am)) dplyr::vars(cyl, am) #> <list_of<quosure>> #> #> [[1]] #> <quosure> #> expr: ^cyl #> env:  global #> #> [[2]] #> <quosure> #> expr: ^am #> env:  global"},{"path":"https://rlang.r-lib.org/dev/reference/topic-quosure.html","id":"technical-description-of-quosures","dir":"Reference","previous_headings":"","what":"Technical description of quosures","title":"What are quosures and when are they needed? — topic-quosure","text":"quosure carries two things: expression (get quo_get_expr()). environment (get quo_get_env()). implements behaviours: callable. Evaluation produces result. historical reasons, base::eval() support quosure evaluation. Quosures currently require eval_tidy(). like fix limitation future. hygienic. evaluates tracked environment. maskable. evaluated data mask (currently masks created eval_tidy() new_data_mask()), mask comes first scope quosure environment. Conceptually, quosure inherits two chains environments, data mask user environment. practice rlang implements special scoping rechaining top data mask quosure environment currently evaluation. similarities promises (ones R uses implement lazy evaluation, async expressions promises package) quosures. One important difference promises evaluated cache result subsequent evaluation. Quosures behave like calls can evaluated repeatedly, potentially different data mask. property useful implement split-apply-combine evaluations.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/topic-quosure.html","id":"see-also","dir":"Reference","previous_headings":"","what":"See also","title":"What are quosures and when are they needed? — topic-quosure","text":"enquo() enquos() defuse function arguments quosures. main way quosures created. quo() like expr() wraps quosure. Usually needed wrap local expressions . quo_get_expr() quo_get_env() access quosure components. new_quosure() as_quosure() assemble quosure components.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/trace_back.html","id":null,"dir":"Reference","previous_headings":"","what":"Capture a backtrace — trace_back","title":"Capture a backtrace — trace_back","text":"backtrace captures sequence calls lead current function (sometimes called call stack). lazy evaluation, call stack R actually tree, print() method object reveal. Users rarely need call trace_back() manually. Instead, signalling error abort() setting global_entrace() common way create backtraces error thrown. Inspect backtrace created recent error last_error(). trace_length() returns number frames backtrace.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/trace_back.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capture a backtrace — trace_back","text":"","code":"trace_back(top = NULL, bottom = NULL)  trace_length(trace)"},{"path":"https://rlang.r-lib.org/dev/reference/trace_back.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capture a backtrace — trace_back","text":"top first frame environment included backtrace. becomes top backtrace tree represents oldest call backtrace. needed particular call trace_back() indirectly larger context, example tests inside RMarkdown document want knitr evaluation mechanisms appear backtrace. supplied, rlang_trace_top_env global option consulted. makes possible trim embedding context backtraces created option set. knitr progress, default value option knitr::knit_global() knitr context trimmed backtraces. bottom last frame environment included backtrace. becomes rightmost leaf backtrace tree represents youngest call backtrace. Set like capture backtrace without capture context. Can also integer passed caller_env(). trace backtrace created trace_back().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/trace_back.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Capture a backtrace — trace_back","text":"","code":"# Trim backtraces automatically (this improves the generated # documentation for the rlang website and the same trick can be # useful within knitr documents): options(rlang_trace_top_env = current_env())  f <- function() g() g <- function() h() h <- function() trace_back()  # When no lazy evaluation is involved the backtrace is linear # (i.e. every call has only one child) f() #>     ▆ #>  1. └─f() #>  2.   └─g() #>  3.     └─h()  # Lazy evaluation introduces a tree like structure identity(identity(f())) #>     ▆ #>  1. ├─base::identity(identity(f())) #>  2. ├─base::identity(f()) #>  3. └─f() #>  4.   └─g() #>  5.     └─h() identity(try(f())) #>     ▆ #>  1. ├─base::identity(try(f())) #>  2. ├─base::try(f()) #>  3. │ └─base::tryCatch(...) #>  4. │   └─base (local) tryCatchList(expr, classes, parentenv, handlers) #>  5. │     └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]]) #>  6. │       └─base (local) doTryCatch(return(expr), name, parentenv, handler) #>  7. └─f() #>  8.   └─g() #>  9.     └─h() try(identity(f())) #>     ▆ #>  1. ├─base::try(identity(f())) #>  2. │ └─base::tryCatch(...) #>  3. │   └─base (local) tryCatchList(expr, classes, parentenv, handlers) #>  4. │     └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]]) #>  5. │       └─base (local) doTryCatch(return(expr), name, parentenv, handler) #>  6. ├─base::identity(f()) #>  7. └─f() #>  8.   └─g() #>  9.     └─h()  # When printing, you can request to simplify this tree to only show # the direct sequence of calls that lead to `trace_back()` x <- try(identity(f())) x #>     ▆ #>  1. ├─base::try(identity(f())) #>  2. │ └─base::tryCatch(...) #>  3. │   └─base (local) tryCatchList(expr, classes, parentenv, handlers) #>  4. │     └─base (local) tryCatchOne(expr, names, parentenv, handlers[[1L]]) #>  5. │       └─base (local) doTryCatch(return(expr), name, parentenv, handler) #>  6. ├─base::identity(f()) #>  7. └─f() #>  8.   └─g() #>  9.     └─h() print(x, simplify = \"branch\") #>  1. base::try(identity(f())) #>  7. f() #>  8. g() #>  9. h()  # With a little cunning you can also use it to capture the # tree from within a base NSE function x <- NULL with(mtcars, {x <<- f(); 10}) #> [1] 10 x #>     ▆ #>  1. ├─base::with(...) #>  2. └─base::with.default(...) #>  3.   └─base::eval(substitute(expr), data, enclos = parent.frame()) #>  4.     └─base::eval(substitute(expr), data, enclos = parent.frame()) #>  5.       └─f() #>  6.         └─g() #>  7.           └─h()   # Restore default top env for next example options(rlang_trace_top_env = NULL)  # When code is executed indirectly, i.e. via source or within an # RMarkdown document, you'll tend to get a lot of guff at the beginning # related to the execution environment: conn <- textConnection(\"summary(f())\") source(conn, echo = TRUE, local = TRUE) #>  #> > summary(f()) #>      ▆ #>   1. └─pkgdown::build_site_github_pages(new_process = FALSE, install = FALSE) #>   2.   └─pkgdown::build_site(...) #>   3.     └─pkgdown:::build_site_local(...) #>   4.       └─pkgdown::build_reference(...) #>   5.         ├─pkgdown:::unwrap_purrr_error(...) #>   6.         │ └─base::withCallingHandlers(...) #>   7.         └─purrr::map(...) #>   8.           └─purrr:::map_(\"list\", .x, .f, ..., .progress = .progress) #>   9.             ├─purrr:::with_indexed_errors(...) #>  10.             │ └─base::withCallingHandlers(...) #>  11.             ├─purrr:::call_with_cleanup(...) #>  12.             └─pkgdown (local) .f(.x[[i]], ...) #>  13.               ├─base::withCallingHandlers(...) #>  14.               └─pkgdown:::data_reference_topic(...) #>  15.                 └─pkgdown:::run_examples(...) #>  16.                   └─pkgdown:::highlight_examples(code, topic, env = env) #>  17.                     └─downlit::evaluate_and_highlight(...) #>  18.                       └─evaluate::evaluate(code, child_env(env), new_device = TRUE, output_handler = output_handler) #>  19.                         ├─base::withRestarts(...) #>  20.                         │ └─base (local) withRestartList(expr, restarts) #>  21.                         │   ├─base (local) withOneRestart(withRestartList(expr, restarts[-nr]), restarts[[nr]]) #>  22.                         │   │ └─base (local) doWithOneRestart(return(expr), restart) #>  23.                         │   └─base (local) withRestartList(expr, restarts[-nr]) #>  24.                         │     └─base (local) withOneRestart(expr, restarts[[1L]]) #>  25.                         │       └─base (local) doWithOneRestart(return(expr), restart) #>  26.                         ├─evaluate:::with_handlers(...) #>  27.                         │ ├─base::eval(call) #>  28.                         │ │ └─base::eval(call) #>  29.                         │ └─base::withCallingHandlers(...) #>  30.                         ├─base::withVisible(eval(expr, envir)) #>  31.                         └─base::eval(expr, envir) #>  32.                           └─base::eval(expr, envir) #>  33.                             ├─base::source(conn, echo = TRUE, local = TRUE) #>  34.                             │ ├─base::withVisible(eval(ei, envir)) #>  35.                             │ └─base::eval(ei, envir) #>  36.                             │   └─base::eval(ei, envir) #>  37.                             ├─base::summary(f()) #>  38.                             └─f() #>  39.                               └─g() #>  40.                                 └─h() close(conn)  # To automatically strip this off, specify which frame should be # the top of the backtrace. This will automatically trim off calls # prior to that frame: top <- current_env() h <- function() trace_back(top)  conn <- textConnection(\"summary(f())\") source(conn, echo = TRUE, local = TRUE) #>  #> > summary(f()) #>     ▆ #>  1. ├─base::summary(f()) #>  2. └─f() #>  3.   └─g() #>  4.     └─h() close(conn)"},{"path":"https://rlang.r-lib.org/dev/reference/try_fetch.html","id":null,"dir":"Reference","previous_headings":"","what":"Try an expression with condition handlers — try_fetch","title":"Try an expression with condition handlers — try_fetch","text":"try_fetch() establishes handlers conditions given class (\"error\", \"warning\", \"message\", ...). Handlers functions take condition object argument called corresponding condition class signalled. condition handler can: Recover conditions value. case computation expr aborted recovery value returned try_fetch(). Error recovery useful want errors abruptly interrupt program resume catching site instead.   Rethrow conditions, e.g. using abort(msg, parent = cnd). See parent argument abort(). typically done add information low-level errors high-level context occurred.   Inspect conditions, instance log data warnings errors. case, handler must return zap() sentinel instruct try_fetch() ignore (zap) particular handler. next matching handler called , errors bubble user handler remains.   Whereas tryCatch() catches conditions (discarding running code along way) calls handler, try_fetch() first calls handler condition top currently running code (fetches stands) catches return value. subtle difference implications debuggability functions. See comparison tryCatch() section . Another difference try_fetch() base equivalent errors matched across chains, see parent argument abort(). useful property makes try_fetch() insensitive changes implementation context evaluation cause classed error suddenly get chained contextual error. Note chained conditions inherited, see .inherit argument abort() warn(). particular, downgraded conditions (e.g. error warning warning message) matched across parents.","code":"# Recover with the value 0 try_fetch(1 + \"\", error = function(cnd) 0) try_fetch(1 + \"\", error = function(cnd) abort(\"Failed.\", parent = cnd)) log <- NULL try_fetch(1 + \"\", error = function(cnd) {   log <<- cnd   zap() })"},{"path":"https://rlang.r-lib.org/dev/reference/try_fetch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Try an expression with condition handlers — try_fetch","text":"","code":"try_fetch(expr, ...)"},{"path":"https://rlang.r-lib.org/dev/reference/try_fetch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Try an expression with condition handlers — try_fetch","text":"expr R expression. ... <dynamic-dots> Named condition handlers. names specify condition class handler called.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/try_fetch.html","id":"stack-overflows","dir":"Reference","previous_headings":"","what":"Stack overflows","title":"Try an expression with condition handlers — try_fetch","text":"stack overflow occurs program keeps adding stack memory (whose size limited unlike heap memory) exhausted.   memory limited errors happen, possible call handlers existing program stack. Instead, error conditions first caught try_fetch() error handlers called. Catching error interrupts program try_fetch() context, allows R reclaim stack memory. practical implication error handlers never assume whole call stack preserved. instance trace_back() capture might miss frames. Note error handlers run stack overflows R >= 4.2. older versions R handlers simply run. errors inherit class stackOverflowError R 4.2. Consider using tryCatch() instead critical error handlers need capture errors old versions R.","code":"# A function that calls itself indefinitely causes stack overflows f <- function() f() f() #> Error: C stack usage  9525680 is too close to the limit"},{"path":"https://rlang.r-lib.org/dev/reference/try_fetch.html","id":"comparison-with-trycatch-","dir":"Reference","previous_headings":"","what":"Comparison with tryCatch()","title":"Try an expression with condition handlers — try_fetch","text":"try_fetch() generalises tryCatch() withCallingHandlers() single function. reproduces behaviour calling exiting handlers depending return value handler. handler returns zap() sentinel, taken calling handler declines recover condition. Otherwise, taken exiting handler returns value catching site. important difference tryCatch() try_fetch() program expr still fully running error handler called. call stack preserved, makes possible capture full backtrace within handler, e.g. rethrowing error abort(parent = cnd). Technically, try_fetch() similar (implemented top ) base::withCallingHandlers() tryCatch().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/type-predicates.html","id":null,"dir":"Reference","previous_headings":"","what":"Type predicates — type-predicates","title":"Type predicates — type-predicates","text":"type predicates aim make type testing R consistent. wrappers around base::typeof(), operate level beneath S3/S4 etc.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/type-predicates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Type predicates — type-predicates","text":"","code":"is_list(x, n = NULL)  is_atomic(x, n = NULL)  is_vector(x, n = NULL)  is_integer(x, n = NULL)  is_double(x, n = NULL, finite = NULL)  is_complex(x, n = NULL, finite = NULL)  is_character(x, n = NULL)  is_logical(x, n = NULL)  is_raw(x, n = NULL)  is_bytes(x, n = NULL)  is_null(x)"},{"path":"https://rlang.r-lib.org/dev/reference/type-predicates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Type predicates — type-predicates","text":"x Object tested. n Expected length vector. finite Whether values vector finite. non-finite values NA, Inf, -Inf NaN. Setting something NULL can expensive whole vector needs traversed checked.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/type-predicates.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Type predicates — type-predicates","text":"Compared base R functions: predicates vectors include n argument pattern-matching vector length. Unlike .atomic() R < 4.4.0, is_atomic() return TRUE NULL. Starting R 4.4.0 .atomic(NULL) returns FALSE. Unlike .vector(), is_vector() tests object atomic vector list. .vector checks presence attributes (name).","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/type_of.html","id":null,"dir":"Reference","previous_headings":"","what":"Base type of an object — type_of","title":"Base type of an object — type_of","text":"equivalent base::typeof() differences make dispatching easier: type one-sided formulas \"quote\". type character vectors length 1 \"string\". type special builtin functions \"primitive\".","code":""},{"path":"https://rlang.r-lib.org/dev/reference/type_of.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Base type of an object — type_of","text":"","code":"type_of(x)"},{"path":"https://rlang.r-lib.org/dev/reference/type_of.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Base type of an object — type_of","text":"x R object.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/type_of.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Base type of an object — type_of","text":"","code":"type_of(10L) #> Warning: `type_of()` is deprecated as of rlang 0.4.0. #> Please use `typeof()` or your own version instead. #> This warning is displayed once every 8 hours. #> [1] \"integer\"  # Quosures are treated as a new base type but not formulas: type_of(quo(10L)) #> [1] \"formula\" type_of(~10L) #> [1] \"formula\"  # Compare to base::typeof(): typeof(quo(10L)) #> [1] \"language\"  # Strings are treated as a new base type: type_of(letters) #> [1] \"character\" type_of(letters[[1]]) #> [1] \"string\"  # This is a bit inconsistent with the core language tenet that data # types are vectors. However, treating strings as a different # scalar type is quite helpful for switching on function inputs # since so many arguments expect strings: switch_type(\"foo\", character = abort(\"vector!\"), string = \"result\") #> [1] \"result\"  # Special and builtin primitives are both treated as primitives. # That's because it is often irrelevant which type of primitive an # input is: typeof(list) #> [1] \"builtin\" typeof(`$`) #> [1] \"special\" type_of(list) #> [1] \"primitive\" type_of(`$`) #> [1] \"primitive\""},{"path":"https://rlang.r-lib.org/dev/reference/vec_poke_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Poke values into a vector — vec_poke_n","title":"Poke values into a vector — vec_poke_n","text":"tools R experts . copy elements y x mutation. x, .e. created certain exist context. Otherwise might create unintended side effects undefined consequences.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/vec_poke_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Poke values into a vector — vec_poke_n","text":"","code":"vec_poke_n(x, start, y, from = 1L, n = length(y))  vec_poke_range(x, start, y, from = 1L, to = length(y) - from + 1L)"},{"path":"https://rlang.r-lib.org/dev/reference/vec_poke_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Poke values into a vector — vec_poke_n","text":"x destination vector. start index indicating start modifying x. y source vector. index indicating start copying y. n many elements copied y x. index indicating end range copy y.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/vector-coercion.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce an object to a base type — vector-coercion","title":"Coerce an object to a base type — vector-coercion","text":"equivalent base functions (e.g. .logical(), .list(), etc), perform coercion rather conversion. means generic call S3 conversion methods. attempt coerce base type input. addition, stricter implicit coercion rules never attempt kind parsing. E.g. try figure character vector represents integers booleans. Finally, treat attributes consistently, unlike base R functions: attributes except names removed.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/vector-coercion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce an object to a base type — vector-coercion","text":"","code":"as_logical(x)  as_integer(x)  as_double(x)  as_complex(x)  as_character(x, encoding = NULL)  as_list(x)"},{"path":"https://rlang.r-lib.org/dev/reference/vector-coercion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce an object to a base type — vector-coercion","text":"x object coerce base type. encoding non-null, set encoding mark. declarative, encoding conversion performed.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/vector-coercion.html","id":"lifecycle","dir":"Reference","previous_headings":"","what":"Lifecycle","title":"Coerce an object to a base type — vector-coercion","text":"functions deprecated favour vctrs::vec_cast().","code":""},{"path":"https://rlang.r-lib.org/dev/reference/vector-coercion.html","id":"coercion-to-logical-and-numeric-atomic-vectors","dir":"Reference","previous_headings":"","what":"Coercion to logical and numeric atomic vectors","title":"Coerce an object to a base type — vector-coercion","text":"logical vectors: Integer integerish double vectors. See is_integerish(). integer vectors: Logical integerish double vectors. double vectors: Logical integer vectors. complex vectors: Logical, integer double vectors.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/vector-coercion.html","id":"coercion-to-character-vectors","dir":"Reference","previous_headings":"","what":"Coercion to character vectors","title":"Coerce an object to a base type — vector-coercion","text":"as_character() as_string() optional encoding argument specify encoding. R uses information internal handling strings character vectors. Note declarative, encoding conversion attempted. Note as_string() can coerce symbols scalar character vector. makes code explicit adds extra type check.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/vector-coercion.html","id":"coercion-to-lists","dir":"Reference","previous_headings":"","what":"Coercion to lists","title":"Coerce an object to a base type — vector-coercion","text":"as_list() coerces vector dictionary types (environments example dictionary type). Unlike base::.list(), as_list() removes attributes except names.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/vector-coercion.html","id":"effects-of-removing-attributes","dir":"Reference","previous_headings":"","what":"Effects of removing attributes","title":"Coerce an object to a base type — vector-coercion","text":"technical side-effect removing attributes input underlying objects copied. performance implications case lists shallow copy: list structure copied, contents (see duplicate()). However, aware atomic vectors containing large amounts data copied. general, attribute modification creates copy, better avoid using attributes heavy atomic vectors. Uncopyable objects like environments symbols exception rule: case, attributes modification happens place side-effects.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/vector-coercion.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce an object to a base type — vector-coercion","text":"","code":"# Coercing atomic vectors removes attributes with both base R and rlang: x <- structure(TRUE, class = \"foo\", bar = \"baz\") as.logical(x) #> [1] TRUE  # But coercing lists preserves attributes in base R but not rlang: l <- structure(list(TRUE), class = \"foo\", bar = \"baz\") as.list(l) #> [[1]] #> [1] TRUE #>  #> attr(,\"class\") #> [1] \"foo\" #> attr(,\"bar\") #> [1] \"baz\" as_list(l) #> Warning: `as_list()` is deprecated as of rlang 0.4.0 #> Please use `vctrs::vec_cast()` instead. #> This warning is displayed once every 8 hours. #> [[1]] #> [1] TRUE #>   # Implicit conversions are performed in base R but not rlang: as.logical(l) #> [1] TRUE if (FALSE) { # \\dontrun{ as_logical(l) } # }  # Conversion methods are bypassed, making the result of the # coercion more predictable: as.list.foo <- function(x) \"wrong\" as.list(l) #> [1] \"wrong\" as_list(l) #> [[1]] #> [1] TRUE #>   # The input is never parsed. E.g. character vectors of numbers are # not converted to numeric types: as.integer(\"33\") #> [1] 33 if (FALSE) { # \\dontrun{ as_integer(\"33\") } # }   # With base R tools there is no way to convert an environment to a # list without either triggering method dispatch, or changing the # original environment. as_list() makes it easy: x <- structure(as_environment(mtcars[1:2]), class = \"foobar\") as.list.foobar <- function(x) abort(\"dont call me\") as_list(x) #> $cyl #>  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4 #>  #> $mpg #>  [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 #> [14] 15.2 10.4 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 #> [27] 26.0 30.4 15.8 19.7 15.0 21.4 #>"},{"path":"https://rlang.r-lib.org/dev/reference/vector-construction.html","id":null,"dir":"Reference","previous_headings":"","what":"Create vectors — vector-construction","title":"Create vectors — vector-construction","text":"atomic vector constructors equivalent c() : allow explicit output type. Implicit coercions (e.g. integer logical) follow rules described vector-coercion. use dynamic dots.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/vector-construction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create vectors — vector-construction","text":"","code":"lgl(...)  int(...)  dbl(...)  cpl(...)  chr(...)  bytes(...)"},{"path":"https://rlang.r-lib.org/dev/reference/vector-construction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create vectors — vector-construction","text":"... Components new vector. Bare lists explicitly spliced lists spliced.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/vector-construction.html","id":"life-cycle","dir":"Reference","previous_headings":"","what":"Life cycle","title":"Create vectors — vector-construction","text":"abbreviated constructors lgl() probably moved vctrs package point. marked questioning. Automatic splicing soft-deprecated trigger warning future version. Please splice explicitly !!!.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/vector-construction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create vectors — vector-construction","text":"","code":"# These constructors are like a typed version of c(): c(TRUE, FALSE) #> [1]  TRUE FALSE lgl(TRUE, FALSE) #> [1]  TRUE FALSE  # They follow a restricted set of coercion rules: int(TRUE, FALSE, 20) #> [1]  1  0 20  # Lists can be spliced: dbl(10, !!! list(1, 2L), TRUE) #> [1] 10  1  2  1   # They splice names a bit differently than c(). The latter # automatically composes inner and outer names: c(a = c(A = 10), b = c(B = 20, C = 30)) #> a.A b.B b.C  #>  10  20  30   # On the other hand, rlang's constructors use the inner names and issue a # warning to inform the user that the outer names are ignored: dbl(a = c(A = 10), b = c(B = 20, C = 30)) #> Warning: Outer names are only allowed for unnamed scalar atomic inputs #>  A  B  C  #> 10 20 30  dbl(a = c(1, 2)) #> Warning: Outer names are only allowed for unnamed scalar atomic inputs #> [1] 1 2  # As an exception, it is allowed to provide an outer name when the # inner vector is an unnamed scalar atomic: dbl(a = 1) #> a  #> 1   # Spliced lists behave the same way: dbl(!!! list(a = 1)) #> a  #> 1  dbl(!!! list(a = c(A = 1))) #> Warning: Outer names are only allowed for unnamed scalar atomic inputs #> A  #> 1   # bytes() accepts integerish inputs bytes(1:10) #>  [1] 01 02 03 04 05 06 07 08 09 0a bytes(0x01, 0xff, c(0x03, 0x05), list(10, 20, 30L)) #> [1] 01 ff 03 05 0a 14 1e"},{"path":"https://rlang.r-lib.org/dev/reference/with_env.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate an expression within a given environment — with_env","title":"Evaluate an expression within a given environment — with_env","text":"functions evaluate expr within given environment (env with_env(), child current environment locally). rely eval_bare() features lighter evaluation mechanism base R base::eval(), also subtle implications evaluting stack sensitive functions (see help eval_bare()). locally() equivalent base function base::local() produces much cleaner evaluation stack, stack-consistent semantics. thus suited experimenting R language.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/with_env.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate an expression within a given environment — with_env","text":"","code":"with_env(env, expr)  locally(expr)"},{"path":"https://rlang.r-lib.org/dev/reference/with_env.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate an expression within a given environment — with_env","text":"env environment within evaluate expr. Can object get_env() method. expr expression evaluate.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/with_env.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate an expression within a given environment — with_env","text":"","code":"# with_env() is handy to create formulas with a given environment: env <- child_env(\"rlang\") f <- with_env(env, ~new_formula()) identical(f_env(f), env) #> [1] TRUE  # Or functions with a given enclosure: fn <- with_env(env, function() NULL) identical(get_env(fn), env) #> [1] TRUE   # Unlike eval() it doesn't create duplicates on the evaluation # stack. You can thus use it e.g. to create non-local returns: fn <- function() {   g(current_env())   \"normal return\" } g <- function(env) {   with_env(env, return(\"early return\")) } fn() #> [1] \"early return\"   # Since env is passed to as_environment(), it can be any object with an # as_environment() method. For strings, the pkg_env() is returned: with_env(\"base\", ~mtcars) #> ~mtcars #> <environment: base>  # This can be handy to put dictionaries in scope: with_env(mtcars, cyl) #>  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4"},{"path":"https://rlang.r-lib.org/dev/reference/with_handlers.html","id":null,"dir":"Reference","previous_headings":"","what":"Establish handlers on the stack — with_handlers","title":"Establish handlers on the stack — with_handlers","text":"rlang 1.0.0, with_handlers() deprecated. Use base functions experimental try_fetch() function instead.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/with_handlers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Establish handlers on the stack — with_handlers","text":"","code":"with_handlers(.expr, ...)  calling(handler)  exiting(handler)"},{"path":"https://rlang.r-lib.org/dev/reference/with_handlers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Establish handlers on the stack — with_handlers","text":".expr, ..., handler","code":""},{"path":"https://rlang.r-lib.org/dev/reference/wref_key.html","id":null,"dir":"Reference","previous_headings":"","what":"Get key/value from a weak reference object — wref_key","title":"Get key/value from a weak reference object — wref_key","text":"Get key/value weak reference object","code":""},{"path":"https://rlang.r-lib.org/dev/reference/wref_key.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get key/value from a weak reference object — wref_key","text":"","code":"wref_key(x)  wref_value(x)"},{"path":"https://rlang.r-lib.org/dev/reference/wref_key.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get key/value from a weak reference object — wref_key","text":"x weak reference object.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/reference/zap.html","id":null,"dir":"Reference","previous_headings":"","what":"Create zap objects — zap","title":"Create zap objects — zap","text":"zap() creates sentinel object indicates object removed. instance, named zaps instruct env_bind() call_modify() remove objects environment call. advantage zap objects unambiguously signal intent removing object. Sentinels like NULL missing_arg() ambiguous represent valid R objects.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/zap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create zap objects — zap","text":"","code":"zap()  is_zap(x)"},{"path":"https://rlang.r-lib.org/dev/reference/zap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create zap objects — zap","text":"x object test.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/zap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create zap objects — zap","text":"","code":"# Create one zap object: zap() #> <zap>  # Create a list of zaps: rep(list(zap()), 3) #> [[1]] #> <zap> #>  #> [[2]] #> <zap> #>  #> [[3]] #> <zap> #>  rep_named(c(\"foo\", \"bar\"), list(zap())) #> $foo #> <zap> #>  #> $bar #> <zap> #>"},{"path":"https://rlang.r-lib.org/dev/reference/zap_srcref.html","id":null,"dir":"Reference","previous_headings":"","what":"Zap source references — zap_srcref","title":"Zap source references — zap_srcref","text":"number situations R creates source references: Reading R code file source() parse() might save source references inside calls function {. sys.call() includes source reference possible. Creating closure stores source reference call function, . source references take space might cause number issues. zap_srcref() recursively walks expressions functions remove source references.","code":""},{"path":"https://rlang.r-lib.org/dev/reference/zap_srcref.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Zap source references — zap_srcref","text":"","code":"zap_srcref(x)"},{"path":"https://rlang.r-lib.org/dev/reference/zap_srcref.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Zap source references — zap_srcref","text":"x R object. Functions calls walked recursively.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-development-version","dir":"Changelog","previous_headings":"","what":"rlang (development version)","title":"rlang (development version)","text":"C code longer calls memcpy() memset() 0-length R object memory (#1797).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-116","dir":"Changelog","previous_headings":"","what":"rlang 1.1.6","title":"rlang 1.1.6","text":"CRAN release: 2025-04-11 Fixes CRAN checks. Progress towards making rlang conformant public C API R. env_browse() env_is_browsed() now defunct require API longer available packages (#1727). SEXP iterator rlang C library (used r-lib/memtools) now behind feature flag requires private API accessors. Compile rlang -DRLANG_USE_PRIVATE_ACCESSORS enable . env_unlock() now defunct recent versions R long make possible unlock environment (#1705). Make sure use --date version pkgload (>= 1.4.0) following change. is_dictionaryish() now return TRUE NULL (@ilovemane, #1712).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-114","dir":"Changelog","previous_headings":"","what":"rlang 1.1.4","title":"rlang 1.1.4","text":"CRAN release: 2024-06-04 Added missing C level r_dyn_raw_push_back() r_dyn_chr_push_back() utilities (#1699). last_trace() hyperlinks now use modern x-r-run format (#1678).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-113","dir":"Changelog","previous_headings":"","what":"rlang 1.1.3","title":"rlang 1.1.3","text":"CRAN release: 2024-01-10 Fix CRAN checks. %||% now reexported base newer R versions. avoids conflict messages attaching importing rlang.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-112","dir":"Changelog","previous_headings":"","what":"rlang 1.1.2","title":"rlang 1.1.2","text":"CRAN release: 2023-11-04 Fixed --one typo traceback source column location (#1633). abort() now respects base R global option, options(show.error.messages = FALSE) (#1630). obj_type_friendly() now displays first class S3 objects (#1622). expr_label() now back-compatility respect changes made R version 4.4 .atomic(NULL) (#1655) Performance improvement .rlang_cli_compat() (#1657).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-111","dir":"Changelog","previous_headings":"","what":"rlang 1.1.1","title":"rlang 1.1.1","text":"CRAN release: 2023-04-28 englue() now allows omitting {{. make easier embed external functions need support either { {{ (#1601). Fix CRAN checks. stop_input_type() now handles () input literally arg (#1607, @simonpcouch). parse_expr() parse_exprs() now faster getOption(\"keep.source\") TRUE (#1603).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-110","dir":"Changelog","previous_headings":"","what":"rlang 1.1.0","title":"rlang 1.1.0","text":"CRAN release: 2023-03-14","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"life-cycle-changes-1-1-0","dir":"Changelog","previous_headings":"","what":"Life cycle changes","title":"rlang 1.1.0","text":"dots_splice() deprecated. function previously questioning lifecycle stage moving towards explicit !!! splicing style. flatten(), squash(), variants deprecated favour purrr::list_flatten() purrr::list_c(). child_env() deprecated favour env() supported creating child environments several years now.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"main-new-features-1-1-0","dir":"Changelog","previous_headings":"","what":"Main new features","title":"rlang 1.1.0","text":"last_error() options(rlang_backtrace_on_error = \"full\") now print full backtrace tree default (except hidden frames). simplified backtraces tended hide important context often. Now show intervening frames lighter colour don’t distract important parts backtraces still easily inspectable. global_entrace(), last_warnings(), last_messages() now support knitr documents. New rlang_backtrace_on_warning_report global option. useful conjunction global_entrace() get backtraces warnings inside RMarkdown documents. global_entrace() entrace() now stop entracing warnings messages 20 times. avoid large overhead 100s 1000s warnings signalled loop (#1473). abort(), warn(), inform() gain .inherit parameter. controls whether parent inherited. FALSE, cnd_inherits() try_fetch() match chained conditions across parents. ’s normally TRUE default, warning chained error message chained warning error (downgraded chaining), .inherit defaults FALSE (#1573). try_fetch() now looks condition classes across chained errors (#1534). makes try_fetch() insensitive changes implementation context evaluation cause classed error suddenly get chained contextual error. englue() gained env, error_arg, error_call arguments support wrapped another function (#1565). data-masking documentation arguments imported dplyr. can link starting argument documentation button: enquos() friends gain .ignore_null argument (#1450). New env_is_user_facing() function determine evaluation frame corresponds direct usage end user (global environment package tested) indirect usage third party function. return value can overridden setting \"rlang_user_facing\" global option.","code":"<[`data-masking`][rlang::args_data_masking]>"},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"miscellaneous-fixes-and-features-1-1-0","dir":"Changelog","previous_headings":"","what":"Miscellaneous fixes and features","title":"rlang 1.1.0","text":"New check_data_frame() check_logical() functions standalone-types-check.R (#1587, @mgirlich). Added allow_infinite argument check_number_whole() (#1588, @mgirlich). lifecycle standalone file updated match modern lifecycle tools. parse_expr() now supports vectors lines (#1540). Quosures can now consistently concatenated lists quosures (#1446). Fixed memory issue caused excessive duplication list2() friends (#1491). Embraced empty arguments now properly detected trimmed quos() (#1421). Fixed edge case caused enquos(.named = NULL) return named list (#1505). expr_deparse() now deparses embrace operator {{ single line (#1511). zap_srcref() rewritten C efficiency (#1513). zap_srcref() now supports expression vectors. non-error path check_dots_unnamed() rewritten C efficiency (#1528). Improved error messages englue() (#1531) glue strings LHS := (#1526). englue() now requires size 1 outputs (#1492). prevents surprising errors inconsistencies interpolated input size != 1 makes way glue string. arg_match() now throws correct error supplied missing value empty vector (#1519). is_integerish() now handles negative doubles consistently positive ones (@sorhawell, #1530). New check_logical() standalone-types-check.R (#1560). quo_squash() now squashes quosures function position (#1509). is_expression() now recognises quoted functions (#1499). now also recognises non-parsable attributes (#1475). obj_address() now supports missing argument (#1521). Fixed check_installed() issue packages removed current R session (#1561). new_data_mask() now slightly faster due smaller initial mask size usage C level function R_NewEnv() R >=4.1.0 (#1553). C level r_dyn_*_push_back() utilities now faster (#1542). C level r_lgl_sum() r_lgl_which() helpers now faster (#1577, contributions @mgirlich). rlang now compliant -Wstrict-prototypes requested CRAN (#1508).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-106","dir":"Changelog","previous_headings":"","what":"rlang 1.0.6","title":"rlang 1.0.6","text":"CRAN release: 2022-09-24 as_closure(seq.int) now works (#1468). rlang longer stores errors backtraces org:r-lib environment search path. low-level function error_call() now exported (#1474). Fixed issue caused failure missing is_character function rlang installed alongside old version vctrs (#1482). Fixed issue caused multiline calls backtraces. C API function r_lgl_which() now propagates names input (#1471). pkg_version_info() function now allows == package version comparison (#1469, @kryekuzhinieri).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-105","dir":"Changelog","previous_headings":"","what":"rlang 1.0.5","title":"rlang 1.0.5","text":"CRAN release: 2022-08-31 Fixed backtrace display calls containing long lists arguments (#1456). New r_obj_type_friendly() function C library (#1463). interfaces obj_type_friendly() compat-obj-type.R via C callable.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-104","dir":"Changelog","previous_headings":"","what":"rlang 1.0.4","title":"rlang 1.0.4","text":"CRAN release: 2022-07-12 is_installed() longer throws error irregular package names. is_installed() check_installed() now properly detect base package installed older versions R (#1434).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-103","dir":"Changelog","previous_headings":"","what":"rlang 1.0.3","title":"rlang 1.0.3","text":"CRAN release: 2022-06-27 Child errors may now empty messages enable pattern: rlib_bytes class now uses prettyunits format bytes. bytes now represented decimal prefixes instead binary prefixes. Supplying frame environment call argument abort() now causes corresponding function call backtrace highlighted. addition, store argument name failing input arg error field, argument also highlighted backtrace. Instead : can now write benefit arg highlighting: abort(message = ) can now function. case, stored header field acts cnd_header() method invoked message displayed. New obj_type_oo() function compat-obj-type.R (#1426). friendly_type_of() compat-obj-type.R (formerly compat-friendly-type.R) now obj_type_friendly(). options(backtrace_on_error = \"collapse\") print(trace,   simplify = \"collapse\") deprecated. fall back \"none\" warning. call_match() now better handles ... dots_expand = FALSE. list2(!!!x) now faster x list. now returned instead duplicated new list. abort() gains .trace_bottom argument disambiguate .frame. allows cli::cli_abort() wrap abort() way .internal mentions correct package report error (#1386). transpose() compat now consistent purrr inner names congruent (#1346). New reset_warning_verbosity() reset_message_verbosity() functions. reset verbosity messages signalled warn() inform() .frequency argument. useful testing verbosity package (#1414). check_dots_empty() now allows trailing missing arguments (#1390). Calls local functions accessible :: ::: now marked (local) backtraces (#1399). Error messages now mention indexed calls like foo$bar(). New env_coalesce() function copy bindings one environment another. Unlike approaches based looping [[<-, env_coalesce() preserves active lazy bindings. Chaining errors top-level (directly console instead function) longer fails (#1405). Warning style propagated across parent errors chained error messages (#1387). check_installed() now works within catch-tryCatch(error = ) expressions (#1402, tidyverse/ggplot2#4845). arg_match() arg_match0() now mention correct call case type error (#1388). abort() inform() now print messages stdout RStudio panes (#1393). is_installed() now detects unsealed namespaces (#1378). fixes inconsistent behaviour run within user onLoad hooks. Source references backtraces last_error()/last_trace() instructions now clickable IDEs support links (#1396). compat-cli.R now supports style_hyperlink(). abort(.homonyms = \"error\") now throws expected error (#1394). env_binding_are_active() longer accidentally triggers active bindings (#1376). Fixed bug quo_squash() nested quosures containing missing argument.","code":"Error in `my_function()`: Caused by error in `their_function()`: ! Message. cli::cli_abort(\"{.arg {arg}} must be a foobar.\", call = call) cli::cli_abort(\"{.arg {arg}} must be a foobar.\", arg = arg, call = call)"},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-102","dir":"Changelog","previous_headings":"","what":"rlang 1.0.2","title":"rlang 1.0.2","text":"CRAN release: 2022-03-04 Backtraces parent errors now reused rethrow. avoids capturing backtrace twice solves consistency problems making sure errors chain backtrace. Fixed backtrace oversimplification cnd base error abort(parent = cnd). Internal errors thrown abort(.internal = TRUE) now mention name package error reported . Backtraces now separated error messages --- ruler line (#1368). internal bullet formatting routine now ignores unknown names (#1364). makes consistent cli package, increases resilience hard--detect errors, increases forward compatibility. abort() friends longer calls non-existent functions (e.g. cli::format_error() cli::format_warning) installed version cli old (#1367, tidyverse/dplyr#6189). Fixed OOB subsetting error abort().","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-101","dir":"Changelog","previous_headings":"","what":"rlang 1.0.1","title":"rlang 1.0.1","text":"CRAN release: 2022-02-03 New rlang_call_format_srcrefs global option (#1349). Similar rlang_trace_format_srcrefs, option allows turning display srcrefs error calls. can useful reproducibility note srcrefs already disabled within testthat default. abort(parent = NA) now supported indicate unchained rethrow. helps abort() detect condition handling context create simpler backtraces context hidden default. parent supplied, abort() now loops callers detect condition handler frame. makes easier wrap extract condition handlers functions without supplying .frame. parent supplied call points condition setup frame (e.g. withCallingHandlers() try_fetch()), call replaced caller setup frame. provides helpful default call. is_call() now implemented C performance. Fixed performance regression trace_back(). Fixed partial matching issue header, body, footer condition fields. eval_tidy() calls longer mentioned error messages.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-100","dir":"Changelog","previous_headings":"","what":"rlang 1.0.0","title":"rlang 1.0.0","text":"CRAN release: 2022-01-26","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"major-changes-1-0-0","dir":"Changelog","previous_headings":"","what":"Major changes","title":"rlang 1.0.0","text":"release focuses rlang errors framework features extensive changes display error messages. abort() now displays errors fully bulleted lists. Error headers displayed ! prefix. See https://rlang.r-lib.org/reference/topic-condition-customisation.html customise display error messages. abort() now displays full chain messages errors chained parent argument. Following change, update dplyr version 1.0.8 get proper error messages. abort() now displays function calls message originated default. refrained showing calls now avoid confusing messages error thrown helper function isn’t relevant users. help cases, abort() now takes call argument can set caller_env() parent.frame() used helper function. function call corresponding environment retrieved stored condition. cli formatting now supported. Use cli::cli_abort() get advanced formatting error messages, including indented bulleted lists. See https://rlang.r-lib.org/reference/topic-condition-formatting.html. New try_fetch() function error handling. recommend use chaining errors. mostly works like tryCatch() important differences. Compared tryCatch(), try_fetch() preserves call stack. allows full backtrace capture allows recover() reach error site. Compared withCallingHandler(), try_fetch() able handle stack overflow errors (requires R 4.2, unreleased time writing). tidy eval documentation fully rewritten reflect current practices. Access “Tidy evaluation” “Metaprogramming” menus https://rlang.r-lib.org.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"breaking-changes-1-0-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"rlang 1.0.0","text":".data object exported rlang now fails subsetted instead returning NULL. new error helps detect .data used wrong context. ’ve noticed several packages failing change using .data outside data-masking context. instance argument dplyr::join() data-masked. Previously dplyr::join(= .data$foo) silently interpreted dplyr::join(= NULL). now error. Another issue using .data inside ggplot2::labs(...). allowed since labs() isn’t data-masked. call_name() now returns NULL instead \"::\" calls form foo::bar. ’ve noticed packages check NULL results call_name(). Note many complex calls foo()(), foo$bar() don’t “name” cause NULL result. always check NULL results using call_name(). ’ve added function is_call_simple() make easier work safely call_name(). invariant call_name() always returns string is_call_simple() returns TRUE. Conversely always returns NULL is_call_simple() retuns FALSE. is_expression() now returns FALSE manually constructed expressions can’t created parser. used return TRUE calls, including contain injected objects. Consider using is_call() just remove expression check. many cases fine letting objects go expression expected. instance can inject objects directly inside dplyr arguments: string supplied as_function() instead object (function formula), function looked global environment instead calling environment. general, passing function name string brittle. easy forget pass user environment as_function() sometimes obvious user environment. support strings considered convenience end users , programmers. Since environment forwarding easy mess , since feature aimed towards end users, as_function() now defaults global environment. Supply environment explicitly correct case. with_handlers(), call_fn(), friendly_type() deprecated. action argument check_dots_used(), check_dots_unnamed(), check_dots_empty() deprecated favour new error argument takes error handler. Many functions deprecated rlang 0.2.0 0.3.0 removed package.","code":"x <- seq_len(nrow(data)) dplyr::mutate(data, col = !!x)"},{"path":[]},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"tidyeval-1-0-0","dir":"Changelog","previous_headings":"Fixes and features","what":"tidyeval","title":"rlang 1.0.0","text":"New englue() operator allow string-embracing outside dynamic dots (#1172). New data_sym() data_syms() functions create calls form .data$foo. .data now fails early subsetted outside data mask context. provides informative error message (#804, #1133). as_label() now better handles calls infix operators (#956, r-lib/testthat#1432). change improves auto-labelled expressions data-masking functions like tibble(), mutate(), etc. {{ operator now detected strictly (#1087). additional arguments supplied {, longer interpreted injection operator. .ignore_empty argument enexprs() enquos() longer treats named arguments supplied ... empty, consistently exprs() quos() (#1229). Fixed hang quosure inheriting data mask evaluated mask . Fixed performance issue splicing classes explicitly inherit list !!! (#1140, r-lib/vctrs#1170). Attributes quosure lists longer modified side effect (#1142). enquo(), enquos() variants now support numbered dots like ..1 (#1137). Fixed bug AST rotation algorithm caused !! operator unexpectedly mutate injected objects (#1103). Fixed AST rotation issue !! involving binary operators (#1125).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-errors-1-0-0","dir":"Changelog","previous_headings":"Fixes and features","what":"rlang errors","title":"rlang 1.0.0","text":"try_fetch() flexible alternative tryCatch() withCallingHandlers() (#503). also efficient tryCatch() creates leaner backtraces. New cnd_inherits() function detect class chain errors (#1293). New global_entrace() function, user-friendly helper configuring errors RProfile. Call enrich base errors warnings rlang backtrace. enables last_error(), last_warnings(), last_messages(), backtrace_on_error support conditions. New global_handle() function install default configuration error handlers. currently calls global_entrace() global_prompt_install(). Expect come. “Error:” part error messages now printed rlang instead R. introduces several cosmetic informative changes errors thrown abort(): call field error messages now displayed, default base::stop(). call displayed simple expression (e.g. inlined function) arguments displayed avoid distracting error message. message formatted tidyverse style (code formatting cli package available). source location displayed (base::stop()) call carries source reference. Source locations displayed testthat running avoid brittle snapshots. Error headers always displayed line, \"!\" bullet prefix. See https://rlang.r-lib.org/reference/topic-condition-customisation.html customise new display. display chained errors created parent argument abort() improved. Chains errors now displayed throw time error prefix “Caused error:”. print() method rlang errors (commonly invoked last_error()) improved: Display calls present. Chained errors displayed clearly. inform() warn() messages can now silenced global options rlib_message_verbosity rlib_warning_verbosity. abort() now outputs error messages stdout interactive sessions, following approach inform(). Errors, warnings, messages generated rlang now formatted cli. means practice long lines width-wrapped terminal size user themes applied. currently case rlang messages. special formatting applied abort(), warn(), inform() called another namespace rlang. See https://rlang.r-lib.org/reference/topic-condition-formatting.html ’d like use cli format condition messages package. format_error_bullets() (used fallback instead cli) now treats: Unnamed elements unindented line breaks (#1130) Elements named \"v\" green ticks (@rossellhayes) Elements named \" \" indented line breaks Elements named \"*\" normal bullets Elements named \"!\" warning bullets convenience, fully unnamed vector interpreted vector \"*\" bullets. abort() gains .internal argument. set TRUE, footer bullet added message let user know error internal report package authors. abort(), warn(), inform() gain body argument supply additional bullets error message. rlang conditions now .character() methods. Use generic conditions generate whole error message, including Error: prefix. methods implemented wrappers around cnd_message(). header footer methods can now stored closures condition fields name. cnd_message() gains prefix argument print message full prefix, including call field present parent messages condition chained. cnd_message() gains inherit argument control whether print messages parent errors. Condition constructors now check duplicate field names (#1268). cnd_footer() now returns footer field default, . warn() inform() now signal conditions classes \"rlang_warning\" \"rlang_message\" respectively. body field error conditions can now character vector. error returned last_error() now stored search path .Last.error binding \"org:r-lib\" environment. consistent processx package records error conditions. Printing .Last.error object now equivalent running last_error(). Added is_error(), is_warning(), is_message() predicates (#1220). interrupt() longer fails interrupts suspended (#1224). warn() now temporarily sets warning.length global option maximum value (8170). default limit (1000 characters) especially easy hit message contains lot ANSI escapes, created crayon cli packages (#1211).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"backtraces-1-0-0","dir":"Changelog","previous_headings":"Fixes and features","what":"Backtraces","title":"rlang 1.0.0","text":"entrace() global_entrace() now log warnings messages backtraces attached. Run last_warnings() last_messages() inspect warnings messages emitted last command. Internal errors now include winch backtrace installed. user invited install installed. Display rlang backtraces expected errors dynamic reports (chunks error = TRUE knitted documents RStudio notebooks) now controlled rlang_backtrace_on_error_report option. default, set \"none\". display backtraces unexpected errors (chunks error unset set FALSE) still controlled rlang_backtrace_on_error. last_error() reminder longer displayed RStudio notebooks. knitr::sew() method registered rlang_error. makes possible consult last_error() (call must occur different chunk error) set rlang_backtrace_on_error_report global options knitr display backtrace expected errors. show rlang backtraces knitted document, also set hidden chunk trim knitr context backtraces: change replaces ad hoc mechanism caused bugs corner cases (#1205). rlang_trace_top_env global option trace_back() now detects backtraces created within knitr. option set, default value becomes knitr::knit_global() knitr progress (determined knitr..progress global option). prevents knitr evaluation context appearing backtraces (#932). Namespace changes now emboldened backtraces (#946). Functions defined global environments local execution environments now displayed space separator backtraces instead :: :::. avoids making seem like frame calls valid R code ready typed (#902). Backtraces longer contain inlined objects avoid performance issues edge cases (#1069, r-lib/testthat#1223). External backtraces error chains now separately displayed (#1098). Trace capture now better handles wrappers calling handler case rethrown chained errors. Backtraces now print dangling srcrefs (#1206). Paths shortened show three components (two levels folder file). root symbol backtraces now slightly different can’t confused prompt character (#1207).","code":"options(   rlang_trace_top_env = environment() )"},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"argument-intake-1-0-0","dir":"Changelog","previous_headings":"Fixes and features","what":"Argument intake","title":"rlang 1.0.0","text":"arg_match() gains multiple argument cases zero several matches allowed (#1281). New function check_required() check argument supplied. produces friendly error message force() (#1118). check_dots_empty(), check_dots_used(), check_dots_unnamed() moved ellipsis rlang. ellipsis package deprecated eventually archived. added check_dots_empty0(). different UI almost efficient checking missing(...). Use low level functions couple microseconds make difference. arg_nm argument arg_match0() must now string symbol. arg_match() now mentions supplied argument (#1113). is_installed() check_installed() gain version argument (#1165). check_installed() now consults rlib_restart_package_not_found global option determine whether prompt users install packages. also disables restart mechanism (see ). check_installed() now signals errors class rlib_error_package_not_found rlib_restart_package_not_found restart. allows calling handlers install required packages restart check (#1150). is_installed() check_installed() now support DESCRIPTION-style version requirements like \"rlang (>= 1.0)\". also gain version compare arguments supply requirements programmatically. check_installed() gains action argument called user chooses install update missing outdated packages. New check_exclusive() function check one argument set supplied (#1261).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"r-apis-1-0-0","dir":"Changelog","previous_headings":"Fixes and features","what":"R APIs","title":"rlang 1.0.0","text":"on_load() run_on_load() lets run .onLoad() expressions file package. on_package_load() runs expressions another package loaded. (#1284) new predicate is_call_simple() indicates whether call name /namespace. provides two invariants: is_call_simple(x) TRUE, call_name() always returns string. is_call_simple(x, ns = TRUE) TRUE, call_ns() always returns string. call_name() call_ns() now return NULL calls form foo::bar (#670). New current_call(), caller_call(), frame_call() accessors. New frame_fn() accessor. env_has() corresponding C-level function longer force active bindings (#1292). New names2<- replacement function never adds missing values names don’t names (#1301). zap_srcref() now preserves attributes closures. Objects headers (printed last_error(), env_print(), …) now formatted using cls class cli package. as_function() gains arg call arguments provide contextual information erroring inputs. is_expression() now returns FALSE manually constructed expressions created R parser. New C callable rlang_env_unbind(). wrapper around R_removeVarFromFrame() R >= 4.0.0. older R wraps R function base::rm(). Unlike rm(), function warn (throw) binding exist. friendly_type_of() now supports missing arguments. env_clone() now properly clones active bindings avoids forcing promises (#1228). R < 4.0, promises still forced. Fixed s3_register() issue registering package dependency package exports generic (#1225). Added compat-vctrs.R file robust manipulation data frames zero-deps packages. Added compat-cli.R file format message elements consistently cli zero-deps packages. compat-purrr.R now longer includes pluck* helpers; used defintion pluck predated purrr (#1159). *_cpl() also removed. map* wrappers now call as_function() can pass short anonymous functions use ~ (#1157). exprs_auto_name() gains repair_auto argument make automatic names unique (#1116). .named argument dots_list() can now set NULL give result default names. option, fully unnamed inputs produce fully unnamed result NULL names instead character vector minimal \"\" names (#390). is_named2() variant is_named() always returns TRUE empty vectors (#191). tests property element vector named rather presence names attribute. New rlib_bytes class imported bench package (#1117). prints parses human-friendly sizes. env argument as_function() now defaults global environment. previous default caller as_function(), rarely correct environment look . Since ’s hard remember pass user environment ’s sometimes tricky keep track , ’s best consider string lookup convenience end users, developers (#1170). s3_register() longer fails generic exist. prevents failures users don’t last versions packages (#1112). Formulas now deparsed according tidyverse style guide (~symbol without space ~ expression() space). New hash_file(), complementing hash(), generate 128-bit hashes data within file without loading R (#1134). New env_cache() function retrieve value create default doesn’t exist yet (#1081). env_get() env_get_list() gain last argument. Lookup stops environment. can useful conjunction base::topenv(). New call_match() function. like match.call() also supports matching missing arguments defaults function definition (#875). call_standardise() deprecated favour call_match(). expr_deparse() now properly escapes \\ characters symbols, argument names, vector names (#1160). friendly_type_of() (compat-friendly-type.R) now supports matrices arrays (#141). Updated env_print() use format_error_bullets() consistent tidyverse style (#1154). set_names() now recycles names size 1 size input, following tidyverse recycling rules. is_bare_formula() now handles scoped argument consistently. default changed TRUE compatibility historical default behaviour (#1115). “definition” API (dots_definitions() etc.) archived. New is_complex() predicates complete family (#1127). C function r_obj_address() now properly prefixes addresses hexadecimal prefix 0x Windows (#1135). obj_address() now exported. %<~% now actually works. XXH3_64bits() XXHash library now exposed C callable name rlang_xxh3_64bits().","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-0412","dir":"Changelog","previous_headings":"","what":"rlang 0.4.12","title":"rlang 0.4.12","text":"CRAN release: 2021-10-18 Fix CRAN checks.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-0411","dir":"Changelog","previous_headings":"","what":"rlang 0.4.11","title":"rlang 0.4.11","text":"CRAN release: 2021-04-30 Fix CRAN checks. Fixed gcc11 warning related hash() (#1088).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-0410","dir":"Changelog","previous_headings":"","what":"rlang 0.4.10","title":"rlang 0.4.10","text":"CRAN release: 2020-12-30 New hash() function generate 128-bit hashes arbitrary R objects using xxHash library. implementation modeled xxhashlite, created @coolbutuseless. New check_installed() function. Unlike is_installed(), asks user whether install missing packages. user accepts, packages installed pak::pkg_install() available, utils::install.packages() otherwise. session non interactive user chooses install packages, current evaluation aborted (#1075). rlang now licensed MIT (#1063). Fixed issue causing extra empty lines inform() messages .frequency (#1076, @schloerke). expr_deparse() now correctly wraps code using :: ::: (#1072, @krlmlr).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-049","dir":"Changelog","previous_headings":"","what":"rlang 0.4.9","title":"rlang 0.4.9","text":"CRAN release: 2020-11-25","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"breaking-changes-0-4-9","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"rlang 0.4.9","text":"Dropped support R 3.2 series.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"new-features-0-4-9","dir":"Changelog","previous_headings":"","what":"New features","title":"rlang 0.4.9","text":"inject() evaluates argument !!, !!!, {{ support. New enquo0() enquos0() operators defusing function arguments without automatic injection (unquotation). format_error_bullets() longer experimental. message arguments abort(), warn(), inform() automatically passed function make easy create messages regular, info, error bullets. See ?format_error_bullets information. New zap_srcref() function recursively remove source references functions calls. new compat file zeallot operator %<-% now available rlang repository. New %<~% operator define variable lazily. New env_browse() env_is_browsed() functions. env_browse() equivalent evaluating browser() within environment. sets environment persistently browsable (unsets value = FALSE supplied). Functions created quosures as_function() now print user friendly way. New rlang_print_backtrace C callable debugging C interpreters (#1059).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"bugfixes-and-improvements-0-4-9","dir":"Changelog","previous_headings":"","what":"Bugfixes and improvements","title":"rlang 0.4.9","text":".data pronoun longer skips functions (#1061). solves dplyr issue involving rowwise data frames list-columns functions (tidyverse/dplyr#5608). as_data_mask() now intialises environments correct size improve efficiency (#1048). eval_bare(), eval_tidy() (#961), with_handlers() (#518) now propagate visibility. cnd_signal() now ignores NULL inputs. Fixed bug prevented splicing named empty vector !!! operator (#1045). exit status now preserved non-interactive sessions entrace() used options(error = ) handler (#1052, rstudio/bookdown#920). next break now properly deparsed nullary operators.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-048","dir":"Changelog","previous_headings":"","what":"rlang 0.4.8","title":"rlang 0.4.8","text":"CRAN release: 2020-10-08 Backtraces now include native stacks (e.g. C code) winch package installed rlang_trace_use_winch set TRUE (@krlmlr). Compatibility upcoming testthat 3 magrittr 2 releases. get_env() now returns proper environment primitive functions, .e. base namespace rather base environment (r-lib/downlit#32). entrace() longer handles non-rlang errors carry backtrace. improves compatibility packages like callr. Backtraces unhandled errors now displayed without truncation non-interactive sessions (#856). is_interactive() longer consults “rstudio.notebook.executing” option (#1031).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-047","dir":"Changelog","previous_headings":"","what":"rlang 0.4.7","title":"rlang 0.4.7","text":"CRAN release: 2020-07-09 cnd_muffle() now returns FALSE instead failing condition mufflable (#1022). warn() inform() gain .frequency argument control frequently warning message displayed. New raw_deparse_str() function converting raw vector string hexadecimal characters (@krlmlr, #978). backtraces chained errors longer decomposed error context. Instead, error messages displayed tree reflect error ancestry, deepest backtrace ancestry displayed. change simplifies display (#851) makes possible rethow errors calling handler rather exiting handler, now think appropriate allows users recover() error. env_bind(), env_bind_active(), env_bind_lazy(), env_get(), env_get_list() rewritten C. env_poke() now supports zap() sentinels removing bindings (#1012) better support characters representable local encoding. env_poke() rewritten C performance. unicode translation warnings appeared Windows R 4.0 now fixed. env_unbind(inherit = TRUE) now removes binding first parent environment binding. used remove bindings whole ancestry. new behaviour doesn’t guarantee scope doesn’t binding safer. env_has() now rewritten C performance. dots_list() gains .named argument auto-naming dots (#957). now possible subset .data pronoun quosured symbols strings (#807). Expressions like quote(list(\"b\" = 1)) now properly deparsed expr_deparse() (#950). parse_exprs() now preserves names (#808). single string produces multiple expressions, names may useful figure input produced expression. parse_exprs() now supports empty expressions (#954). list2(!!!x) longer evaluates x multiple times (#981). is_installed() now properly handles pkg argument length > 1. silently tested first element pkg thus always returned TRUE first package installed regardless actual length pkg. (#991, @salim-b) arg_match0() faster version arg_match() use performance premium (#997, @krlmlr).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-046","dir":"Changelog","previous_headings":"","what":"rlang 0.4.6","title":"rlang 0.4.6","text":"CRAN release: 2020-05-02 !!! now uses combination length(), names(), [[ splice S3 S4 objects. produces consistent behaviour .list() wider variety vector classes (#945, tidyverse/dplyr#4931).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-045","dir":"Changelog","previous_headings":"","what":"rlang 0.4.5","title":"rlang 0.4.5","text":"CRAN release: 2020-03-01 set_names(), is_formula(), names2() now implemented C efficiency. .data pronoun now accepts symbol subscripts (#836). Quosure lists now explicitly inherit \"list\". makes compatible vctrs package (#928). rlang options now documented centralised place, see ?rlang::faq-options (#899, @smingerson). Fixed crash env_bindings_are_lazy() gets improper arguments (#923). arg_match() now detects suggests possible typos provided arguments (@jonkeane, #798). arg_match() now gives error argument length greater 1 doesn’t exactly match values input, similar base match.arg (#914, @AliciaSchep)","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-044","dir":"Changelog","previous_headings":"","what":"rlang 0.4.4","title":"rlang 0.4.4","text":"CRAN release: 2020-01-28 Maintenance release CRAN.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-043","dir":"Changelog","previous_headings":"","what":"rlang 0.4.3","title":"rlang 0.4.3","text":"CRAN release: 2020-01-24 can now use glue syntax unquote LHS :=. syntax automatically available functions taking dots list2() enquos(), thus tidyverse. Note use glue syntax R package, need import glue. single pair braces triggers normal glue interpolation: Using pair double braces labelling function argument. Technically, shortcut \"{as_label(enquo(arg))}\". syntax similar curly-curly syntax interpolating function arguments: Fixed bug magrittr backtraces caused duplicate calls appear trace. Fixed bug magrittr backtraces caused wrong call indices. Empty backtraces longer shown rlang_backtrace_on_error set. tidy eval .env pronoun now exported documentation purposes. warn() abort() now check either class message supplied. inform() allows sending empty message occasionally useful building user output incrementally. flatten() fails proper error input can’t flattened (#868, #885). inform() now consistently appends final newline message (#880). cnd_body.default() now properly registered. cnd_signal() now uses approach abort() save unhandled errors last_error(). Parsable constants like NaN NA_integer_ now deparsed expr_deparse() parsable form (#890). Infix operators now stick LHS deparsed expr_deparse() (#890).","code":"df <- data.frame(x = 1:3)  suffix <- \"foo\" df %>% dplyr::mutate(\"var_{suffix}\" := x * 2) #>   x var_foo #> 1 1       2 #> 2 2       4 #> 3 3       6 my_wrapper <- function(data, var, suffix = \"foo\") {   data %>% dplyr::mutate(\"{{ var }}_{suffix}\" := {{ var }} * 2) } df %>% my_wrapper(x) #>   x x_foo #> 1 1     2 #> 2 2     4 #> 3 3     6  df %>% my_wrapper(sqrt(x)) #>   x sqrt(x)_foo #> 1 1    2.000000 #> 2 2    2.828427 #> 3 3    3.464102"},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-042","dir":"Changelog","previous_headings":"","what":"rlang 0.4.2","title":"rlang 0.4.2","text":"CRAN release: 2019-11-23 New cnd_header(), cnd_body() cnd_footer() generics. automatically called conditionMessage.rlang_error(), default method rlang errors. Concretely, way breaking lazy generation error messages conditionMessage() three independent parts. provides lot flexibility hierarchies error classes, instance inherit body error message parent class overriding header footer. reminder call last_error() now less confusing thanks suggestion @markhwhiteii. functions prefixed scoped_ renamed use conventional local_ prefix. instance, scoped_bindings() now local_bindings(). scoped_ functions deprecated next significant version rlang (0.5.0). .subclass argument abort(), warn() inform() renamed class. consistency conventions class constructors documented https://adv-r.hadley.nz/s3.html#s3-subclassing. inform() now prints messages standard output default interactive sessions. makes appear like normal output IDEs RStudio. non-interactive sessions, messages still printed standard error make easy redirect messages running R scripts (#852). Fixed error trace_back() call stack contains quosured symbol. Backtrace now displayed full error occurs non-interactive sessions. Previously backtraces parent errors left .","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-041","dir":"Changelog","previous_headings":"","what":"rlang 0.4.1","title":"rlang 0.4.1","text":"CRAN release: 2019-10-24 New experimental framework creating bulleted error messages. See ?cnd_message motivation overwiew tools created support approach. particular, abort() now takes character vectors assemble bullet list. Elements named x prefixed red cross, elements named prefixed blue info symbol, unnamed elements prefixed bullet. Capture backtrace context rethrowing error exiting handler improved. tryCatch() context longer leaks high-level backtrace. Printing error longer recommends calling last_trace(), unless called last_error(). env_clone() longer recreates active bindings now just alias env2list(.list(env)). Unlike .list() returns active binding function R < 4.0, value active bindings consistently used versions. display rlang errors derived parent errors improved. simplified backtrace (printed rlang::last_error()) longer includes parent errors. hand, full backtrace (printed rlang::last_trace()) now includes backtraces parent errors. cnd_signal() improved support rlang errors created error_cnd(). now records backtrace isn’t one already, saves error can inspected rlang::last_error(). rlang errors longer formatted saved conditionMessage(). makes easier use conditionMessage() method subclasses created abort(), useful delay expensive generation error messages display time. abort() can now called without error message. useful conditionMessage() used generate message print-time. Fixed infinite loop eval_tidy(). occurred evaluating quosure inherits mask . env_bind()’s performance significantly improved fixing bug caused values repeatedly looked name. cnd_muffle() now checks restart exists invoking . restart might exist condition signalled different function (stop(warning_cnd)). trace_length() returns number frames backtrace. Added internal utility cnd_entrace() add backtrace condition. rlang::last_error() backtraces longer displayed red. x %|% y now also works y length x (@rcannood, #806). Empty named lists now deparsed explicitly \"<named list>\". Fixed chr() bug causing return invisibly.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-040","dir":"Changelog","previous_headings":"","what":"rlang 0.4.0","title":"rlang 0.4.0","text":"CRAN release: 2019-06-25","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"interpolate-function-inputs-with-the-curly-curly-operator-0-4-0","dir":"Changelog","previous_headings":"Tidy evaluation","what":"Interpolate function inputs with the curly-curly operator","title":"rlang 0.4.0","text":"main change release new tidy evaluation operator {{. operator abstracts quote--unquote idiom single interpolation step: {{ var }} shortcut !!enquo(var) easier eyes, easier learn teach. Note multiple inputs, existing documentation doesn’t stress enough can just pass dots straight tidy eval functions. need quote--unquote unless need modify inputs names way:","code":"my_wrapper <- function(data, var, by) {   data %>%     group_by({{ by }}) %>%     summarise(average = mean({{ var }}, na.rm = TRUE)) } my_wrapper <- function(data, var, ...) {   data %>%     group_by(...) %>%     summarise(average = mean({{ var }}, na.rm = TRUE)) }"},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"more-robust-env-pronoun-0-4-0","dir":"Changelog","previous_headings":"Tidy evaluation","what":"More robust .env pronoun","title":"rlang 0.4.0","text":"Another improvement tidy evaluation make easier use .env pronoun. Starting release, subsetting object .env pronoun now evaluates corresponding symbol. makes .env robust, particular magrittr pipelines. following example previously fail: way, using .env pronoun now equivalent unquoting constant objects, easier syntax: Note following change, despite name, .env longer referring bare environment. Instead, special shortcut rules. Similarly, .data pronoun really data frame.","code":"foo <- 10 mtcars %>% mutate(cyl = cyl * .env$foo) mtcars %>% mutate(cyl = cyl * !!foo)"},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"new-functions-and-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New functions and features","title":"rlang 0.4.0","text":"New pairlist2() function splicing support. preserves missing arguments, makes useful lists formal parameters functions. is_bool() scalar type predicate checks whether input single TRUE FALSE. Like is_string(), returns FALSE input missing. useful type-checking function arguments (#695). is_string() gains string argument. is_string(x, \"foo\") shortcut is_character(x) && length(x) == 1 && identical(x,   \"foo\"). Lists quosures now pillar methods display tibbles. set_names() now names unnamed input vectors applying function. following expressions now equivalent: can now pass character vector message argument abort(), warn(), inform(), signal(). vector collapsed single string \"\\n\" newline separating element input vector (#744). maybe_missing() gains default argument. New functions weak references: new_weakref(), weakref_key(), weakref_value(), is_weakref() (@wch, #787).","code":"letters %>% set_names() %>% set_names(toupper)  letters %>% set_names(toupper)"},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"performance-0-4-0","dir":"Changelog","previous_headings":"","what":"Performance","title":"rlang 0.4.0","text":"performance exec() improved. now order performance .call(), though slightly slower. call2() now uses new pairlist2() function internally. considerably improves performance. also means now preserves empty arguments:","code":"call2(\"fn\", 1, , foo = ) #> fn(1, , foo = )"},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"bugfixes-and-small-improvements-0-4-0","dir":"Changelog","previous_headings":"","what":"Bugfixes and small improvements","title":"rlang 0.4.0","text":"with_handlers() now installs calling handlers first stack, matter location argument list. way always take precedence exiting handlers, ensures side effects (logging) take place (#718). rlang backtraces, global:: prefix now added function directly inherits global environment. Functions inheriting indirectly longer namespace qualifier (#733). options(error = rlang::entrace) now better support errors thrown C (#779). also saves structured errors error field rlang::last_error(). ns_env() ns_env_name() (experimental functions) now support functions environments consisently. also require argument now . is_interactive() aware TESTTHAT environment variable returns FALSE \"true\" (@jennybc, #738). fn_fmls() variants longer coerce input closure. Instead, throw error. Fixed issue knitr caused backtraces print even error = TRUE. return object as_function() now inherits \"function\" (@richierocks, #735).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"lifecycle-0-4-0","dir":"Changelog","previous_headings":"","what":"Lifecycle","title":"rlang 0.4.0","text":"commit support 5 versions R. R 3.6 released, rlang now requires R 3.2 greater. ’re also continuing efforts streamline narrow rlang API. modify() prepend() (two experimental functions marked questioning stage since rlang 0.3.0) now deprecated. Vector functions now scope rlang. might revived vctrs funs packages. exiting() soft-deprecated with_handlers() treats handlers exiting default. vector constructors like lgl() new_logical() now questioning stage. likely moved vctrs package point. missing values shortcuts like na_lgl. as_logical(), as_integer(), etc soft-deprecated favour vctrs::vec_cast(). type_of(), switch_type(), coerce_type(), friends soft-deprecated. encoding locale API summarily archived. API didn’t bring value wasn’t used CRAN. lang_type_of(), switch_lang(), coerce_lang() archived. functions used CRAN internally. Subsetting quosures [ [[ soft-deprecated. functions soft-deprecated, deprecated, defunct previous releases bumped next lifecycle stage.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-032","dir":"Changelog","previous_headings":"","what":"rlang 0.3.2","title":"rlang 0.3.2","text":"CRAN release: 2019-03-21 Fixed protection issue reported rchk. experimental option rlang__backtrace_on_error longer experimental renamed rlang_backtrace_on_error. New “none” option rlang_backtrace_on_error. Unary operators applied quosures now give better error messages. Fixed issue backtraces warnings promoted error, entraced via withCallingHandlers(). issue didn’t affect entracing via top level options(error = rlang::entrace) handling.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-031","dir":"Changelog","previous_headings":"","what":"rlang 0.3.1","title":"rlang 0.3.1","text":"CRAN release: 2019-01-08 patch release polishes new backtrace feature introduced rlang 0.3.0 solves bugs upcoming release purrr 0.3.0. also features as_label() as_name() meant replace quo_name() future. Finally, bunch deparsing issues fixed.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"backtrace-fixes-0-3-1","dir":"Changelog","previous_headings":"","what":"Backtrace fixes","title":"rlang 0.3.1","text":"New entrace() condition handler. Add RProfile enable rlang backtraces errors, including warnings promoted errors: handler also works calling handler: However ’s often practical use with_abort() case: with_abort() gains classes argument promote kind condition rlang error. New last_trace() shortcut print backtrace stored last_error(). Backtrace objects now print full default. Calls backtraces now numbered according position call tree. numbering non-contiguous simplified backtraces omitted call frames. catch_cnd() gains classes argument specify classes condition catch. returns NULL expected condition caught (#696).","code":"if (requireNamespace(\"rlang\", quietly = TRUE)) {   options(error = rlang::entrace) } with_handlers(   error = calling(entrace),   foo(bar) ) with_abort(foo(bar))"},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"as_label-and-as_name-0-3-1","dir":"Changelog","previous_headings":"","what":"as_label() and as_name()","title":"rlang 0.3.1","text":"new as_label() as_name() functions used instead quo_name() transform objects quoted expressions string. noticed tidy eval users often use quo_name() extract names quosured symbols. good use function way quo_name() creates string well defined operation. reason, replacing quo_name() two new functions clearly defined purposes, hopefully better names reflecting purposes. Use as_label() transform object short human-readable description, as_name() extract names (possibly quosured) symbols. Create labels as_label() : Display object concise way, example labellise axes graphical plot. Give default names columns data frame. case, labelling first step name repair. expect as_label() gain additional parameters future, example control maximum width label. way object labelled thus subject change. hand, as_name() transforms symbols back string well defined manner. Unlike as_label(), as_name() guarantees roundtrip symbol -> string -> symbol. general, don’t know sure kind object ’re dealing (call, symbol, unquoted constant), use as_label() make assumption resulting string. know symbol need name object refers , use as_name(). instance, use as_label() objects captured enquo() as_name() symbols captured ensym(). Note quo_name() soft-deprecated next major version rlang (0.4.0). point, start issuing -per-session warnings scripts, packages. deprecated yet another major version, point issue -per-session warnings packages well. thus plenty time change code.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"minor-fixes-and-features-0-3-1","dir":"Changelog","previous_headings":"","what":"Minor fixes and features","title":"rlang 0.3.1","text":"New is_interactive() function. serves purpose base::interactive() also checks knitr progress provides escape hatch. Use with_interactive() scoped_interactive() override return value is_interactive(). useful unit tests manually turn interactive features RMarkdown outputs calling() now boxes argument. New done() function box value. Done boxes sentinels indicate early termination loop computation. instance, used purrr package allow users shortcircuit reduction accumulation. new_box() now accepts additional attributes passed structure(). Fixed quotation bug binary operators zero one argument `/`(1) (#652). now deparsed printed properly well. New call_ns() function retrieve namespace call. Returns NULL call namespaced. Top-level S3 objects now deparsed properly. Empty { blocks now deparsed line. Fixed deparsing issue symbols containing non-ASCII characters (#691). expr_print() now handles [ [[ operators correctly, deparses non-syntactic symbols backticks. call_modify() now respects ordering unnamed inputs. fix, move unnamed inputs named ones. as_closure() wrappers now call primitives positional arguments avoid edge case issues argument matching. as_closure() wrappers now dispatch properly methods defined global environment (tidyverse/purrr#459). as_closure() now supports base-style (e1 e2) purrr-style (.x .y) arguments binary primitives. exec() takes .fn first argument instead f, consistency rlang functions. Fixed infinite loop quosures created inside data mask. Base errors set parent rlang errors now printed correctly.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-030","dir":"Changelog","previous_headings":"","what":"rlang 0.3.0","title":"rlang 0.3.0","text":"CRAN release: 2018-10-22","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"breaking-changes-0-3-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"rlang 0.3.0","text":"rlang API still maturing. section, ’ll find hard breaking changes. See life cycle section exhaustive list API changes. quo_text() now deparses non-syntactic symbols backticks: caused number issues reverse dependencies quo_text() tends used converting symbols strings. quo_text() quo_name() used purpose general purpose deparsers. functions generally used printing outputs creating default labels. need convert symbols strings, please use as_string() rather quo_text(). extended documentation ?quo_text ?quo_name make points clearer. exprs() longer flattens quosures. exprs(!!!quos(x, y)) now equivalent quos(x, y). sentinel removing arguments call_modify() changed NULL zap(). breaking change motivated ambiguity NULL valid argument values. %@% operator now quotes input supports S4 objects. makes directly equivalent @ except extracts attributes non-S4 objects (#207). Taking env_parent() empty environment now error.","code":"quo_text(sym(\"foo+\")) #> [1] \"`foo+`\" call_modify(call, arg = NULL)  # Add `arg = NULL` to the call call_modify(call, arg = zap()) # Remove the `arg` argument from the call"},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"summary-0-3-0","dir":"Changelog","previous_headings":"","what":"Summary","title":"rlang 0.3.0","text":"changes version organised around three main themes: error reporting, tidy eval, tidy dots. abort() now records backtraces automatically error object. Errors thrown abort() invite users call rlang::last_error() see backtrace help identifying error occurred. backtraces created rlang (can create one manually trace_back()) printed simplified form default removes implementation details backtrace. see full backtrace, call summary(rlang::last_error()). abort() also gains parent argument. meant situations ’re calling low level API (download file, parse JSON file, etc) like intercept errors base::tryCatch() rlang::with_handlers() rethrow high-level message. Call abort() intercepted error parent argument. user prints rlang::last_error(), backtrace shown two sections corresponding high-level low-level contexts. order get segmented backtraces, low-level error thrown abort(). ’s case, can call low-level function within with_abort() automatically promote errors rlang errors. tidy eval changes mostly developers data masking APIs. main user-facing change .data[[ now unquote operator var .data[[var]] never masked data frame columns always picked environment. makes pronoun safe programming functions. !!! operator now supports classed objects like factors. calls .list() S3 objects (x, \"list\") S4 objects. dots_list() gains several arguments control dots collected. can control selection arguments name .homonyms (keep first, last, , abort). can also elect preserve empty arguments .preserve_empty.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"conditions-and-errors-0-3-0","dir":"Changelog","previous_headings":"","what":"Conditions and errors","title":"rlang 0.3.0","text":"New trace_back() captures backtrace. Compared base R traceback, contains additional structure relationship frames. comes tools automatically restricting frames certain environment stack, simplify printing. backtraces now recorded errors thrown abort() (see ). abort() gains parent argument specify parent error. meant situations low-level error expected (e.g. download parsing failed) ’d like throw error higher level information. Specifying low-level error parent makes possible partition backtraces based ancestry. Errors thrown abort() now embed backtrace condition object. longer necessary record trace calling handler errors. with_abort() runs expressions context errors promoted rlang errors gain backtrace. Unhandled errors thrown abort() now automatically saved can retrieved rlang::last_error(). error prints simplified backtrace. Call summary(last_error()) see full backtrace. New experimental option rlang__backtrace_on_error display backtraces alongside error messages. See ?rlang::abort supported options. new signal() function completes abort(), warn() inform() family. creates signals bare condition. New interrupt() function simulate user interrupt R code. cnd_signal() now dispatches messages, warnings, errors interrupts relevant signalling functions (message(), warning(), stop() C function Rf_onintr()). makes good choice resignal captured condition. New cnd_type() helper determine type condition (\"condition\", \"message\", \"warning\", \"error\" \"interrupt\"). abort(), warn() inform() now accepts metadata .... data stored condition can examined user handlers. Consequently arguments renamed prefixed dot (limit naming conflicts arguments metadata names). with_handlers() treats bare functions exiting handlers (equivalent handlers supplied tryCatch()). also supports formula shortcut lambda functions (purrr). with_handlers() now produces cleaner stack trace.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"tidy-dots-0-3-0","dir":"Changelog","previous_headings":"","what":"Tidy dots","title":"rlang 0.3.0","text":"input types !!! standardised. !!! generally defined vectors: takes vector (typically, list) unquotes element separate argument. standardisation makes !!! behave functions taking dots list2() quoting functions. !!! accepts types: Lists, pairlists, atomic vectors. class, converted base::.list() allow S3 dispatch. Following change, objects like factors can now spliced without data loss. S4 objects. converted (obj, \"list\") splicing. Quoted blocks expressions, .e. { } calls !!! disallows: objects like functions environments, also language objects like formula, symbols, quosures. Quoting functions used automatically wrap language objects lists make spliceable. behaviour now soft-deprecated longer valid write !!!enquo(x). Please unquote scalar objects !! instead. dots_list(), enexprs() enquos() gain .homonyms argument control treat arguments name. default keep . Set \"first\" \"last\" keep first last occurrences. Set \"error\" raise informative error arguments duplicated names. enexprs() enquos() now support .ignore_empty = \"\" named arguments well (#414). dots_list() gains .preserve_empty argument. TRUE, empty arguments stored missing arguments (see ?missing_arg). dots_list(), enexprs() enquos() gain .check_assign argument. TRUE, warning issued <- call detected .... warning issued assignment wrapped brackets like { <- 1 }. warning lets users know possible typo code (assigning instead matching function parameter) requires explicit really want assign variable wrapping parentheses. lapply(list(quote(foo)), list2) longer evaluates foo (#580).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"tidy-eval-0-3-0","dir":"Changelog","previous_headings":"","what":"Tidy eval","title":"rlang 0.3.0","text":"can now unquote quosured symbols LHS :=. symbol automatically unwrapped quosure. Quosure methods defined common operations like ==. methods fail informative error message suggesting unquote quosure (#478, #tidyverse/dplyr#3476). as_data_pronoun() now accepts data masks. mask multiple environments, looked subsetting pronoun. Function objects stored mask bypassed. now possible unquote strings function position. consistent R parser coerces strings symbols. two expressions now equivalent: expr(\"foo\"()) expr((!!\"foo\")()). Quosures converted functions as_function() now support nested quosures. expr_deparse() (used print quosures console) now escapes special characters. instance, newlines now print \"\\n\" (#484). ensures roundtrip parse_expr(expr_deparse(x)) lossy. new_data_mask() now throws error bottom child top (#551). Formulas now evaluated correct environment within eval_tidy(). fixes issues dplyr tidy-evaluation interfaces. New functions new_quosures() as_quosures() create coerce list quosures. small S3 class ensures two invariants subsetting concatenation: element quosure list always named even vector empty strings.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"environments-0-3-0","dir":"Changelog","previous_headings":"","what":"Environments","title":"rlang 0.3.0","text":"env() now treats single unnamed argument parent new environment. Consequently, child_env() now superfluous now questioning life cycle. New current_env() current_fn() functions retrieve current environment function evaluated. equivalent base::environment() base::sys.function() called without argument. env_get() env_get_list() gain default argument provide default value non-existing bindings. env_poke() now returns old value invisibly rather input environment. new function env_name() returns name environment. always adds “namespace:” prefix namespace names. returns “global” instead “.GlobalEnv” “R_GlobalEnv”, “empty” instead “R_EmptyEnv”. companion env_label() like env_name() returns memory address anonymous environments. env_parents() now returns named list. names taken env_name(). env_parents() env_tail() now stop global environment default. can changed last argument. empty environment always stopping condition can take parents tail environment search path without changing default. New predicates env_binding_are_active() env_binding_are_lazy() detect kind bindings environment. env_binding_lock() env_binding_unlock() allows lock unlock multiple bindings. predicate env_binding_are_locked() tests bindings locked. env_lock() env_is_locked() lock environment test environment locked. env_print() pretty-prints environments. shows contents (20 elements) properties environment. is_scoped() soft-deprecated renamed is_attached(). now supports environments addition search names. env_bind_lazy() env_bind_active() now support quosures. env_bind_exprs() env_bind_fns() soft-deprecated renamed env_bind_lazy() env_bind_active() clarity consistency. env_bind(), env_bind_exprs(), env_bind_fns() now return list old binding values (missing arguments old value). makes easy restore original environment state: env_bind() now supports binding missing arguments removing bindings zap sentinels. env_bind(env, foo = ) binds missing argument env_bind(env, foo = zap()) removes foo binding. inherit argument env_get() env_get_list() changed position. now comes default. scoped_bindings() with_bindings() can now called without bindings. env_clone() now recreates active bindings correctly. env_get() now evaluates promises active bindings since internal objects exposed R level (#554) env_print() calls get_env() argument, making easier see environment closures quosures (#567). env_get() now supports retrieving missing arguments inherit FALSE.","code":"old <- env_bind(env, foo = \"foo\", bar = \"bar\") env_bind(env, !!!old)"},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"calls-0-3-0","dir":"Changelog","previous_headings":"","what":"Calls","title":"rlang 0.3.0","text":"is_call() now accepts multiple namespaces. instance is_call(x, \"list\", ns = c(\"\", \"base\")) match x list() ’s base::list(): call_modify() better support ... now treats like named argument. call_modify(call, ... = ) adds ... call call_modify(call, ... = NULL) removes . call_modify() now preserves empty arguments. longer necessary use missing_arg() add missing argument call. possible thanks new .preserve_empty option dots_list(). call_modify() now supports removing unexisting arguments (#393) passing multiple arguments name (#398). new .homonyms argument controls treat arguments. call_standardise() now handles primitive functions like ~ properly (#473). call_print_type() indicates call deparsed printed console R: prefix, infix, special form. call_ functions call_modify() now correctly check input right type (#187).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"other-improvements-and-fixes-0-3-0","dir":"Changelog","previous_headings":"","what":"Other improvements and fixes","title":"rlang 0.3.0","text":"New function zap() returns sentinel instructs functions like env_bind() call_modify() objects removed. New function rep_named() repeats value along character vector names. New function exec() simpler replacement invoke() (#536). invoke() soft-deprecated. Lambda functions created formulas as_function() now classed. Use is_lambda() check function created formula shorthand. is_integerish() now supports large double values (#578). are_na() now requires atomic vectors (#558). operator %@% now replacement version update attributes object (#207). fn_body() always returns { block, even function single expression. instance fn_body(function(x) ()) returns quote({ () }). is_string() now returns FALSE NA_character_. vector predicates rewritten C performance. finite argument is_integerish() now NULL default. Missing values now considered non-finite consistency base::.finite(). is_bare_integerish() is_scalar_integerish() gain finite argument consistency is_integerish(). flatten_if() squash_if() now handle primitive functions like base::.list() predicates. is_symbol() now accepts character vector names mach symbol . parse_exprs() parse_quos() now support character vectors. Note output may longer input string may yield multiple expressions (\"foo; bar\"). parse_quos() now adds quosures class output.","code":""},{"path":[]},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"soft-deprecated-functions-and-arguments-0-3-0","dir":"Changelog","previous_headings":"Lifecycle","what":"Soft-deprecated functions and arguments","title":"rlang 0.3.0","text":"rlang 0.3.0 introduces new warning mechanism soft-deprecated functions arguments. warning issued, one circumstances: rlang attached library() call. deprecated function called global environment. addition, deprecation warnings appear per session order disruptive. Deprecation warnings shouldn’t make R CMD check fail packages using testthat. However, expect_silent() can transform warning hard failure.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"tidyeval-0-3-0","dir":"Changelog","previous_headings":"Lifecycle > Soft-deprecated functions and arguments","what":"tidyeval","title":"rlang 0.3.0","text":".data[[foo]] now unquote operator. guarantees foo evaluated context rather data mask makes easier treat .data[[\"bar\"]] way symbol. instance, help ensuring group_by(df,   .data[[\"name\"]]) group_by(df, name) produce column name. Automatic naming expressions now uses new deparser (still unexported) instead quo_text(). Following change, automatic naming now compatible object types (via pillar::type_sum() available), prevents multi-line names, ensures name .data[[\"name\"]] given default name. Supplying name !!! calls soft-deprecated. name ignored names spliced vector applied. Quosure lists returned quos() enquos() now “list-” behaviour: types new elements checked adding objects list. Consequently, assigning non-quosure objects quosure lists now soft-deprecated. Please coerce bare list .list() beforehand. as_quosure() now requires explicit environment symbols calls. typically environment expression created. names() length() methods data pronouns deprecated. longer valid write names(.data) length(.data). Using .character() quosures soft-deprecated (#523).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"miscellaneous-0-3-0","dir":"Changelog","previous_headings":"Lifecycle > Soft-deprecated functions and arguments","what":"Miscellaneous","title":"rlang 0.3.0","text":"Using get_env() without supplying environment now soft-deprecated. Please use current_env() retrieve current environment. frame stack API soft-deprecated. functionality replaced trace_back(). new_vector_along() family soft-deprecated functions longer type equivalent rep_along() rep_named() calls without added clarity. Passing environment wrappers like formulas functions env_ functions now soft-deprecated. internal genericity causing confusion (see issue #427). now extract environment separately calling functions. change concerns env_depth(), env_poke_parent(), env_parent<-, env_tail(), set_env(), env_clone(), env_inherits(), env_bind(), scoped_bindings(), with_bindings(), env_poke(), env_has(), env_get(), env_names(), env_bind_exprs() env_bind_fns(). cnd_signal() now always installs muffling restart non-critical conditions. Consequently .mufflable argument soft-deprecated longer effect.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"deprecated-functions-and-arguments-0-3-0","dir":"Changelog","previous_headings":"Lifecycle","what":"Deprecated functions and arguments","title":"rlang 0.3.0","text":"Deprecated functions arguments issue warning inconditionally, per session. Calling UQ() UQS() rlang namespace qualifier deprecated rlang 0.3.0. Just use unqualified forms instead: Although soft-deprecated since rlang 0.2.0, UQ() UQS() can still used now. call argument abort() condition constructors now deprecated favour storing full backtraces. .standardise argument call_modify() deprecated. Please use call_standardise() beforehand. sentinel argument env_tail() deprecated renamed last.","code":"# Bad rlang::expr(mean(rlang::UQ(var) * 100))  # Ok rlang::expr(mean(UQ(var) * 100))  # Good rlang::expr(mean(!!var * 100))"},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"defunct-functions-and-arguments-0-3-0","dir":"Changelog","previous_headings":"Lifecycle","what":"Defunct functions and arguments","title":"rlang 0.3.0","text":"Defunct functions arguments throw error used. as_dictionary() now defunct. experimental function rst_muffle() now defunct. Please use cnd_muffle() instead. Unlike predecessor, cnd_muffle() generic. marked calling handler thus can passed directly with_handlers() muffle specific conditions (specific subclasses warnings). cnd_inform(), cnd_warn() cnd_abort() retired defunct. old cnd_message(), cnd_warning(), cnd_error() new_cnd() constructors deprecated rlang 0.2.0 now defunct. Modifying condition cnd_signal() defunct. addition, creating condition cnd_signal() soft-deprecated, please use new function [signal()] instead. inplace() renamed calling() follow base R terminology closely.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"functions-and-arguments-in-the-questioning-stage-0-3-0","dir":"Changelog","previous_headings":"Lifecycle","what":"Functions and arguments in the questioning stage","title":"rlang 0.3.0","text":"longer convinced functions right approach precise alternative yet. functions restart API now questioning lifecycle stage. clear yet whether want recommend restarts style programming R. prepend() modify() questioning stage, well as_logical(), as_character(), etc. still figuring vector tools belong rlang. flatten(), squash() atomic variants now questioning lifecycle stage. slightly different semantics flattening functions purrr currently rethinking approach flattening new typing facilities vctrs package.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-022","dir":"Changelog","previous_headings":"","what":"rlang 0.2.2","title":"rlang 0.2.2","text":"CRAN release: 2018-08-16 maintenance release fixes several garbage collection protection issues.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-021","dir":"Changelog","previous_headings":"","what":"rlang 0.2.1","title":"rlang 0.2.1","text":"CRAN release: 2018-05-30 maintenance release fixes several tidy evaluation issues. Functions tidy dots support now allow splicing atomic vectors. Quosures longer capture current srcref. Formulas now evaluated correct environment eval_tidy(). fixes issues dplyr tidy-evaluation interfaces.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-020","dir":"Changelog","previous_headings":"","what":"rlang 0.2.0","title":"rlang 0.2.0","text":"CRAN release: 2018-02-20 release rlang mostly effort polishing tidy evaluation framework. tidy eval functions operators rewritten C order improve performance. Capture expression, quasiquotation, evaluation quosures now vastly faster. UI side, many inconveniences affected first release rlang solved: !! operator now precedence unary + - allows much natural syntax: !!> b unquotes rather whole > b expression. enquo() works magrittr pipes: mtcars %>% select(!!enquo(var)). enquos() variant quos() natural interface capturing multiple arguments .... See first section complete list changes tidy evaluation framework. release also polishes rlang API. Many functions renamed get better feel consistency clarity API. Note rlang whole still maturing functions even experimental. order make things clearer users rlang, started develop set conventions document current stability function. now find “lifecycle” sections documentation topics. addition gathered lifecycle information ?rlang::lifecycle help page. Please use functions marked stable projects unless prepared deal occasional backward incompatible updates.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"tidy-evaluation-0-2-0","dir":"Changelog","previous_headings":"","what":"Tidy evaluation","title":"rlang 0.2.0","text":"backend quos(), exprs(), list2(), dots_list(), etc now written C. greatly improve performance dots capture, especially splicing operator !!! now scales much better (’ll see 1000x performance gain cases). unquoting algorithm also improved makes enexpr() enquo() efficient well. tidy eval !! operator now binds tightly. longer wrap parentheses, .e. !!x > y unquote x. Technically !! operator precedence unary - +. means !!:b !!+ b equivalent (!!):b (!!) + b. hand !!^b !!$b equivalent !!(^b) !!($b). print method quosures greatly improved. Quosures longer appear formulas expressions prefixed ^; quosures colourised according environment; unquoted objects displayed angular brackets instead code (.e. unquoted integer vector shown <int: 1, 2> rather 1:2); unquoted S3 objects displayed using pillar::type_sum() available. New enquos() function capture arguments. treats ... way quos() can also capture named arguments just like enquo(), .e. one level . comparison quos(arg) captures name arg rather expression supplied arg argument. addition, enexprs() like enquos() like exprs() returns bare expressions. ensyms() expects strings symbols. now possible use enquo() within magrittr pipe: Technically, enquo() now also captures arguments parents current environment rather just current environment. flip side increased flexibility made typo name variable want capture, object name exists anywhere parent contexts, capture object rather getting error. quo_expr() renamed quo_squash() order better reflect lossy operation flattens nested quosures. !!! now accepts kind objects consistency. Scalar types treated vectors length 1. Previously symbolic objects like symbols calls treated . ensym() new variant enexpr() expects symbol string always returns symbol. complex expression supplied fails error. exprs() quos() gain .unquote_names arguments switch interpretation := name operator. useful programming language targetting APIs data.table. exprs() gains .named option auto-label arguments (#267). Functions taking dots value rather expression (e.g. regular functions, quoting functions) restricted set unquoting operations. support := !!!, top-level. .e. dots_list(!!! x) valid dots_list(nested_call(!!! x)) (#217). Functions taking dots list2() dots_list() now support splicing NULL values. !!! NULL equivalent !!! list() (#242). Capture operators now support evaluated arguments. Capturing forced evaluated argument exactly unquoting argument: actual object (even vector) inlined expression. Capturing forced argument occurs use enquo(), enexpr(), etc late. also happens quoting function supplied lapply() try quote first argument S3 method (necessarily evaluated order detect class dispatch ). (#295, #300). Parentheses around !! automatically removed. makes generated expression call cleaner: (!! sym(\"name\"))(arg). Note removing parentheses never affect actual precedence within expression parentheses useful parsing code text. parentheses also added R printing code needed (#296). Quasiquotation now supports !! !!! functional forms: consistent way native R operators parses function calls. new functional forms preferred UQ() UQS(). now questioning latter might deprecate future release. quasiquotation parser now gives meaningful errors corner cases help figure wrong. New getters setters quosures: quo_get_expr(), quo_get_env(), quo_set_expr(), quo_set_env(). Compared get_expr() etc, accessors work quosures slightly efficient. quo_is_symbol() quo_is_call() now take set arguments is_symbol() is_call(). enquo() enexpr() now deal default values correctly (#201). Splicing list longer mutates (#280).","code":"select_one <- function(df, var) {   df %>% dplyr::select(!!enquo(var)) } expr(`!!`(var)) quo(call(`!!!`(var)))"},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"conditions-0-2-0","dir":"Changelog","previous_headings":"","what":"Conditions","title":"rlang 0.2.0","text":"new functions cnd_warn() cnd_inform() transform conditions warnings messages signalling . cnd_signal() now returns invisibly. cnd_signal() cnd_abort() now accept character vectors create typed conditions several S3 subclasses. is_condition() now properly exported. Condition signallers cnd_signal() abort() now accept call depth call arguments. allows plucking call call stack (#30). New helper catch_cnd(). small wrapper around tryCatch() captures returns signalled condition. returns NULL none signalled. cnd_abort() now adds correct S3 classes error conditions. fixes error catching, instance testthat::expect_error().","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"environments-0-2-0","dir":"Changelog","previous_headings":"","what":"Environments","title":"rlang 0.2.0","text":"env_get_list() retrieves muliple bindings environment named list. with_bindings() scoped_bindings() establish temporary bindings environment. is_namespace() snake case wrapper around isNamespace().","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"various-features-0-2-0","dir":"Changelog","previous_headings":"","what":"Various features","title":"rlang 0.2.0","text":"New functions inherits_any(), inherits_all(), inherits_only(). allow testing inheritance multiple classes. _any variant equivalent base::inherits() explicit behaviour. inherits_all() checks classes present order inherits_only() checks class vectors identical. New fn_fmls<- fn_fmls_names<- setters. New function experimental function chr_unserialise_unicode() turning characters serialised unicode point form (e.g. <U+xxxx>) UTF-8. addition, as_utf8_character() now translates well. (@krlmlr) expr_label() now supports quoted function definition calls (#275). call_modify() call_standardise() gain argument specify environment. call definition looked environment call modify standardise wrapped quosure. is_symbol() gains name argument check symbol name matches string (#287). New rlang_box class. purpose similar AsIs class base::(), .e. protects value temporarily. However wrapping value scalar list. Use new_box() create boxed value, is_box() test boxed value, unbox() unbox . new_box() is_box() accept optional subclass. vector constructors new_integer(), new_double_along() etc gain names argument. case _along family defaults names input vector.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"bugfixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"rlang 0.2.0","text":"nested quosures evaluated eval_tidy(), .env pronoun now correctly refers current quosure evaluation (#174). Previously always refer environment outermost quosure. as_pairlist() (part experimental API) now supports NULL objects type pairlist (#397). Fixed performance bug set_names() caused full copy vector names (@jimhester, #366).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"api-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"API changes","title":"rlang 0.2.0","text":"rlang API maturing still flux. However made effort better communicate parts stable. introduce breaking changes stable functions unless payoff change worth trouble. See ?rlang::lifecycle lifecycle status exported functions. particle “lang” renamed “call”: lang() renamed call2(). new_language() ben renamed new_call(). is_lang() renamed is_call(). haven’t replaced is_unary_lang() is_binary_lang() redundant n argument is_call(). call accessors lang_fn(), lang_name(), lang_args() etc soft-deprecated renamed call_ prefix. rlang 0.1 calls called “language” objects order follow R type nomenclature returned base::typeof(). wanted avoid adding confusion S modes R types. hindsight find better use meaningful type names. now use term “data mask” instead “overscope”. think data mask natural name context R. say objects user data mask objects current environment. makes reference object masking search path due mechanism (technical terms, lexical scoping hierarchically nested environments). Following new terminology, new functions as_data_mask() new_data_mask() replace as_overscope() new_overscope(). as_data_mask() also consistent interface. functions meant developers tidy evaluation interfaces. longer require data mask (previously called overscope) cleaned evaluation. overscope_clean() thus soft-deprecated without replacement.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"breaking-changes-0-2-0","dir":"Changelog","previous_headings":"API changes","what":"Breaking changes","title":"rlang 0.2.0","text":"!! now binds tightly order match intuitive parsing tidy eval code, e.g. !! x > y now equivalent (!! x) > y. corollary new syntax now explicit want unquote whole expression right !!. instance explicitly write !! (x > y) unquote x > y rather just x. UQ(), UQS() := now issue error called directly. previous definitions caused surprising results operators invoked wrong places (.e. quasiquoted arguments). prefix form `!!`() now alias !! rather UQE(). makes line regular R syntax operators parsed regular calls, e.g. + b parsed `+`(, b) forms completely equivalent. Also prefix form `!!!`() now equivalent !!!. UQE() now deprecated order simplify syntax quasiquotation. Please use !! get_expr(x) instead. expr_interp() now returns formula instead quosure supplied formula. is_quosureish() as_quosureish() deprecated. functions assumed quosures formulas implementation detail. new_cnd() now cnd() consistency constructors. Also, cnd_error(), cnd_warning() cnd_message() now error_cnd(), warning_cnd() message_cnd() follow naming scheme according type output suffix rather prefix. is_node() now returns TRUE calls well is_pairlist() return TRUE NULL objects. Use is_node_list() determine whether object either type pairlist NULL. Note functions still experimental. set_names() longer automatically splices lists character vectors moving away automatic splicing semantics.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"upcoming-breaking-changes-0-2-0","dir":"Changelog","previous_headings":"API changes","what":"Upcoming breaking changes","title":"rlang 0.2.0","text":"Calling functional forms unquote operators rlang namespace qualifier soft-deprecated. UQ() UQS() function calls make sense namespace . Supporting namespace qualifiers complicates implementation unquotation misleading nature unquoting (syntactic operators quotation-time rather function calls evaluation-time). now questioning UQ() UQS() functional forms !!. !! !!! native R operators, parse functional calls `!!`() `!!!`(). now preferred way unquote function call rather operators. haven’t decided yet whether deprecate UQ() UQS() future. case recommend using new functional forms. parse_quosure() parse_quosures() soft-deprecated favour parse_quo() parse_quos(). new names consistent rule abbreviated suffixes indicate return type function. addition new functions require callers explicitly supply environment quosures. Using f_rhs() f_env() quosures soft-deprecated. fact quosures formulas implementation detail might change future. Please use quo_get_expr() quo_get_env() instead. quo_expr() soft-deprecated favour quo_squash(). quo_expr() misnomer implied mere expression acccessor quosures whereas really lossy operation squashed nested quosures. renaming lang particle call, functions soft-deprecated: lang(), is_lang(), lang_fn(), lang_name(), lang_args(). addition, lang_head() lang_tail() soft-deprecated without replacement low level accessors rarely needed. as_overscope() soft-deprecated favour as_data_mask(). node setters renamed mut_node_ prefix node_poke_. change follows new naming convention rlang mutation referred “poking”. splice() now questioning stage needed given !!! operator works functions taking dots dots_list(). lgl_len(), int_len() etc soft-deprecated renamed new_ prefix, e.g. new_logical() new_integer(). consistency non-variadic object constructors. ll() now alias list2(). consistent new call2() constructor calls. list2() call2() versions list() call() support splicing lists !!!. ll() remains around shorthand users like conciseness. Automatic splicing lists vector constructors (e.g. lgl(), chr(), etc) now soft-deprecated. Please explicit splicing operator !!!.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-016","dir":"Changelog","previous_headings":"","what":"rlang 0.1.6","title":"rlang 0.1.6","text":"CRAN release: 2017-12-21 maintenance release anticipation forthcoming change R’s C API (use MARK_NOT_MUTABLE() instead SET_NAMED()). New function is_reference() check whether two objects one .","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-014","dir":"Changelog","previous_headings":"","what":"rlang 0.1.4","title":"rlang 0.1.4","text":"CRAN release: 2017-11-05 eval_tidy() longer maps lists returns literally. behaviour overlook past refactorings never documented.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-012","dir":"Changelog","previous_headings":"","what":"rlang 0.1.2","title":"rlang 0.1.2","text":"CRAN release: 2017-08-09 hotfix release makes rlang compatible R 3.1 branch.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-011","dir":"Changelog","previous_headings":"","what":"rlang 0.1.1","title":"rlang 0.1.1","text":"CRAN release: 2017-05-18 release includes two important fixes tidy evaluation: Bare formulas now evaluated correct environment tidyeval functions. enquo() now works properly within compiled functions. release, constants optimised bytecode compiler couldn’t enquoted.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"new-functions-0-1-1","dir":"Changelog","previous_headings":"","what":"New functions:","title":"rlang 0.1.1","text":"new_environment() constructor creates child empty environment takes optional named list data populate . Compared env() child_env(), meant create environments data structures rather part scope hierarchy. new_call() constructor creates calls callable object (function expression) pairlist arguments. useful avoid costly internal coercions lists pairlists arguments.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"ui-improvements-0-1-1","dir":"Changelog","previous_headings":"","what":"UI improvements:","title":"rlang 0.1.1","text":"env_child()’s first argument now .parent instead parent. mut_ setters like mut_attrs() environment helpers like env_bind() env_unbind() now return (modified) input invisibly. follows tidyverse convention functions called primarily side effects return input invisibly. is_pairlist() now returns TRUE NULL. added is_node() test actual pairlist nodes. words, is_pairlist() tests data structure is_node() tests type.","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"bugfixes-0-1-1","dir":"Changelog","previous_headings":"","what":"Bugfixes:","title":"rlang 0.1.1","text":"env() env_child() can now get arguments whose names start .. Prior fix, arguments partial-matching env_bind()’s .env argument. internal replace_na() symbol renamed avoid collision exported function tidyverse. solves issue occurring old versions R prior 3.3.2 (#133).","code":""},{"path":"https://rlang.r-lib.org/dev/news/index.html","id":"rlang-010","dir":"Changelog","previous_headings":"","what":"rlang 0.1.0","title":"rlang 0.1.0","text":"Initial release.","code":""}]
