% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cnd-abort.R, R/cnd-signal.R
\name{abort}
\alias{abort}
\alias{warn}
\alias{inform}
\alias{signal}
\alias{interrupt}
\title{Signal an error, warning, or message}
\usage{
abort(
  message = NULL,
  class = NULL,
  ...,
  call = caller_call(),
  trace = NULL,
  parent = NULL,
  .file = NULL,
  .subclass = deprecated()
)

warn(
  message = NULL,
  class = NULL,
  ...,
  .frequency = c("always", "regularly", "once"),
  .frequency_id = NULL,
  .subclass = deprecated()
)

inform(
  message = NULL,
  class = NULL,
  ...,
  .file = NULL,
  .frequency = c("always", "regularly", "once"),
  .frequency_id = NULL,
  .subclass = deprecated()
)

signal(message, class, ..., .subclass = deprecated())

interrupt()
}
\arguments{
\item{message}{The message to display. Character vectors are
formatted with \code{\link[=format_error_bullets]{format_error_bullets()}}. The first element
defines a message header and the rest of the vector defines
bullets. Bullets named \code{i} and \code{x} define info and error bullets
respectively, with special Unicode and colour formatting applied
if possible.

If a message is not supplied, it is expected that the message is
generated lazily through \link[=cnd_message]{conditionMessage()}. In
that case, \code{class} must be supplied. Only \code{inform()} allows empty
messages as it is occasionally useful to build user output
incrementally.}

\item{class}{Subclass of the condition. This allows your users
to selectively handle the conditions signalled by your functions.}

\item{...}{Additional data to be stored in the condition object.}

\item{call}{An expression (as returned by e.g.
\code{sys.call()}) representing the context in which the error
occurred. If non-null, the call is stripped from its arguments to
keep it simple.

Can also be an execution environment of a currently running
function (as returned by e.g. \code{parent.frame()}). The
corresponding call is then retrieved.}

\item{trace}{A \code{trace} object created by \code{\link[=trace_back]{trace_back()}}.}

\item{parent}{A parent condition object created by \code{\link[=abort]{abort()}}.}

\item{.file}{A connection or a string specifying where to print the
message. The default depends on the context, see the \code{stdout} vs
\code{stderr} section.}

\item{.subclass}{This argument was renamed to \code{class} in rlang
0.4.2.  It will be deprecated in the next major version. This is
for consistency with our conventions for class constructors
documented in \url{https://adv-r.hadley.nz/s3.html#s3-subclassing}.}

\item{.frequency}{How frequently should the warning or message be
displayed? By default (\code{"always"}) it is displayed at each
time. If \code{"regularly"}, it is displayed once every 8 hours. If
\code{"once"}, it is displayed once per session.}

\item{.frequency_id}{A unique identifier for the warning or
message. This is used when \code{.frequency} is supplied to recognise
recurring conditions. This argument must be supplied if
\code{.frequency} is not set to \code{"always"}.}
}
\description{
These functions are equivalent to base functions \code{\link[base:stop]{base::stop()}},
\code{\link[base:warning]{base::warning()}}, and \code{\link[base:message]{base::message()}}, but make it easy to supply
condition metadata:
\itemize{
\item Supply \code{class} to create a classed condition. Typed
conditions can be captured or handled selectively, allowing for
finer-grained error handling.
\item Supply metadata with named \code{...} arguments. This data will be
stored in the condition object and can be examined by handlers.
}

\code{interrupt()} allows R code to simulate a user interrupt of the
kind that is signalled with \code{Ctrl-C}. It is currently not possible
to create custom interrupt condition objects.
}
\details{
\itemize{
\item \code{abort()} and \code{warn()} temporarily set the \code{warning.length}
global option to the maximum value (8170), unless that option has
been changed from the default value. The default limit (1000
characters) is especially easy to hit when the message contains a
lot of ANSI escapes, as created by the crayon or cli packages
}
}
\section{Backtrace}{


Unlike \code{stop()} and \code{warning()}, these functions don't include call
information by default. This saves you from typing \code{call. = FALSE}
and produces cleaner error messages.

A backtrace is always saved into error objects. You can print a
simplified backtrace of the last error by calling \code{\link[=last_error]{last_error()}}
and a full backtrace with \code{summary(last_error())}.

You can also display a backtrace with the error message by setting
the option \code{\link{rlang_backtrace_on_error}}. It supports the following
values:
\itemize{
\item \code{"reminder"}: Invite users to call \code{rlang::last_error()} to see a
backtrace.
\item \code{"branch"}: Display a simplified backtrace.
\item \code{"collapse"}: Display a collapsed backtrace tree.
\item \code{"full"}: Display a full backtrace tree.
\item \code{"none"}: Display nothing.
}
}

\section{Muffling and silencing conditions}{


Signalling a condition with \code{inform()} or \code{warn()} causes a message
to be displayed in the console. These messages can be muffled with
\code{\link[base:message]{base::suppressMessages()}} or \code{\link[base:warning]{base::suppressWarnings()}}.

\code{inform()} and \code{warn()} messages can also be silenced with the
global options \code{rlib_message_verbosity} and
\code{rlib_warning_verbosity}. These options take the values:
\itemize{
\item \code{"default"}: Verbose unless the \code{.frequency} argument is
supplied.
\item \code{"verbose"}: Always verbose.
\item \code{"quiet"}: Always quiet.
}

When set to quiet, the message is not displayed and the condition
is not signalled.
}

\section{\code{stdout} and \code{stderr}}{


By default, \code{abort()} and \code{inform()} print to standard output in
interactive sessions. This allows rlang to be in control of the
appearance of messages in IDEs like RStudio.

There are two situations where messages are streamed to \code{stderr}:
\itemize{
\item In non-interactive sessions, messages are streamed to standard
error so that R scripts can easily filter them out from normal
output by redirecting \code{stderr}.
\item If a sink is active (either on output or on messages) messages
are always streamd to \code{stderr}.
}

These exceptions ensure consistency of behaviour in interactive and
non-interactive sessions, and when sinks are active.
}

\examples{
# These examples are guarded to avoid throwing errors
if (FALSE) {

# Signal an error with a message just like stop():
abort("Something bad happened")

# Give a class to the error:
abort("Something bad happened", "somepkg_bad_error")

# This will allow your users to handle the error selectively
tryCatch(
  somepkg_function(),
  somepkg_bad_error = function(err) {
    warn(conditionMessage(err)) # Demote the error to a warning
    NA                          # Return an alternative value
  }
)

# You can also specify metadata that will be stored in the condition:
abort("Something bad happened", "somepkg_bad_error", data = 1:10)

# This data can then be consulted by user handlers:
tryCatch(
  somepkg_function(),
  somepkg_bad_error = function(err) {
    # Compute an alternative return value with the data:
    recover_error(err$data)
  }
)

# If you call low-level APIs it is good practice to handle
# technical errors and rethrow them with a more meaningful
# message. Always prefer doing this from `withCallingHandlers()`
# rather than `tryCatch()` because the former preserves the stack
# on error and makes it possible for users to use `recover()`.
file <- "http://foo.bar/baz"
try(withCallingHandlers(
  download(file),
  error = function(err) {
    msg <- sprintf("Can't download `\%s`", file)
    abort(msg, parent = err)
}))
# Note how we supplied the parent error to `abort()` as `parent` to
# get a decomposition of error messages across error contexts.

# Unhandled errors are saved automatically by `abort()` and can be
# retrieved with `last_error()`. The error prints with a simplified
# backtrace:
abort("Saved error?")
last_error()

# Use `summary()` to print the full backtrace and the condition fields:
summary(last_error())

}
}
\seealso{
\code{\link[=with_abort]{with_abort()}} to convert all errors to rlang errors.
}
