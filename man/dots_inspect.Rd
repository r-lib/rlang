% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dots.R
\name{dots_inspect}
\alias{dots_inspect}
\alias{dots_inspect_}
\title{Inspect dots}
\usage{
dots_inspect(..., .only_dots = FALSE)

dots_inspect_(dots, stack, only_dots = FALSE)
}
\arguments{
\item{...}{Dots to inspect.}

\item{.only_dots, only_dots}{Whether to stop introspection once
forwarded dots have been climbed. Setting this to \code{TRUE} is
only useful for inspecting dots (cf. \code{\link{tidy_dots}()}
which does not follow symbols).}

\item{dots}{Dots to inspect.}

\item{stack}{A \code{call_stack} object as returned by
\code{\link{call_stack}()}.}
}
\description{
Runs \code{\link{arg_inspect}()} for each dots element, and return the
results in a list.
}
\details{
\code{only_dots} controls whether dotted arguments should be fully
or partially inspected. When \code{TRUE}, only forwarded dots are
climbed. Symbols bound to a promise are not. See the example
section.

\code{dots_inspect_()} is the standard evaluation version of
\code{dots_inspect()} and takes a list of dots as captured by
\code{\link{frame_dots}()} or \code{\link{dots}()}, and a call
stack as returned by \code{\link{call_stack}()}.
}
\examples{
# The following example focuses on the difference between full and
# partial introspection of dots, which can be difficult to grasp.

h <- function(...) {
  # Let's parameterise `only_dots` with a global variable
  dots_inspect(..., .only_dots = only_dots)
}

g <- function(...) {
  # Here dots are forwarded from g to h. The first node of `...` in
  # h's frame environment is bound to a promise, pledging to evaluate
  # `..1` in g's frame environment.
  h(...)
}

f <- function(arg) {
  # Here the first node of `...` in g's frame environment is bound to
  # a promise, pledging to evaluate `arg` in f's frame environment.
  g(arg)
}

# Here `arg` is bound to a promise, pledging to evaluate `foo(bar)`
# in the global environment. We request full
# introspection. Arguments are climbed beyond forwarded dots and
# introspection is given the same scope as lazy
# evaluation. dots_inspect() thus returns information about `arg`
only_dots <- FALSE
f(foo(bar))

# Here, while `arg` is bound to a promise just like in the last
# call, argument instrospection is not given the same scope as lazy
# evaluation. dots_inspect() does not follow symbols bound to a
# promise and thus returns information about ..1, the expression
# supplied at the first call site (before forwarding dots). The
# expression is `arg` (a symbol that is bound to a promise), to be
# evaluated in f's call frame.
only_dots <- TRUE
f(foo(bar))
}
\seealso{
\code{\link{arg_inspect}()}
}

